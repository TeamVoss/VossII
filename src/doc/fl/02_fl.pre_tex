\section{Fl---The Meta Language of {\voss}}

In this section we provide an introduction to the functional language fl.

Similar to many theorem provers (e.g., the HOL%
\index{HOL}%
{}
system~\cite{HOLsystem,HOLbook}) the
{\voss} command language for the verification system is a general
purpose programming language%
\index{programming language}%
{}.
In fact, the fl language shows a strong degree of influence from
the version of ML%
\index{ML}%
{} used in the HOL-88%
\index{HOL-88}%
{} system.
However, there are several differences:  many syntactic but some
more fundamental.
In particular, the functional language used in {\voss} has lazy evaluation
semantics.
In other words, no expression is evaluated until it is
absolutely needed.
Similarly, no expression is evaluated more than once.
Another difference is that Boolean functions are first-class
objects and can be created, evaluated, compared and printed out.
For efficiency reasons these Boolean functions are represented as
ordered binary decision diagrams%
\index{ordered binary decision diagrams}%
{}.

Fl is an interactive language.
At the top-level one can for example: define functions (possibly of arity 0),
define new concrete types,
evaluate expressions, and
modify the parser.

\subsection{Invoking fl}

If the {\voss} system is installed on your system
and you have the suitable search path set up, it suffices
to type \verb@fl@ to get a stand-alone version of fl.

\FULLSCREEN{forte_start.jpg}

Note that the VOSS-LIBRARY-DIRECTORY%
\index{VOSS-LIBRARY-DIRECTORY}%
{} is installation dependent.

The fl program can take a number of arguments.
\index{command-line arguments}
In particular,
\begin{description}
%
\item[-f n]
Start fl by first reading in the content of the file named n.
%
\item[-I dir]
Set the default search directory%
\index{search directory}%
{} to dir.
%
\item[-noX or --noX]
do not use the graphical (X-windows) interface.
Useful when running batch oriented jobs.
Note that any calls to graphics primitives, will fail with a run time
exception when fl is run in the -noX mode.
\item[-use\_stdin or --use\_stdin]
Read inputs also from stdin as well as from the graphical interface.
\item[-use\_stdout --use\_stdout]
Read inputs also from stdin as well as from the graphical interface.
\item[--read\_input\_from\_file filename]
Read inputs continuously from the file 'filename'.
\item[--write\_output\_to\_file filename]
Write outputs to the file 'filename' in addition to the graphical
user interface.
\item[-r i]
Initialize the random number%
\index{random number}%
{} generator with the seed i.
This allows the {\tt rvariable}
\index{rvariable}%
{} command to create new sets
of random variable values.
See the rvariable command description in Section~\ref{rvariable} for
more details.
\item[-v fn]
Store the variable ordering obtained by dynamic variable re-ordering%
\index{variable re-ordering}%
{}
in the file fn.
\index{dynamic variable re-ordering}
\item[-h or --help]
Print out the available options and quit.
\end{description}

Any additional arguments to fl will be stored in the fl expression ARGS as
a list of strings.
For example:
\begin{hol}
% fl We must do 123 situps
\end{hol}
would yield:

\FULLSCREEN{forte_with_args_start.jpg}

\subsection{Help System}

To make it easier to use fl, there is an automatically generated help system
available by pushing the "Help" button in top right corner of
the user interface.
Whenever a function is defined, it is added to the online help system.
Furthermore, if the function declaration is preceded by some comments
(lines started with //), the comments will be displayed together with
information of the fixity (if any), number and types of input arguments, as
well as the type of the result of the function.
The help system allow the user to search by name, file, argument type(s) or
resulting type using regular globbing style patterns.
Also, if the function is defined by fl code, there will be a live link to the
code used to define the function.
For example, searching for functions with the word AND in them yield:

\FULLSCREEN{forte_help.jpg}

If the size of the help window is too small, and you don't want to make
the whole fl window larger, you can click on the ``detach'' button beside
the Functions tab to detach the help system.

\subsection{Embedding in Editors}

A very convenient way of using {\voss} is to run it within an editor.
There are currently three supported editors: vim, emacs and visual studio codes.
Both of these provide similar capabilities, but using different key-bindings
to better follow the traditions of each editor.
For details on how to enable vim, emacs or vscode integration, see the
README files in \verb@<VossII installation directory>/modes/vim@,
\verb@<VossII installation directory>/modes/emacs@ or \verb@<VossII installation directory>/modes/visual studio code@.


\subsection{Expressions}
\index{expressions}
The Fl prompt%
\index{prompt}%
{} is : so lines beginning with this contain
the user's input; all other lines are output of the system.
%%%START_CODE%%%%
2+3;
%%%END_CODE%%%%
Here we simply evaluated the expression 2+3 and fl reduced
it to normal form; in this case computed the result 5.

Note that {\voss} stores the result of the most recent expression
in a variable called {\tt it}.
\index{it}%
Thus, if you evaluate an expression, you can get a ``handle'' to it by using
{\tt it}.
%%%START_CODE%%%%
12 > 5 => 2+3 | 2-3;
it;
%%%END_CODE%%%%
Here we also illustrated the if-then-else%
\index{if-then-else}%
{} construct used in fl.





\subsection{Integer Expressions}

{\voss} provides arbitrary precisions integers as default.
All the usual arithmetic operations are available.
For example:
%%%START_CODE%%%%
123456789*9876543210;
-121/10;
2**256;
2**500 % 17;
((2**500 % 17) % 7) < 3;
%%%END_CODE%%%%
It should be pointed out that all the arithmetic operations are
overloaded with other data types (e.g., floating point numbers).
As a result, the type inferred for an expression is sometimes
more general than expected.
For example:
%%%START_CODE%%%%
let double x = x+x;
%%%END_CODE%%%%
is not of type \verb@int->int@, bit more general since it depends on the
overloaded \verb@+@ function.
Of course, you can use it on integers as you would expect:
%%%START_CODE%%%%
double 12;
%%%END_CODE%%%%
We will return to this later.

\subsection{Floating Point  Expressions}

The \verb@float@ type represents double precision floating point numbers.
A float must have a decimal point and a fraction digit.
It can additionally have an exponent (e).
For example:
%%%START_CODE%%%%
1.0;
.34;
-1.73e-12;
1.0 / 2.0;
sin(pi*45.0/180.0);
round(-3.7);
%%%END_CODE%%%%

The following floating point operations are available at start:
\begin{hol}
+ - * /                     -- The normal arithmetic operations

< <= = != > >=              -- The normal relational operations

**                          -- Raised to the power

abs                         -- Absolute value
ceil                        -- Smallest integer >= value
floor                       -- Largest integer <= value
round                       -- Integer closest to value

sqrt                        -- Square root

sin cos tan                 -- Sin, cos, and tangent in radians
asin acos atan              -- Arcsin, Arccos, etc. in radians

exp                         -- e to the power
log                         -- Natural logarithm
log10                       -- Logarithm based 10

float2str                   -- Convert float to a string
int2float                   -- Convert an integer to a string
str2float                   -- Convert a string to a float

pi                          -- The constant Pi.
\end{hol}


\subsection{Boolean Expressions}

All Boolean expressions%
\index{Boolean expression}%
{} in fl are maintained as ordered binary decision
diagrams. Hence, it
is very easy to compare complex Boolean expressions and to combine
them in different ways.

The constants true\index{true}
and false\index{false}
are denoted T and F respectively.

Boolean variables%
\index{Boolean variable}%
{} are created by variable%
\index{variable}%
{} s, where s is of type string.
If several variables (including vectors) are needed, the function VARS
is convenient since it both creates a zero-arity fl function for the
bit or bit-list (depending on whether the name is a single node name or
a vector name).
For example:
%%%START_CODE%%%%
variable "q";
VARS "a b c[3:0] d[1:0][2:0]";
a;
b;
c;
d;
%%%END_CODE%%%%

The system uses name equivalence, and thus
%%%START_CODE%%%%
let v = variable "v";
v=v;
variable "v" = variable"v";
%%%END_CODE%%%%

The
standard boolean functions
are available, i.e., AND%
\index{AND}%
{}, OR%
\index{OR}%
{}, NOT%
\index{NOT}%
{}, XOR%
\index{XOR}%
{}, and =%
\index{=}%
{} are all defined for objects of type Boolean.
Furthermore, there
is a special identity%
\index{identity}%
{} operator ==%
\index{==}%
{} that return true or false depending
on whether the two arguments
represent the same Boolean function or not.
To illustrate this, consider the following example:
%%%START_CODE%%%%
let e1 = a XOR b;
let e2 = a OR b;
// Not the same function
e1 == e2;
// Under what conditions is e1 equal to e2.
e1 = e2;
%%%END_CODE%%%%
It should be pointed out that the equal and not equal functions
(\verb@=@ and \verb@!=@) operate over any structure.


Note that unless an ordering has been installed explicitly (more below), the
variable ordering%
\index{variable ordering}%
{} in the OBDD representation is defined
by the order in which each variable function call {\em gets evaluated}.
Since fl is a fully lazy language%
\index{lazy language}%
{}, and thus the order in which expressions
are evaluated is often difficult to predict, it is strongly recommended
that each variable declaration is forced to be evaluated before it
is being used.
Alternatively, one can request that fl re-orders the variables
by evaluating the function var\_order%
\index{var\_order}%
{} and give as argument a list
of variable names.
fl will then apply the dynamic variable re-ordering mechanism and
enforce that the variables mentioned in the list will be the first
in the global BDD order and that they will occur in exactly this order.

Finally, by default, {\voss} will perform a dynamic re-ordering of the
BDD variables when certain thresholds are exceeded.
If this is not desirable, the vossrc variable "DYNAMIC-ORDERING"
can be set to "NO".
Similarly, a dynamic variable re-ordering can be triggered by the
command \verb@bdd_reorder@%
\index{bdd\_reorder}%
{} that takes an integer that determines the total number of sweeps that will
be performed.

Note that during a dynamic variable re-ordering, a small status window will be
opened at the bottom of the fl window showing the current status of the
re-ordering as well as providing a button to abort the re-ordering.

\subsubsection{Displaying and Analyzing BDDs}

The default style for printing Boolean expressions%
\index{printing Boolean expressions}%
{} is as a sum-of-products%
\index{sum-of-products}%
{}.
Since this may require printing an extremely large expression, there
is a user-settable limit on how many products that will be printed
and the maximum size of a product.
For more details how to modify these two parameters, see
Section~\ref{section:vossrc}.
For smaller BDDs, the function draw\_bdds can also be very useful.
%%%START_CODE%%%%
VARS "q[2:0] r[2:0]";
// Force creation
q fseq r fseq ();
// Order the variables sequentially
var_order ((md_expand_vector "q[2:0]")@(md_expand_vector "r[2:0]"));
draw_bdds T [q = r];
// Order the variables by interleaving them MSB to LSB
var_order (interleave [(md_expand_vector "q[3:0]"),
		       (md_expand_vector "r[3:0]")])
;
draw_bdds T [q = r];
%%%END_CODE%%%%
which would create the display
\begin{center}
\includegraphics[width=0.8\linewidth]{screen_shots/bdd_big.png}
\end{center}
and
\begin{center}
\includegraphics[width=0.2\linewidth]{screen_shots/bdd_small.png}
\end{center}

For larger BDDs, there are a number of helpful functions that can
be used to understand the BDD.
The are:
\begin{hol}
depends
forcing
truth_cover
example
enumerate_examples
\end{hol}
Depends%
\index{depends}%
{} is used to return a list of all BDD variables an expression depends on.
Note that the expression can be of any type since depends will recursively
traverse the whole expression looking for BDDs.

Forcing f%
\index{forcing}%
{} returns a substitution list (list of (variable,value) pairs) for all
variables that must take on some specific value for f to be true.

Truth\_cover%
\index{truth\_cover}%
{} takes a list of variables (vars) and a boolean function (f) and returns
the number of assignments to the variables in vars that makes f true.

Example%
\index{example}%
{} takes a preference (true or false) and a BDD f and returns
a substitution list that makes f true.
If there is a choice, the preference decides whether T or F should be selected.

Finally, \verb@enumerate_examples@ is a convenient way of getting some
randomly selected scalar values that makes a BDD true.

\subsubsection{Symbolic If-Then-Else}

One of the more unusual features of fl is that conditionals%
\index{conditional}%
\index{symbolic conditional}%
{} can be symbolic.
For example:
%%%START_CODE%%%%
let e1 = a XOR b;
// If-then-else with symbolic condition.
e1 => a | b;
%%%END_CODE%%%%
There is some restrictions on how these types of conditional if-then-else's
can be used.
With a few exceptions, both the then-case and the else-case has to be
structurally the same.
Effectively, they can only differ in Boolean values.
Thus
%%%START_CODE%%%%
a => (1,[b]) | (1,[a]);
%%%END_CODE%%%%
is acceptable, but
%%%START_CODE%%%%
a => (1,[b]) | (2,[a]);
%%%END_CODE%%%%
is not.

There are two major exceptions to this.
First, bvs (more about these in Section~\ref{section:bitvectors}) automatically
adjust to make the structures equal.
For example:
%%%START_CODE%%%%
let v1 = int2bv 3;
let v2 = int2bv 12;
let res = a => v1 | v2;
res;
%%%END_CODE%%%%
Note that res effectively encodes symbolically both of the alternatives.

The second exception to the requirement of structural similarity is
how the constructors for the option type is handled.
To make it possible to create symbolic data structures, the
handling of the optional constructors NONE and SOME is enhanced.
In particular, the optional data type constructor NONE matches not only
NONE but more importantly the SOME constructor and the result is the
SOME value.
An example of using this, consider the following symbolic binary tree structure.
%%%START_CODE%%%%
lettype stree = STREE {type::bv}
                      {o_val:: {bv} opt}        // Use bvs instead of integers!
                      {o_left :: {stree} opt}
                      {o_right :: {stree} opt}
;

// Define constructors for the symbolic binary tree
let leaf_type = int2bv 0;
let branch_type = int2bv 1;
let LF v = STREE leaf_type (SOME (int2bv v)) NONE NONE;
let BR l r = STREE branch_type NONE (SOME l) (SOME r);

// Define a function that adds up the leaves. Note: bvs are used instead of ints
letrec sum_leaves (STREE type o_val o_left o_right) =
        type = leaf_type => get_value o_val |
        (sum_leaves (get_value o_left)) + (sum_leaves (get_value o_right))
;

let t1 = BR (BR (LF 1) (LF 2)) (LF 3);
sum_leaves t1;

let t2 = BR (BR (BR (BR (LF 1) (LF 2)) (LF 3)) (LF 4)) (BR (LF 5) (LF 6));
sum_leaves t2;

// A symbolic tree
let st = a => t1 | t2;

// Note that sum_leaves still work for it.
sum_leaves (a => t1 | t2);
%%%END_CODE%%%%

\subsubsection{Advanced BDD Operations}

There are several ways of using quantification%
\index{quantification}%
{}.
The ``traditional'' !x. e%
\index{!.\,e}%
{} (for all x) and ?x. e%
\index{?x.\,e}%
{}
(there is an x) can be used as long as the type of x and e is bool.
In addition, you can also quantify away a variable in an expression
by Quant\_forall%
\index{Quant\_forall}%
{} v e or Quant\_thereis%
\index{Quant\_thereis}%
{} v e.
%%%START_CODE%%%%
!a. ?b. (a XOR b);
let a = variable "a"; let b = variable "b"; let c = variable "c";
a AND b OR c;
Quant_forall ["a"] (a AND b OR c);
Quant_thereis ["a","c"] (a AND b OR c);
%%%END_CODE%%%%
In fact, Quant\_forall and Quant\_thereis quantifies away all variables
in the list of variables.
For example:
%%%START_CODE%%%%
let v s = variable s;
let a = v "a"; let b = v "b"; let c = v "c"; let d = v "d";
let ex = (a AND NOT b);
ex;
let nex = ex AND (a=c) AND (b=d);
Quant_thereis ["a","b"] nex;
%%%END_CODE%%%%

A common operation when implementing a symbolic model checker, is
to perform a quantification for a product of two BDDs.
Rather than doing the conjunction and then the quantification, the
functions
\verb@relprod_forall@%
\index{relprod\_forall}%
{} and
\verb@relprod_thereis@ perform%
\index{relprod\_thereis}%
{} perform this combinations of operations much more efficiently.
See the help system for more details.

A common operation with BDDs is to simultaneously substitute some
expressions for (some) variables in the BDD.
For this purpose, there is a function called
\verb@substitute@%
\index{substitute}%
{}.
This function takes a substitution list (list of string name--Boolean
expression pairs), and an arbitrary fl expression.
It then traverses the expression and performs the substitution
on every object of type bool it encounters.
%%%START_CODE%%%%
VARS "a b c d";
let e = [(1,[a AND b XOR c]), (2,[T,T,a,b, d])];
e;
substitute [("a",T),("b",F),("c",F),("d",F)] e;
substitute [("a",b),("b",a)] e;
%%%END_CODE%%%%

When a BDD variable `x' is created, a ``next-state'' variable `x\_n' is also
created.
These two variables are always kept together in the variable order.
As a result, the size of a BDD in terms of ``current-state'' variables
is the same as it would in in terms of ``next-state'' variables.
To make this conversion easier, there are two helpful functions:
\verb@bdd_current2next@%
\index{bdd\_current2next}%
{} and \verb@bdd_next2current@%
\index{bdd\_next2current}.
For example,
%%%START_CODE%%%%
VARS "s[2:0]";

// Simple forward reachability code
let image R init =
    val (next_vars,cur_vars) = split (str_is_suffix "_n") (depends R) in
    letrec fwd cur =
	let next = bdd_next2current (Quant_thereis cur_vars (cur AND R)) in
	let cur' = cur OR next in
	cur == cur' => cur | fwd cur'
    in
    fwd init
;

// Simple backwards reachability code
let preimage R init =
    val (next_vars,cur_vars) = split (str_is_suffix "_n") (depends R) in
    letrec back cur =
	let prev = bdd_current2next (Quant_thereis next_vars (cur AND R)) in
	let cur' = cur OR prev in
	cur == cur' => cur | back cur'
    in
    bdd_next2current (back (bdd_current2next init))
;
%%%END_CODE%%%%

With these functions we could now do:
%%%START_CODE%%%%

// Example of simple state machine
let transition_relation =
    let s' = bdd_current2next s in
    let mk_trans (f,t) = (s = (int2bl 3 f)) AND (s' = (int2bl 3 t)) in
    let my_fsm = [(0,1),
		  (1,0), (1,1), (1,2),
		  (2,5),
		  (3,4), (3,2),
		  (4,3),
		  (5,5)]
    in
    itlist (\tr.\r. mk_trans tr OR r) my_fsm F
;

// Compute the set of states reachable from init
let init = (s = int2bl 3 0);
let final_image = image transition_relation init;
enumerate_examples 20 (depends s) final_image;

// Compute the set of states that could have taken us to final.
let final = (s = int2bl 3 3);
let res = preimage transition_relation final;
enumerate_examples 20 (depends s) res;

%%%END_CODE%%%%

A very common problem is to create a vector of Boolean variables
but restrict the possible values to be in a set.
For example, one might want to have a vector of 4 bits that has the
property that exactly one signal is high.
For this problem the param%
\index{param}%
{} is available.
Param takes a boolean condition c and returns a substitution list that
provides expressions for every variable in c such that
1) every truth assignment to the parametric variables will make c satisfied,
and 2) for every substitution to the variables in c that makes c satisfied
there is some truth assignment to the parametric variables so
(param c) is that substitution.
%%%START_CODE%%%%
VARS "a b s[2:0]";
param (a AND b);
param (a OR b);

// Note that this is a state vector that only takes on values
// that are in the final_image and that all states in final_image
// has some assignment to the variables.
substitute (param final_image) s;
%%%END_CODE%%%%

If one wants to solve for only some variables, i.e., treat the remainder
as symbolic constants, there is a fparam%
\index{fparam}%
{} function available.
See the help system for more details.

\subsubsection{Structural BDD Operations}

Sometimes one needs to write a function that walks over a BDD and perform
some operation.
For this task, the functions
top\_cofactor%
\index{top\_cofactor}%
{} and
bdd\_signature%
\index{bdd\_signature}%
{} are useful.
Of course, it is almost certain that any function walking over a BDD
needs to be memoized since the BDDs are DAGs and thus a tree structured
traversal can take time that grows exponentially with the size of the BDD!

Finally, it is sometimes useful to save a collection of BDDs to disk
to work with them in a fresh {\voss} invocation.
Thus, bdd\_save%
\index{bdd\_save}%
{} and
bdd\_load%
\index{bdd\_load}%
{} come in handy.

\subsection{Bexpr and SAT}

If you don't want to use BDDs for representing Boolean expressions, fl
provides \verb@bexpr@, which are essentially AND-INVERT directed acyclic
graphs.
Most of the Boolean operations, have a bexpr equivalent that is named the
same, except prefixed with a b.
For example:
%%%START_CODE%%%%
let a = bvariable "a";
let b = bvariable "b";
let c = bvariable "c";

let ex0 = bNOT (a bAND b);
ex0;

let ex1 = bNOT a bOR bNOT (b bAND (c bOR (b bAND bNOT c)));
ex1;

let ex2 = bNOT a bOR bNOT (b bAND (c bOR (bNOT b bAND c)));
ex2;
%%%END_CODE%%%%

Since bexprs are not canonical, one must use a SAT solver to determine
whether a bexpr is satisfiable or not.
Currently {\voss} uses MiniSAT~\cite{miniSAT} through the
\verb@bget_model@%
\index{bget\_model}%
\index{SAT}%
{} function call.

%%%START_CODE%%%%
let model = bget_model [(ex0 bXOR ex1)] 10;
// No model exists when ex0 and ex1 are different (i.e., ex0 == ex1)
model;

let model = bget_model [(ex0 bXOR ex2)] 10;
// A model is found
model;

bsubstitute model ex0;
bsubstitute model ex2;
%%%END_CODE%%%%

Like with BDDs, there are functions to recursively walk over bexprs.
Here the relevant functions are:
bget\_type%
\index{bget\_type}%
,
bget\_arguments%
\index{bget\_arguments}%
{} and
bget\_variable%
\index{bget\_variable}%
.

\subsection{Strings}

A sequence of characters enclosed between \verb@"@ is a string%
\index{string}%
{}.
The standard functions on strings are \verb@^@ (catenation%
\index{catenation}%
{}), explode%
\index{explode}%
{}
(make string into list of strings) and
implode%
\index{implode}%
{} (make list of strings into single string).
There a numerous other string functions.
For example:
%%%START_CODE%%%%

let q = "abc and _12!@@#";
let qq = "qw\"q qw";
q^qq;
explode q;
implode ["1", "2"];
filter (str_is_prefix "a") ["abc", "Ava", "vad", "bbAb", "aaa"];
filter (str_is_suffix "a") ["abc", "Ava", "vad", "bbAb", "aaa"];
filter (str_match "*a*") ["abc", "Ava", "vad", "bbAb", "aaa"];
qsort strcmp ["abc", "Ava", "vad", "bbAb", "aaa"];
let s = "A funny story often told is the story of";
strlen s;
strstr s "is";
substr s 1 25;
substr s 26 (-1);
sprintf "%s: %032b (%d)" "abc" 1423 1423;
%%%END_CODE%%%%

\subsection{Printf Family of Functions}

To make the conversion of values to strings easier, there is a
family of functions called \verb@sprintf@ that takes a format
string to guide the conversion.
The type of the sprintf function is determined by the format string

The format string is composed of zero  or more  directives: ordinary
characters (not \%), which are copied unchanged to the output stream;
and conversion specifications, each of which results in fetching zero
or more subsequent arguments. Each conversion specification is
introduced by the character \%, and ends with a conversion specifier.
In between there may be (in this order) zero or more flags, and an
optional length modifier.

The arguments must correspond properly (after type promotion) with the
conversion specifier. The arguments are used in the order given,
where each '*' and each conversion specifier asks for the next argument.

The character \% should be followed by zero or more of the following flags:
\begin{description}
\item[0]
The value should be zero padded.
\item[-]
The value should be left justified.
\end{description}
After this, one can give an optional decimal digit string (with nonzero
first digit) specifying a field width.
If the converted value has fewer characters
than the field width, it will be padded with spaces on the left (or
right, if the left-adjustment flag has been given). Instead of a decimal
digit string one may write \verb@*@  to specify that the field width is
given in the next argument.  A negative field  width is taken as a '-'
flag followed by a positive field width.
If the resulting value does not fit in the width given, an exception is
raised.

Finally, there is a conversion specifier, which is one of
\begin{description}
\item[b]
the integer argument will be converted to a binary number
\item[o]
the integer argument will be converted to an octal number
\item[d]
the integer argument will be converted to a signed decimal number
\item[x]
the integer argument will be converted to a hexadecimal number
\item[s]
the string argument will be copied out
\item[S]
the list of strings argument will be copied out enclosed in [] and each string separated by a comma.
\item[B]
the BDD (bool) argument will be converted to a string and copied to the output
\end{description}

For example:
%%%START_CODE%%%%
let conv i = sprintf "%0*b is the same as %x or %d\n" 16 i i i;
conv 2;
conv 142;
conv (-142);
%%%END_CODE%%%%


There are also an fprintf\index{fprintf}, printf\index{printf}, and
eprintf\index{eprintf} versions for writing the resulting string to
a stream, stdout, or as an error message respectively.

Similarly, there is a \verb@sscanf@ family of functions that can be
used to parse simple strings to values.
It uses the same type of format string, except neither 'S' or 'B'
are accepted.
For example:
%%%START_CODE%%%%
sscanf "(%d,%04b)-->%x" "(12,1101)-->4f";
%%%END_CODE%%%%


\subsection{Declarations}

The declaration%
\index{declaration}%
\index{declaration@toplevel}%
{} let x = e binds a computation of e to
the variable x.
Note that it does not evaluate e (since the language is lazy%
\index{lazy}%
{}).
Only if x is printed or used in some other expression that is evaluated
will it be evaluated.
Also, once e is evaluated, x will refer to the result of the evaluation
rather than the computation.
Hence, the expression e is evaluated at most once, but it may
not be evaluated at all.
%%%START_CODE%%%%
let x = 3+3;
%%%END_CODE%%%%
Note that when expressions are bound to variables, the system simply
prints out the inferred type%
\index{inferred type}%
{} of the expression. We will return to
the typing scheme in fl later.
For now, it suffices to say that fl tries to find as general type as
possible that is consistent with the type of the expression.

A declaration%
\index{declaration@local}%
{} can be made local to the evaluation of an expression
e by evaluating the expression decl in e.
For example:
%%%START_CODE%%%%
let y = let x = 4 in x-5;
%%%END_CODE%%%%
would bind the expression 4 to x only inside the expression
bound to y. Thus, we get:
%%%START_CODE%%%%
let x = 2;
let y = let x = 4 in x-5;
x;
y;
%%%END_CODE%%%%
fl is lexically scoped%
\index{scoping}%
{}, and thus
the binding in effect at the time of definition is the one used.
In other words, if we write:
%%%START_CODE%%%%
let x = 2;
let y = x*5;
let x = 12;
%%%END_CODE%%%%
and we then evaluate y we will get 10
rather than 60.


To bind several expressions%
\index{simultaneous bindings}
to several variables at the same time, a special keyword {\tt val}
\index{val}%
{}
is available to take a complicated object apart automatically.
For example, if q is an expression of type (int\verb@#@bool) then
we could write:
%%%START_CODE%%%%
let top_level q =
        val (i,b) = q in
        i < 3 => b | F
;
top_level (12,variable "a");
top_level (-2,variable "a");
%%%END_CODE%%%%
or
%%%START_CODE%%%%
val (a:b:rest) = [1,2,3,4,5];
a;
b;
rest;
%%%END_CODE%%%%

In general, the expression to the right of the val keyword
can be an arbitrary complex pattern similar to the patterns%
\index{patterns}%
{}
allowed in function definitions and lambda expressions.
For more details, see the section on pattern matching on page~\ref{val}.

\subsection{Functions}

To define a function%
\index{function}%
{} f with formal parameter x and body e one performs
the declaration: let f x = e.
To apply the function f to an actual parameter e one evaluates
the expression f e.
%%%START_CODE%%%%
let f x = x+2;
f 4;
%%%END_CODE%%%%
Note that the type inferred for f is essentially ``a function taking
an int as argument and returning an int''.
Applications binds more tightly than anything else in fl; thus for example:
f 3 * 4 would be evaluated as: ((f 3)*4) and thus yield 20.

Functions of several arguments can also be defined:
%%%START_CODE%%%%
let add x y = x+2*y;
add 1 4;
let f = add 1;
f 4;
%%%END_CODE%%%%
Applications associate%
\index{association rules}%
{} to the left so add 3 4 means (add 3) 4. In the
expression add 3, the
function add is partially applied to 3; the resulting value is the
function of type int\funarrow int which
adds 3 to twice its argument. Thus add takes its arguments one at a time.
We could have made add take a single argument of the Cartesian product%
\index{cartesian product}%
{}
type (int\verb@#@int):
%%%START_CODE%%%%
let add (x,y) = x+2*y;
add (3,4);
%%%END_CODE%%%%
As well as taking structured arguments (e.g. (3,4)) functions may also return
structured results:
%%%START_CODE%%%%
let manhat_dist (x1,y1) (x2,y2) = (x2-x1, y2-y1);
manhat_dist (1,1) (3,5);
let geometric_dist (x1,y1) (x2,y2) = sqrt ( (pow 2.0 (x1-x2)) + (pow 2.0 (y1-y2)));
geometric_dist (1.0,1.0) (3.0,5.0);
%%%END_CODE%%%%
The latter function illustrates the use of floats as well as integers.

Trying to print%
\index{print}%
{} a function with insufficient number of actual arguments
yield a dash for the function and the type of the expression is printed out.
For example:
%%%START_CODE%%%%
let manhat_dist (x1,y1) (x2,y2) = (x2-x1, y2-y1);
(5, manhat_dist (1,2));
%%%END_CODE%%%%
The only exception to this rule is for concrete types
for which the user has installed a printing function%
\index{printing function}%
{}.
For more details of concrete types, see page~\ref{concreteTypes}.

\subsection{Recursive Functions}

The following is an attempt to define the factorial function:
%%%START_CODE%%%%
let fact n = n=0 => 1 | n*fact (n-1);
%%%END_CODE%%%%
The problem is that any free variables in the body of a function have
the bindings they had
just before the function was declared; fact is such a free variable
in the body of the declaration
above, and since it is not defined before its own declaration, an error
results. To make things
clear consider:
%%%START_CODE%%%%
let f n = n+1;
let f n = n=0 => 1 | n*f (n-1);
f 3;
%%%END_CODE%%%%
Here 3 results in the evaluation of 3*(f 2), but now the first f is
used so f 2 evaluates to 2+1=3.
To make a function declaration hold within its own body, letrec%
\index{letrec}%
{}
instead of let must be used.
The correct recursive%
\index{recursive}%
{} definition of the factorial function is thus:
%%%START_CODE%%%%
letrec fact n = n=0 => 1 | n*fact (n-1);
fact 5;
%%%END_CODE%%%%

\subsection{Mutually Recursive Functions}

There is currently no direct support for mutually recursive functions, i.e.,
declaring a function f that needs to evaluate g, but g needs to evaluate f etc.
The work-around for this problem is to forward declare one of the functions.
The command: forward\_declare%
\index{forward\_declare}
allows a ``stub'' to be declared.
When the declarations of this functions comes later, the stub is
replaced with the actual definition.
To illustrate this, consider defining functions
that compute members of the Hofstadter Female and Male sequences:
%%%START_CODE%%%%
forward_declare {Male:: int-> int};

letrec Female 0 = 1
 /\    Female n = n - Male (Female (n-1))
;

letrec Male 0 = 0
 /\    Male n = n - Female (Male (n-1))
;

Female 10;

map Male (1--20);
%%%END_CODE%%%%
It should be pointed out that a function that is to be forward
declared, must be given the same type as it will get once it is defined.

\subsection{Memoization}

Sometimes, there are pure functions that take relatively simple inputs
and are heavily used with a relatively small set of inputs
and that take a long time to compute their results.
For these types of functions, memoization~\cite{memo-68}%
\index{memoization}%
{} is often very useful.
In fl, a function can be memoized simply by using
\verb@clet@ or \verb@cletrec@ instead of
\verb@let@ and \verb@letrec@ respectively.
The classical example is Fibonacci number:
%%%START_CODE%%%%
// Original version
letrec fib 1 = 1
 /\    fib 2 = 1
 /\    fib n = fib (n-1) + fib (n-2)
;

time (fib 30);

// Memoized version
cletrec fib 1 = 1
  /\    fib 2 = 1
  /\    fib n = fib (n-1) + fib (n-2)
;

time (fib 30);
%%%END_CODE%%%%

It is important to remember that a memoized function might not be
evaluated every time it is called.
Thus if the functions have side effects (e.g., prints out something),
the memoization of the function will lead to unexpected results.
Sometimes all subsequent calls will be found in the memo table.
Sometimes only some of the subsequent calls will be found.
Similarly, if the function depends on reference variables (i.e., the function
is not pure but depends on state holding variables), the result will likely
be completely incorrect.
However, if the function is pure, memoizing it will never change the
result.

It should be pointed out that one should not memoize any function.
Not only can it increase the memory foot print significantly, for
some functions it will slow down the program.
In particular, when the arguments can be very large, and thus the
hashing function take long time, and the computation relatively
small, memoization is a bad idea.


\subsection{Tuples}

If $e\_1, e\_2, \ldots , e\_n$ have types $t\_1, t\_2, \ldots , t\_n$, then
the fl expression $(e\_1, e\_2, \ldots , e\_n)$ have type
$t\_1$\verb@#@$t\_2$\verb@#@$\ldots$\verb@#@$t\_n$.
The standard functions on tuples are fst%
\index{fst}%
{} (first), snd%
\index{snd}%
{} (second), and the infix
operation , (pair%
\index{pair}%
{}).
%%%START_CODE%%%%
let q = ((1,2),3);
let qq = (1,2,3);
q;
qq;
let qqq = (1,"abc");
qqq;
%%%END_CODE%%%%

\subsection{Lists}

If $e\_1, e\_2, \ldots , e\_n$ have type $t$, then the fl expression
$[e\_1, e\_2, \ldots , e\_n]$ has type ($t$ list%
\index{list}%
{}).
The standard functions on lists are hd%
\index{hd}%
{} (head%
\index{head}%
{}), tl%
\index{tl}%
{} (tail%
\index{tail}%
{}), []%
\index{[]}%
{} (the empty list%
\index{empty list}%
{}), and the infix operation : (cons%
\index{cons}%
{}).
Note that all elements of a list must have the same type (compare
this with a tuple where the size is determined but each member of
the tuple can have different type).
%%%START_CODE%%%%
let l = [1,2,3,3,2,1,2];
hd l;
tl l;
0:l;
length l;
letrec odd_even (a:b:rem) =
    val (r_odd, r_even) = odd_even rem then
    (a:r_odd), (b:r_even)
 /\    odd_even [a] = [a],[]
 /\    odd_even [] = [], []
;
val (odd,even) = odd_even (1--20);
odd;
even;
%%%END_CODE%%%%

There are a large number of list functions built into fl.
For example:
%%%START_CODE%%%%
let l1 = 1 upto 8;
let l2 = 13 downto 1;
let l3 = 1--100;
l1 @ l2;
lastn 5 l1;
butlast l2;
firstn 7 l3;
butfirstn 96 l3;
cluster 4 (1--20);
let ll = [l1, l2, [4,8,12]];
flat ll;
%%%END_CODE%%%%
To find all such functions, use the help system and search for functions
whose argument type matches "*list*".

\subsection{Polymorphism}

The list processing functions hd, tl, etc. can be used on all types of lists.
%%%START_CODE%%%%
hd [1,2,3];
hd ["abc", "edf"];
(hd ["a", "b"]), hd [4,2,1];
let q = [T,T,F];
hd q;
%%%END_CODE%%%%
Thus hd has several types; for example, it is used above with types
(int list) \funarrow int,
(string list) \funarrow string, and (bool list) \funarrow bool.
In fact if ty is any type then hd has the type (ty list) \funarrow ty.
Functions, like hd, with many types are called polymorphic%
\index{polymorphic}%
{},
and fl uses type variables%
\index{type variables}%
{} *, **, ***, etc. to represent their types.
%%%START_CODE%%%%
let f x = hd x;

letrec map2 fn [] [] = []
 /\    map2 fn (a:as) (b:bs) = (fn a b) : (map2 fn as bs)
 /\    map2 fn _ _ = error "Lists of different length in map2"
;

letrec fact n = n=0 => 1 | n*fact (n-1);
let binom n k = (fact n) / ((fact k) * (fact (n-k)));
map2 binom [8,8,8,8,8,8,8,8,8] [0,1,2,3,4,5,6,7,8];
%%%END_CODE%%%%
The fl function map2%
\index{map}%
{} takes a function f (with argument types * and ** result
type ***), and two lists l1
(of elements of type *) and l2 (of elements of type **), and returns
the list obtained by applying
f to each pair of elements of l1 and l2.
Map2 can be used at any instance of its type: above, *, **, and
*** were instantiated to int;

below, * is instantiated to (int list) and ** to bool. Notice that the
instance need  not be  specified; it is determined by the type checker.
%%%START_CODE%%%%
let capitalize s = (chr ((ord (string_hd s))+(ord "A")-(ord "a")))^(string_tl s);
let classify name type = sprintf "%s is a %s" (capitalize name) type;
map2 classify ["john", "anna", "betsy", "bob"] ["boy","girl","girl","boy"];
%%%END_CODE%%%%

It should be pointed out that fl has a polymorphic type system that
is sightly different from
standard ML's. In particular, only ``top-level'' user-defined functions
can be polymorphic. In
other words, the following works as we would expect.
%%%START_CODE%%%%
let null l = l = [];
let f x y = null x OR null y;
f [1,2,3] ["abc", "cdef"];
%%%END_CODE%%%%
However, if we use the same declaration inside the expression, it must
be monomorphic%
\index{monomorphic}%
{}. In other
words, the following example fails.
%%%START_CODE%%%%
let f x y =
    let null l = l = [] in
    null x OR null y
;
f [1,2,3] ["abc", "cdef"];
%%%END_CODE%%%%
In this respect, fl is similar to the functional language called
Miranda\footnote{Miranda is a trademark of
Research Software Ltd.}~\cite{Miranda}.

\subsection{Type Annotations}
Sometimes it is useful to inform the type inference mechanism
of fl what type is expected.
This is particularly useful when there is an obscure type error in the
expression you are trying to define.
Annotating expressions with the type one expects them to have is often a
very efficient method for finding the problem.
This is particularly common when using overloaded functions.

In fl a variable or expression can be annotated%
\index{type annotation}%
{} with its expected
type by enclosing it in curly braces and decorate the expression
with a type expression.
For example, if we would like to define a function ihd that
return the head of a list, but that only can be used on integer lists,
we could define ihd as follows:
%%%START_CODE%%%%
let ihd {l::int list} = hd l;
%%%END_CODE%%%%

A more subtle example is the following.
Assume we have overloaded the operator + to either
operate over strings or integers.
We then want to extend this overloading
with yet another function over bools.
This can be done as:
%%%START_CODE%%%%
let iplus {a::int} {b::int} = a+b;
let splus {a::string} {b::string} = a^b;
overload + iplus splus;
let foo a b = a OR b;
overload + + foo;
infix 2 +;
1+2;
"a"+"bc";
T+F;
%%%END_CODE%%%%
If we now were to write a function that applies the + function to three
arguments, we could accomplish this by defining:
%%%START_CODE%%%%
let f x y z = x+y+z;
f 1 2 3;
f "a" "b" "s";
f F F T;
%%%END_CODE%%%%
However, note that the type inferred for f is more general than one might like.
After all, all the arguments to f as well as its return type, must have the
same type.
To capture this, a slightly better definition of f would be:
%%%START_CODE%%%%
let f {x:: *a} {y:: *a} {z:: *a} = {x+y+z:: *a};
%%%END_CODE%%%%
Here we also demonstrate how polymorphic types can be defined.
One warning: make sure there is a space between the :: and the *a so that
the parser does not try to look up the symbol ::*a!

\subsection{Lambda Expressions}

The expression \verb@\@x.e evaluates to a function with formal parameter x
and body e. Thus the
declaration let f x = e is equivalent to let f = \verb@\@x.e. The character
\verb@\@ is our representation of lambda,
and expressions like \verb@\@x.e are called lambda-expressions%
\index{lambda-expressions}%
{}.
%%%START_CODE%%%%
\x.x+1;
let q = \x.x+1;
q 1;
map (\x.x*x) [1,2,3,4,5];
%%%END_CODE%%%%

\subsection{Failures}

Some standard functions fail at run-time on certain arguments.
When this happen, an exception is raised.
If that exception is not captured (more below), the failure will propagate
to the top-level and an error message will be printed out and any
(possibly nested) loads will be aborted.
In addition to builtin functions failing, a failure%
\index{failure}%
{} with string "msg" may also be
generated explicitly by evaluating the expression error "msg" (or more
generally error%
\index{error}%
{} e where e has type string).
%%%START_CODE%%%%
hd(tl [2]);
1/0;
error "My message";
let select idx l =
    idx < 1 OR idx > length l =>
        eprintf "select called with illegal index (%d)" idx
    |
    el idx l
;
select 10 [1,2,3,4];
%%%END_CODE%%%%

A failure can be caught%
\index{catch a failure}%
{} by catch%
\index{catch}%
{}; the value of the expression $e\_1$ catch
$e\_2$ is that of $e\_1$, unless
$e\_1$ causes a failure, in which case it is the value of $e\_2$.
If one wants to examine the error message, one can use gen\_catch instead
of catch. However, the right-hand side expression to gen\_catch must
be a function taking the error message as argument.
For example:
%%%START_CODE%%%%
let half x = (x % 2) = 1 => eprintf "HALF_ERR: f2 is given an odd number (%d)" x
                        | x/2
;
letrec  robust_half x =
    (half x) gen_catch
    (\msg. str_is_prefix "HALF_ERR" msg => robust_half (x+1) | error msg)
;

robust_half 2;
robust_half 3;
robust_half (1/0);
%%%END_CODE%%%%
Here we catch only errors with "HALF\_ERR" in the error message.

One important
property of catch and gen\_catch is that they are
(very) strict in their first argument. In other words, (hd ($e\_1$ catch
$e\_2$)) will completely evaluate $e\_1$
even though only the first element in the list may be needed. In view
of fl's lazy semantics%
\index{lazy semantics}%
{}, the
use of catch should be very carefully considered.

\subsection{Type Abbreviations}
\index{type abbreviations}

Types can be given names:
%%%START_CODE%%%%
new_type_abbrev pair = int#int;
let p = (1,2);
%%%END_CODE%%%%
However, as can be seen from the example, the system does not
make any distinction between the new type name
and the actual type. It is purely a short hand that is useful when
defining concrete types below.

\subsection{Concrete Types}

New types (rather than mere abbreviations) can also be defined.
Concrete types%
\index{concrete type}%
{} are types
defined by a set of constructors%
\index{type constructor}%
{} which can be used to create objects
of that type and also (in
patterns) to decompose objects of that type. For example, to define
a type card one could use the
construct type:
%%%START_CODE%%%%
lettype card = king | queen | jack | other int;
%%%END_CODE%%%%
Such a declaration declares king, queen, jack and other as constructors
and gives them
values. The value of a 0-ary constructor such as king is the constant
value king. The value of a
constructor such as other is a function that given an integer value
n produces other(n).
%%%START_CODE%%%%
king;
other 9;
%%%END_CODE%%%%

Note that there is no print routine%
\index{print routine}%
{} for concrete types. If a print
routine is desired, one has to
define it.
To define functions that take their argument from a concrete type,
we introduce the idea of pattern matching%
\index{pattern matching}%
{}.
In particular
\begin{hol}
let f pat1 = e1
 /\verb@\@ f pat2 = e2
 /\verb@\@ ...
 /\verb@\@ f patn = en;
\end{hol}
denotes a function that given a value v selects the first pattern that
matches $v$, say pati, binds the variables of pati to
the corresponding components of the value $v$ and then evaluates the
expression ei.
We could for example define a print function for the cards in the following way:
%%%START_CODE%%%%
let pr_card king = "K"
  /\  pr_card queen = "Q"
  /\  pr_card jack = "J"
  /\  pr_card (other n) = int2str n;
pr_card king;
pr_card queen;
pr_card jack;
pr_card (other 5);
%%%END_CODE%%%%
If we now issue the top-level command
%%%START_CODE%%%%
install_print_function pr_card;
%%%END_CODE%%%%
\index{install\_print\_function}
every time we evaluate an expression of type card this routine would
be called and the string printed out on standard out.

Although pattern matching is often sufficient, sometimes one needs
to match on some predicate, rather than just the type constructor.
For this case, fl provides an {\tt assuming} keyword.
For example:
%%%START_CODE%%%%
letrec collatz 1 = [1]
 /\    collatz n assuming (n % 2 = 0) = n:(collatz (n/2))
 /\    collatz n assuming (n % 2 = 1) = n:(collatz (3*n+1))
;
collatz 7;
%%%END_CODE%%%%

Mutually recursive types%
\index{mutually recursive types}%
{} can also be defined. To do so, use the keyword andlettype for the
subsequent types.  For example:
%%%START_CODE%%%%
lettype    IExpr = Ivar string | Plus IExpr IExpr | ITE BExpr IExpr IExpr
andlettype BExpr = And BExpr BExpr | GEQ IExpr IExpr;
%%%END_CODE%%%%
defines two mutually recursive concrete data types for integer expressions
and Boolean expressions (very simple versions!).

Currently, fl does not provide any direct way of defining
mutually recursive functions%
\index{mutually recursive functions}%
{}.
The easiest work-around is to pass the later defined functions as
parameters to the earlier function.
After all functions have been defined, one can re-define the early ones.
To illustrate the approach, consider writing functions that converts
objects of type IExpr and BExpr to strings.
One possible solution is as follows:
%%%START_CODE%%%%
let prIExpr prBexpr expr =
    letrec prIExpr (Ivar s) = s
     /\    prIExpr (Plus a b) = (prIExpr a)^" + "^(prIExpr b)
     /\    prIExpr (ITE c t e) = "if "^(prBexpr c)^" then "^
                                 (prIExpr t)^" else "^(prIExpr e) in
    prIExpr expr
;
letrec prBExpr (And a b) = (prBExpr a) ^ " AND " ^ (prBExpr b)
   /\    prBExpr (GEQ a b) = (prIExpr prBExpr a)^" >= "^
                             (prIExpr prBExpr b)
;
let prIExpr e = prIExpr prBExpr e;
%%%END_CODE%%%%
Note that we simply pass prBExpr as an argument to the initial definition
of prIExpr.

A slightly easier approach is to use the forward\_declare mechanism.
With this, we get:
%%%START_CODE%%%%
forward_declare {prBexpr::BExpr->string};
letrec prIExpr (Ivar s) = s
 /\    prIExpr (Plus a b) = (prIExpr a)^" + "^(prIExpr b)
 /\    prIExpr (ITE c t e) = "if "^(prBexpr c)^" then "^
                             (prIExpr t)^" else "^(prIExpr e)
;
letrec prBExpr (And a b) = (prBExpr a) ^ " AND " ^ (prBExpr b)
 /\    prBExpr (GEQ a b) = (prIExpr a)^" >= "^ (prIExpr b)
;
%%%END_CODE%%%%
which is much easier to write, although it requires one to declare
the type of the forward function(s).

\subsection{Abstract Types}

In fl one can also hide the definitions of types, type constructors,
and functions.
By enclosing a sequence of type declarations and function definitions
within begin\_abstype%
\index{begin\_abstype}%
{}
end\_abstype%
\index{end\_abstype}%
{} elist, only the constructors and/or functions mentioned
in the elist will be visible and accessible for other functions
and definitions. Thus, one can protect a concrete type and only
make some abstract constructor functions available. To illustrate the
concept, consider defining a
concrete type called theorem. The only way we would like the user to
be able to create a new theorem is to give a Boolean expression that
denotes a tautology (something always true).
First we define the basic expression type.
%%%START_CODE%%%%

lettype expr =  E_FORALL string expr |
                E_VAR string |
                E_TRUE |
                E_AND expr expr |
                E_NOT expr
;

%%%END_CODE%%%%

For convenience we define a (simple) pretty printer and install it.

%%%START_CODE%%%%

let Pexpr expr =
    letrec do_print indent (E_FORALL s e) =
        (printf "(E_FORALL %s\n%*s" s (indent+2) "") fseq
        (do_print (indent+2) e) fseq
        (printf "%*s)\n" indent "")
     /\    do_print indent (E_VAR s) = printf "%s\n" s
     /\    do_print indent (E_TRUE) = printf "T\n"
     /\    do_print indent (E_AND e1 e2) =
        (printf "(E_AND\n%*s" (indent+2) "") fseq
        (do_print (indent+2) e1) fseq
        (printf "%*s" (indent+2) "") fseq
        (do_print (indent+2) e2) fseq
        (printf "%*s)\n" indent "")
     /\    do_print indent (E_NOT e) =
        (printf "(E_NOT\n%*s" (indent+2) "") fseq
        (do_print (indent+2) e) fseq
        (printf "%*s)\n" indent "")
    in
    (do_print 0 expr) fseq
    ""
;
install_print_function Pexpr;

let e = E_FORALL "a" (E_AND (E_VAR "a") (E_NOT (E_AND E_TRUE (E_VAR "a"))));

e;

%%%END_CODE%%%%

To make it more convenient to input expressions, one usually defines
operators and give them suitable fixities.
%%%START_CODE%%%%

let ~ e = E_NOT e;
prefix 0 ~;
let && a b = E_AND a b;
infix 4 &&;
let || a b = E_NOT (E_AND (E_NOT a) (E_NOT b));
infix 3 ||;
let forall fn s = E_FORALL s (fn (E_VAR s));
binder forall;
let thereis fn s = E_NOT (E_FORALL s (E_NOT (fn (E_VAR s))));
binder thereis;
let ^^ a b = ~a && ~b || a && b;
infix 4 ^^;

// Example
let e = forall a b. thereis c. ~(a^^b) || ~(a^^(c^^b));

%%%END_CODE%%%%

We then define the concrete type theorem and the constructor function
is\_taut. Note that we
also define a couple of help functions. However, only the is\_taut function
is exported out of the
abstract type%
\index{abstract type}%
{}, and thus is the only way of creating a theorem.
%%%START_CODE%%%%

begin_abstype;

let empty_state = [];
let add_to_state state var value = (var,value):state;
let lookup var state =
    (assoc var state) catch
    eprintf "Cannot find variable %s (not bound?)" var
;

let expr2bool e =
    letrec eval (E_FORALL s e) state =
            let state0 = add_to_state state s T in
            let state1 = add_to_state state s F in
            (eval e state0) AND (eval e state1)
     /\    eval (E_VAR s) state = lookup s state
     /\    eval (E_TRUE) state = T
     /\    eval (E_AND e1 e2) state = (eval e1 state) AND (eval e2 state)
     /\    eval (E_NOT e) state = NOT (eval e state)
    in
    eval e empty_state
;

lettype theorem = THM expr;
let Ptheorem t =
    let PP (THM e) = fprintf stdout "Expression is a theorem\n" in
    (PP t) fseq ""
;
install_print_function Ptheorem;

let is_taut e =
    (expr2bool e == T) => THM e | error "Expression is not a theorem"
;
end_abstype is_taut;

%%%END_CODE%%%%

We can now use this very safe theorem system, since we can only generate
theorems that are tautologies.
For example
%%%START_CODE%%%%

let e = forall a b. thereis c. ~(a^^b) || ~(a^^(c^^b));
is_taut e;
let f = thereis c. forall a b. ~(a^^b) || ~(a^^(c^^b));
is_taut f;
let g = forall a b c. ~(a^^b) || ~(a^^(c^^b));
is_taut g;

%%%END_CODE%%%%

\subsection{Fixity Operators}

In order to make the fl code more readable, there is extensive
support for changing the fixity of operators or functions.


if\_then\_else\_binder
postfix
nonfix
prefix 0
prefix 1
binder
infix 0-9
infixr 0-9
infix\_unary

change the parsing of variables or


declare
a function to be infix%
\index{infix}%
{} (associating from the left), infixr%
\index{infixr}%
{}
(associating from the right), nonfix%
\index{nonfix}%
{} (no fixity at all), prefix
\index{prefix}%
{} (prefix operator with tighter binding than ``normal'' function definitions),
postfix%
\index{postfix}%
{}, or
of a binder%
\index{binder}%
{} type.
For the infix and infixr directives, the precedence can be given as
a number from 1 to 9, where a higher number binds tighter.
Similarly, prefix also takes a precedence number, but only 0 or 1.
Note that prefix and postfix functions bind higher than any infix function.
Beware that the fixity declaration modifies the parser and
thus remains in effect whether
the function is exported out of an abstract data type or note.
As an illustration of this idea, consider the following example:
%%%START_CODE%%%%

lettype expr = Val int |
               Mult expr expr |
               Plus expr expr |
               Negate expr;
letrec eval (Val i) = i
  /\   eval (Mult e1 e2) = (eval e1) * (eval e2)
  /\   eval (Plus e1 e2) = (eval e1) + (eval e2)
  /\   eval (Negate e1) = 0-(eval e1)
;
let ** a b = Mult a b;
let ++ a b = Plus a b;
infix 4 **;
infix 3 ++;
let ' i = Val i;
prefix 0 ';
let q = '1 ++ Negate '2 ** Negate '4;
eval q;

%%%END_CODE%%%%

The next example illustrates how postfix declarations can make the
code more readable.
%%%START_CODE%%%%

let ns i = 1000*i;
postfix ns;
let to a b = (a,b);
infix 3 to;
2 ns to 4 ns;

%%%END_CODE%%%%

Our final example deals with more advanced binder declarations.
The command binder takes a function and makes it into a binder, i.e., an
object that introduces a new bound variable in an expression.
Note that the type of the function declared to be a binder must be
(*\funarrow **)\funarrow string\funarrow **, since the first argument of
a binder function will be a lambda expression and the second argument will
be a string with the name of the bound variable.
Thus, if a function f has been declared as a binder, then
f x.E will be parsed as f (\protect\verb!\! x.E) "x".

%%%START_CODE%%%%

// Syntactic sugaring
let forall fn s = E_FORALL s (fn (E_VAR s));
binder forall;
let ' v = E_VAR v;
free_binder ';
let && = E_AND;
infix 4 &&;
let || a b = E_NOT (E_AND (E_NOT a) (E_NOT b));
infix 3 ||;

'a && 'b;

forall a b c. a || b && c;

%%%END_CODE%%%%

% \subsection{Overloading}
%
% fl supports a limited amount of user defined overloading%
% \index{overloading}%
% {} of functions
% and operators.
% However, in order to avoid an exponential type inference algorithm, the
% overloaded operators must be resolved from the types of their arguments only.
% To illustrate the construct, consider the following example:
% %%% START_CODE%%%%
% let pplus ({a::int},{b::int}) (c,d) = (a+c, b+d);
% let pprod ({a::int},{b::int}) (c,d) = (a*c, b*d);
% overload + + pplus;
% overload * * pprod;
% (1,2)+(3,4)*(9,3*2);
% %%% END_CODE%%%%
% Here we overloaded the symbols + and *.
% Note that we essentially added new meanings to + and * since we included
% the (built-in) versions as possible candidates.
%
% Finally, overloaded operators and functions can of course also
% be declared infix, binders, or postfix as any other function or operator.

\subsection{Vossrc Variables}
\label{section:vossrc}

The {\voss} system uses some user controllable settings for various
behaviors.
All of these can be seen by clicking on "Preference" under the "File"
menu in the main fl window.
In addition, on startup, {\voss} will look for a .vossrc file in
the current directory or your home directory to set these preferences.
For a temporary change of one of these settings, use of the GUI under
Preferences is definitely recommended.
However, if you want a certain setting for a particular fl program/session,
there are two builtin functions that can be used:
\verb@get_vossrc@ and \verb@update_vossrc@.
The first takes a name of a vossrc variable (to get the names of them, see the
Preference window and click on the ``copy to clipboard'' icon beside the
name) and returns its current value.
The second changes it to a new value (and returns the old).
For example:
%%%START_CODE%%%%
// Read the old value
get_vossrc "DYNAMIC-ORDERING";
// Update the value
update_vossrc "DYNAMIC-ORDERING" "NO";
// Read the new value
get_vossrc "DYNAMIC-ORDERING";
%%%END_CODE%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Reference variables}

Although fl is mostly a pure functional language, it has some
non-functional parts that can be very useful.
One particular non-functional part is reference variables%
\index{reference variable}%
{}.
A reference variable is like a memory location to which one
can write new values and programs can get the current value.
A reference variable is created by the (psuedo-) function call ref.
Ref takes a value and returns a reference to a storage location
for such values and that initially contain this value.
One important restriction to reference variables is that the value must
be monomorphic.
Thus, \verb@ref []@ is rarely usable, but,
e.g., \verb@ref {[]::(int#bool) list}@ is needed.
To access the current value of a reference variable, the function \verb@deref@
is used.
Finally, to update the value stored in the reference variable, the infix
function \verb@:-@ is used.
An example of using a reference variable to count the number of times
a function is called could look like:
%%%START_CODE%%%%
let cnt_r = ref 1;

letrec fib 1 = 1
 /\    fib 2 = 1
 /\    fib n =
	(cnt_r := (deref cnt_r + 1)) fseq
	fib (n-1) + fib (n-2)
;

cnt_r := 0;
fib 20;
deref cnt_r;

cletrec mfib 1 = 1
  /\    mfib 2 = 1
  /\    mfib n =
	(cnt_r := (deref cnt_r + 1)) fseq
	mfib (n-1) + mfib (n-2)
;

cnt_r := 0;
mfib 20;
deref cnt_r;
%%%END_CODE%%%%

\subsection{Tables}

To enable fast lookup, there is a tbl type in fl.
However, it has some restrictions.
Although it appears to be functional, e.g., inserting a new (key,data) pair
yields a new table, this is an illusion.
Internally, the table is implemented as a stateful hash table and thus
one always see the latest version.
%%%START_CODE%%%%
let t0 = tbl_create 10;
t0;
let t1 = tbl_insert t0 1 11;
t1;
let t2 = tbl_insert t1 2 11;
t2;
tbl_get t2 1;
tbl_get t2 2;
// Note!!!
tbl_get t1 2;
%%%END_CODE%%%%
\begin{hol}
tbl_create	    -- Make a table
tbl_insert	    -- Make a "new" table by inserting a key and data
tbl_delete	    -- Make a "new" table by deleting the data linked to key
tbl_member    	    -- Is a given key in the table
tbl_get	    	    -- Return the data linked to key
tbl_clear	    -- Empty the table
list2tbl	    -- Build a table from a (key,data) list
tbl2list	    -- Return the (key,data) pairs stored in the table
\end{hol}


\subsection{Laziness}

As stated earlier, fl is a lazy language.
This is mostly true, but there are some subtle exceptions.
In general, laziness means two aspects:
1) an expression is never evaluated until it is needed and
2) an expression is only evaluated once.
Once you introduce side effects in the language this causes problems.
In particular, the second aspect may no longer be what you want.
In addition, as a consequence of property 1, the order in which
expressions get evaluated is difficult to predict.

To mitigate the problem of evaluation order, fl provides two mechanisms.
First, the (infix) functions
seq%
\index{seq}%
{} and
fseq%
\index{fseq}%
{} can be used to force a particular evaluation order.

Since a very common situation is that we define some expression and would
like it to be evaluated before we do some more work, we could write this as:
\begin{hol}
    ...
    let e = <big-expression-with-side-effects> in
    e fseq
    ...
\end{hol}
However, this is so tedious that fl has introduced a short-hand for this:
then%
\index{then}%
{} and thus you can simply write:
\begin{hol}
    ...
    let e = <big-expression-with-side-effects> then
    ...
\end{hol}
to achieve the same effect.

The problem with functions being evaluated once causes problems
with side effecting functions.
Consider for example:
%%%START_CODE%%%%
let pr name = fprintf stderr "We have now reached: %s\n" name;

letrec fac n =
    ((n % 2 = 0) => pr "Even" | pr "Odd") fseq
    n = 0 => 1 | n* fac (n-1)
;

fac 7;
fac 11;
%%%END_CODE%%%%
Not only do we only get two printouts for the fac 7 evaluation, we get
no output the second time we call fac!
The problem here is that the expressions (pr "Even") and (pr "Odd")
does not depend on n and thus will only be evaluated once.
What is needed is somehow introduce a dependency on n in these expressions.
One approach would be:
%%%START_CODE%%%%
let pr name = fprintf stderr "We have now reached: %s\n" name;

letrec fac n =
    ((n % 2 = 0) => pr (n seq "Even") | pr (n seq "Odd")) fseq
    n = 0 => 1 | n* fac (n-1)
;

fac 7;
fac 11;
%%%END_CODE%%%%
in which we introduced a (dummy) dependency on n.

Since situation is quite common when one use side-effecting functions,
fl has introduced an automatic mechanism for it.
By declaring the function pr as
non\_lazy%
\index{non\_lazy}%
{} the compiler will insert such a dummy dependency,
Thus, the above example is best written as:
%%%START_CODE%%%%
let pr name = fprintf stderr "We have now reached: %s\n" name;
non_lazy pr;

letrec fac n =
    ((n % 2 = 0) => pr "Even" | pr "Odd") fseq
    n = 0 => 1 | n* fac (n-1)
;

fac 7;
fac 11;
%%%END_CODE%%%%

\subsection{tcl interface}

The fl interpreter consists of two processes.
One for the main fl interpreter and one wish process for the graphical
interface.
As a result, there is bidirectional a link between the tcl/tk process
and the fl process and thus fl can call tcl procedures and tcl
procedures can call fl functions.
To call tcl from fl, there is a command called
tcl\_eval%
\index{tcl\_eval}%
{} that takes a list of strings and send them over to the running
tcl interpreter.
For example:
%%%START_CODE%%%%
let go_on topic =
    let query = sprintf "Do you want to continue with %s?" topic in
    tcl_eval [
	"toplevel .foo",
	sprintf "label .foo.question -text {%s}" query,
	"frame .foo.answer",
	"button .foo.answer.yes -text Yes -command {set res 1}",
	"button .foo.answer.no  -text No  -command {set res 0}",
	"pack .foo.question -side top -fill x",
	"pack .foo.answer -side top -fill x",
	"pack .foo.answer.yes -side left -expand y -fill x",
	"pack .foo.answer.no  -side left -expand y -fill x",
	"update",
	"i_am_free",
	"tkwait variable res",
	"destroy .foo",
	"set res"
    ] = "1"
;
%%%END_CODE%%%%
If one now invokes \verb@go_on "computation";@ one would see:
\begin{center}
% \includegraphics[width=0.4\linewidth]{screen_shots/go_on.png}
\includegraphics{screen_shots/go_on.png}
\end{center}
and the system would wait for the user to press either.
Depending on whether the user pressed Yes or No, the expression would return
true or false.

Of course, in practice the tcl program is usually kept in a separate
file and the tcl\_eval command simply contains a tcl command to source that
file.

One thing to note is that the main {\voss} window is in a looked (busy-wait)
state during evaluations of a tcl\_eval.
To ``unlock'' it, the tcl command ``i\_am\_free%
\index{i\_am\_free}%
'' is needed before waiting for the variable to change.

To have tcl call fl is even easier.
If you declare an fl function of suitable type (more on that later) and
add the directive \verb@export_to_tcl@%
\index{export\_to\_tcl}%
{} directly after, a tcl procedure will exist with that name and
that will call the fl function when invoked.
For example:
%%%START_CODE%%%%
letrec fl_fac n = (n = 1) => 1 | n*fl_fac (n-1);
export_to_tcl fl_fac;

let fac_calc title =
    tcl_eval [
	"toplevel .foo",
	sprintf "label .foo.title -text {%s}" title,
	"frame .foo.c",
	"entry .foo.c.inp",
	"button .foo.c.do -text Compute -command { docomp }",
	"entry .foo.c.out",
	"pack .foo.title .foo.c -side top -fill x",
	"pack .foo.c.inp .foo.c.do .foo.c.out -side left",
	(
	    "proc docomp {} {"^
	    "   set i [.foo.c.inp get];"^
	    "   set o [fl_fac $i];"^
	    "   .foo.c.out delete 0 end;"^
	    "   .foo.c.out insert 0 $o;"^
	    "}"
	)
    ]
;

%%%END_CODE%%%%
If one now evaluates \verb@fac_calc "Factorial computation";@, one
would see:
\begin{center}
% \includegraphics[width=0.6\linewidth]{screen_shots/fac_calc.png}
\includegraphics{screen_shots/fac_calc.png}
\end{center}

Note that the tcl procedure (proc docomp) has to be given as a single string
in tcl\_eval. Again, putting this code in a separate tcl file is far easier.

Finally, although not a requirement, the convention is to name
fl functions that will be used as callback functions in tcl with a prefix
\verb@fl_@.

