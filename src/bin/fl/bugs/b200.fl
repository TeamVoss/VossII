// isomatching + search and replace.

load "ste.fl";

// Pexlif to pexlif "transformation" via verilog.
//
// Pexlif -{pretty}-> Verilog -{write}-> File -{yosys+carl}-> Pexlif
let pex2pex p =
      val (PINST top _ _ _ _ _ _) = p in
      let file = "test.v" in
      let v  = pexlif2verilog p then
      let fp = fopen file "w" then
      fprintf fp "%s\n" v fseq
      fclose fp fseq
      verilog2pexlif "-I." top [file] []
;


// Creates a miter circuit for two pexlifs.
//
//                          Ckt p1
//                        +------+                     
//      i_1 ---------*----|   o_1|---------------+----+      +----+        
//                   |    |      |               | == |------|    |           
//                   |    |      |    +----------+----+      |    |    
//      i_2 -------*-|----|   o_2|----|----------+----+      |    |
//                 | |    |      |    |          | == |------| A  |
//      ...        | |    |      |    |  +-------+----+      | N  |----- eq
//                 | |    |      |... |  |       ...         | D  |      
//      i_m --*----|-|----|   o_n|----|--|-------+----+      |    |
//            |    | |    |      |    |  |       | == |------|    | 
//            |    | |    |      |    |  |   +---+----+      +----+
//            |    | |    +------+    |  |   |                
//            |    | |     Ckt p2     |  |   |                
//            |    | |    +------+    |  |   |
//            |    | +----|  o_1 |----*  |   |
//            |    +------|  o_2 |-------*   |
//            |           |      | ...       |
//            +-----------|  o_n |-----------+
//                        +------+       
let mk_miter p1 p2 =
      val (PINST n1 a1 l1 fa_inps1 fa_outs1 ints1 chs1) = p1 in
      val (PINST n2 a2 l2 fa_inps2 fa_outs2 ints2 chs2) = p2 in
      // -------------------------------------------
      // Check for same inputs/outputs.
      let inps1 = setify (md_expand_vectors (flatmap snd fa_inps1)) in
      let inps2 = setify (md_expand_vectors (flatmap snd fa_inps2)) in
      let d = inps1 subtract inps2 in
      d != [] => eprintf "Input mismatch: %S in pexlif 1 but not in pexlif 2" d |
      let d = inps2 subtract inps1 in
      d != [] => eprintf "Input mismatch: %S in pexlif 2 but not in pexlif 1" d |
      let outs1 = setify (md_expand_vectors (flatmap snd fa_outs1)) in
      let outs2 = setify (md_expand_vectors (flatmap snd fa_outs2)) in
      let d = outs1 subtract outs2 in
      d != [] => eprintf "Output mismatch: %S in pexlif 1 but not in pexlif 2" d |
      let d = outs2 subtract outs1 in
      d != [] => eprintf "Output mismatch: %S in pexlif 2 but not in pexlif 1" d |
      // -------------------------------------------
      // Same inputs and outputs, now rename the outputs.
      let p1' =
        let fa_outs1' = map (\(f,as). f,(map (sprintf "P1_%s") as)) fa_outs1 in
        PINST n1 a1 l1 fa_inps1 fa_outs1' ints1 chs1
      in
      let p2' =
        let fa_outs2' = map (\(f,as). f,(map (sprintf "P2_%s") as)) fa_outs2 in
        PINST n2 a2 l2 fa_inps2 fa_outs2' ints2 chs2
      in
      val (eq_nd, eqs) =
        let vname = sprintf "_eq[%d:0]" (i_minus (length outs1) 1) then
        let nds = md_expand_vector vname then
        (vname, (map (\n. BV_bit (W_VAR 1 n)) nds))
      in
      let mk_eq out_i eq_i = 
        let o1 = BV_bit (W_VAR 1 ("P1_"^out_i)) in
        let o2 = BV_bit (W_VAR 1 ("P2_"^out_i)) in
        eq_i <- o1 '=' o2
      in
      let AND_bits {l::bit list} =
        l = [] => eprintf "AND_bits for empty list" |
        accumulate (defix '&') l
      in
      let eq_pexlifs = map2 mk_eq outs1 eqs in
      let ok_bit = BV_bit (W_VAR 1 "_OK_") in
      let and_pexlif = ok_bit <- AND_bits eqs then
      let pfn = "draw_hier miter" in
      let fa_inps = map (\n. n,[n]) (md_extract_vectors inps1) in
      let fa_outs = [("_OK_", ["_OK_"])] in
      let o1s = map (\n. "P1_"^n) outs1 in
      let o2s = map (\n. "P2_"^n) outs2 in
      let ints = eq_nd:(md_extract_vectors (o1s @ o2s)) in
      let children = p1' : p2' : and_pexlif : eq_pexlifs in
      let mpexlif = PINST pfn [] F fa_inps fa_outs ints (P_HIER children) in
      let mant = map (\n. (T,n,variable n,0,1)) inps1 in
      let mcons = [(T,"_OK_",T,0,1)] in
      (mpexlif, mant, mcons)
;

let miter_test p g =
      val (miter, ant, cons) = mk_miter p g then
      let vis = pexlif2fsm miter then
      let ste = STE "-e -m 10" vis [] ant cons [] then
      get_ste_result ste "";
;

// =============================================================================
// Randomized example.

let gen_vec_size max_sz =
        let gen_range sz = sprintf "[%d:0]" (sz-1) in
        one_of_weighted [
            (4, "")
          , (1, one_of_weighted [
                (1, gen_range (min max_sz 4))
              , (1, gen_range (min max_sz 8))
              , (1, gen_range (min max_sz 16))
              , (1, gen_range (min max_sz 32))
              , (1, gen_range (min max_sz 64))
              , (1, gen_range (random 2 max_sz))
              ])
          ]
;
non_lazy gen_vec_size;

let gen_fas max_f max_sz pre_f pre_as =
        // Gen. the vec. size of each formal.
        let szs    = map gen_vec_size (replicate (random 1 max_f) max_sz) in
        let pr v i = v ^ int2str i in
        let lbl p  = map (curry pr) (ixlabel (replicate (length szs) p)) in
        // Gen. the formals and actuals (1-to-1 always, since we're testing leafs).
        let fs  = map2 (defix ^) (lbl pre_f) szs in
        let ass = map2 (\p. \sz. [p ^ sz]) (lbl pre_as) szs in
        // /
        zip fs ass
;
non_lazy gen_fas;

let gen_pex seed max_f max_sz max_d =
        max_f <= 1 => error "gen_pex: max_f < 2" |
        // Just to be sure FL is gen. different pexlifs each time, use a seed.
        (srandom seed) fseq
        // Gen. of the formal/actuals used as either inputs or outputs.
        val (max_is, max_os) = let x = random 1 (max_f - 1) in (x, max_f - x) in
        let fa_is = gen_fas max_is max_sz "in" "in" in
        let fa_os = gen_fas max_os max_sz "out" "out" in
        // Gen. a random pexlif.
        let sz = random 1 max_sz in
        let d  = random 1 max_d in
        gen_pinst_leaf "test" fa_is fa_os F sz d
;
non_lazy gen_pex;
// note: requires that max_f > 1

let gen s = pexlif2verilog (normalize_pexlif (gen_pex s 4 2 2));
non_lazy gen;

letrec
    no_attrs (PINST n _ l i o t (P_HIER cs)) =
        PINST n [] l i o t (P_HIER (map no_attrs cs))
/\  no_attrs (PINST n _ l i o t (P_LEAF fs)) =
        PINST n [] l i o t (P_LEAF fs)
;

let gen_test s =
        (printf "=== Generating example %d\n" s) fseq
        let pex = normalize_pexlif (gen_pex s 4 2 2) then
        (pretty_pexlif pex)  fseq
        // /
        (printf "=== Generating verilog for example %d:\n" s) fseq
        (print (pexlif2verilog pex)) fseq
        (printf "\n=== Reading verilog for example %d back to pexlif:\n" s) fseq
        let pex' = pex2pex pex then
        (pretty_pexlif (no_attrs pex')) fseq
        // /
        miter_test pex pex' => print "OK\n" | print "ERROR\n"
;
non_lazy gen_test;

// =============================================================================
// Small example.

let ex1 =
        bit_input a.
        bit_output b.
        CELL "draw_hier ex1" [
            b <- '~' a
        ]
;

let target =
        bit_input i1.
        bit_input i2.
        bit_output o1.
        bit_output o2.
        CELL "draw_hier target" [
            ex1 i1 o1,
            o2 <- '~' i2
        ]
;

let ex1' = ex1 'x 'y;
let target' = target 'i1 'i2 'o1 'o2;
//isomatch_and_store ex1' target';
//find_isomatches target';

// =============================================================================
// Four examples, all put into a larger haystack.

let buf1 =
    bit_input a.
    bit_output out.
    bit_internal mid.
    CELL "draw_hier buf1" [
      mid <- '~' a,
      out <- '~' mid
    ];

let buf2 =
    bit_input x.
    bit_output y.
    bit_internal mid.
    CELL "draw_hier buf2" [
      mid <- '~' x,
      y <- '~' mid
];

let buf3 =
    bit_input a.
    bit_output out.
    bit_internal oink.
    CELL "draw_hier buf3" [
      oink <- '~' a,
      out <- '~' oink
    ];

letrec inv_rec n =
    bit_input    a.
    bit_output  out.
    bit_internal mid.
    CELL "draw_hier inv_rec" (
      n = 1 => [ out <- '~' a ] |
      [
          mid <- '~' a,
          inv_rec (n-1) mid out
      ]);
let buf4 =
    bit_input    a.
    bit_output  out.
    CELL "buf4" [
        inv_rec 2 a out
    ];

let bufs =
    bit_input a b c d e f.
    bit_output o1 o2 o3 o4 o5 o6 o7.
    bit_internal mid.
    CELL "draw_hier bufs" [
      buf1 a o1,
      buf2 b o2,
      buf3 c o3,
      inv_rec 2 d o4,
      buf4 e o5,
      mid <- '~' f,
      o6 <- '~' mid,
      o7 <- '~' mid
    ];

let buf1' = buf1 'i1 'o1;
let buf2' = buf2 'i1 'o1;
let buf3' = buf3 'i1 'o1;
let buf4' = buf4 'i1 'o1;
let bufs' = bufs 'i1 'i2 'i3 'i4 'i5 'i6 'o1 'o2 'o3 'o4 'o5 'o6 'o7;
//let matches = isomatch buf1' bufs';

// =============================================================================
// ...

let mux4' = verilog2pexlif "-Iisomatch/tests/mux" "mux4" ["mux4.v"] [];
let mux2' = verilog2pexlif "-Iisomatch/tests/mux" "mux2" ["mux2.v"] [];

//let wrap p = PINST "box" [] F [] [] [] (P_HIER [p]) in
//isomatch_and_store mux2' mux4';
//find_isomatches mux4';

// =============================================================================
// ...

let BYTE_SIZE           = 8;
let ADDR_SIZE           = 20;
let TIMER_SIZE          = 16;
let LINES               = 12;            // Number of cache lines
let BYTES_IN_CACHE_LINE = 8;            // Number of bytes in cache line
let TAG_SIZE		= ADDR_SIZE-(log2 LINES)-(log2 BYTES_IN_CACHE_LINE);

TYPE "byte" BYTE_SIZE;
TYPE "cache_line" (BYTE_SIZE*BYTES_IN_CACHE_LINE);;
TYPE "atag_field" TAG_SIZE;
TYPE "line_addr" (log2 LINES);
TYPE "decoded_line_addr" LINES;
TYPE "byte_addr" (log2 BYTES_IN_CACHE_LINE);

STRUCT "addr" [ ("aTag", "atag_field"),
		("line", "line_addr"),
		("byte", "byte_addr")
];

STRUCT "ext_cache_line" [
	    ("valid", "bit"),
	    ("aTag", "atag_field"),
	    ("data", "cache_line")
];

let cache_line =
    bit_input		    clk.
    bit_input		    reset.
    bit_input		    we.
    line_addr_input	    line.
    cache_line_input	    din.
    atag_field_input	    atag.
    bit_output		    match.
    cache_line_output	    dout.
    bit_input               sel.
    cache_line_input	    r_dout.
    bit_input               r_match.
    //
    bit_internal	    my_we l_match.
    ext_cache_line_internal n_cl cl.
    //
    CELL ("cache_line") [
	my_we <- sel '&' we,
	n_cl-->valid <- (IF reset THEN '0 ELSE (my_we '|' cl-->valid)),
	n_cl-->aTag  <- (IF my_we THEN atag ELSE cl-->aTag),
	n_cl-->data  <- (IF my_we THEN din ELSE cl-->data),
	re_ff clk n_cl cl,
	l_match <- sel '&' cl-->valid '&' (atag '=' cl-->aTag),
	match <- (IF sel THEN l_match ELSE r_match),
	dout <- (IF sel THEN cl-->data ELSE r_dout)
    ]
;

letrec cache_rec n =
    bit_input		    clk.
    bit_input		    reset.
    bit_input		    we.
    line_addr_input	    line.
    cache_line_input	    din.
    atag_field_input	    atag.
    bit_output		    match.
    cache_line_output	    dout.
    //
    bit_internal	    my_we sel r_match l_match.
    ext_cache_line_internal n_cl cl.
    cache_line_internal	    r_dout.
    //
    CELL (sprintf "cache_rec %d" n) (
    n < 0 => [
	    dout  <- 'X,
	    match <- '0
    ] | [
	sel <- line '=' ''n,
	cache_rec (n-1) clk reset we line din atag r_match r_dout,
        cache_line clk reset we line din atag match dout sel r_dout r_match
]);

let cache_mem =
    bit_input			clk.
    bit_input			reset.
    bit_input			we.
    line_addr_input		line.
    cache_line_input		din.
    atag_field_input		atag.
    bit_output			hit.
    cache_line_output		dout.
    //
    CELL "draw_hier CacheMem" [
	cache_rec (LINES-1) clk reset we line din atag hit dout
];

let cache_line' = cache_line 'clk 'reset 'we 'line 'din 'atag 'match 'dout 'sel 'r_dout 'r_match;
let cache_mem' = cache_mem 'clk 'reset 'we 'line 'din 'atag 'hit 'dout;
let flat_cache_line' = flatten_pexlif cache_line';
let flat_cache_mem' = flatten_pexlif cache_mem';
//isomatch_and_store cache_line' cache_mem';
//find_isomatches cache_mem';

// =============================================================================
// Fin.