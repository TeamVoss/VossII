let do_debug = (length ARGS > 1) AND (hd ARGS == "DO_DEBUG");

let yfl_file = (last ARGS);
(str_is_suffix ".yfl" yfl_file) => () | error "Usage: yaccfl [--debug] file.yfl"
;

let base_name = gen_trim "" ".yfl" yfl_file;

let prefix_name = gen_trim "" ".yfl" (last (str_split yfl_file "/"));

let sl2s sl = list2str T "" "" "" id sl;

let PREF s =
    let pat_yy = "^(.*)yy(.*)$" in
    let pat_YY = "^(.*)YY(.*)$" in
    letrec tr pat old =
	NOT (str_reg_match pat old) => old |
	val [_, pre,post] = str_reg_extract pat old in
	let new = sprintf "%s%s%s" pre prefix_name post then
	tr pat new
    in
    let s'  = tr pat_yy s then
    let s'' = tr pat_YY s' then
    s''
;

let err line msg =
    eprintf "Syntax error around line %d in file %s\n%s\n" line yfl_file msg
;

let read_file file = 
    letrec rd fp = 
	let s = fgets fp then
	s = "" => [] |
	(string_butlastn s 1):(rd fp)
    in
    let fp = fopen file "r" then
    let lines = rd fp then
    (fclose fp) fseq
    lines
;

let extract_fl_code start_line lines =
    let act_dir = 
	let dirs = butlast (str_split (file_fullname yfl_file) "/") in
	list2str T "" "/" "/" id dirs
    in
    let pat = "^(.*[^A-Za-z_])DIR([^A-Za-z0-9_].*)$" in
    letrec do_replace old =
	NOT (str_reg_match pat old) => old |
	val [_,pre,post] = str_reg_extract pat old then
	let new = sprintf "%s\"%s\"%s" pre act_dir post then
	do_replace new
    in
    map do_replace lines
;


let tokensr = ref [""];
let add_token token = (tokensr := (token:(deref tokensr)));
non_lazy add_token;

let extract_scanner start_line lines =
    let ridx = find_first0 (str_reg_match "^%%") lines in
    ridx = 0 => 
	eprintf "Missing %%%% in SCANNER section in %s" yfl_file 
    |
    let base = firstn ridx lines in
    let rules = butfirstn ridx lines in
    (tokensr := []) fseq
    let process s =
	let pat3 = "^([^ \t]*)[ \t]+([^ \t]+)[ \t]+([^ \t]+)$" in
	let pat2 = "^([^ \t]*)[ \t]+([^ \t]+)$" in
	str_reg_match pat3 s =>
	    val [_,pat,token,init] = str_reg_extract pat3 s in
	    (add_token token) fseq
	    pat, (sprintf "{ BEGIN %s; RET(%s); }" init token)
	|
	str_reg_match pat2 s =>
	    val [_,pat,token] = str_reg_extract pat2 s in
	    (add_token token) fseq
	    pat, (sprintf "{ RET(%s); }" token)
	|
	(s,"{}")
    in
    let prelude tokens =
	[
	    "%{",
	    "#include <stdlib.h>",
	    "#include \"fl.h\"",
	    "#include \"graph.h\"",
	    sprintf "#include \"%s.tab.h\"" prefix_name,
	    "",
	    sprintf "#define YY_DECL                 int %slex (YYSTYPE *lvalp)"
		prefix_name,
	    "",
	    "char *copy_str(char *txt) { char *res = malloc(strlen(txt+1)); strcpy(res, txt); return res; }",

	    "struct token_rec {int tk; char name[50];} token_tbl [] = {"
	]@(map (\tk. sprintf "    {%s, \"%s\"}," tk tk) tokens)@
	[
	    "    {-1, \"_DUMMY_\"}\n};",
	    "char ebuf[100];",
	    "",
	    "char *tk2name(int tk) {",
	    "    struct token_rec dummy;",
	    "    for(int i = 0; i < sizeof(token_tbl)/sizeof(dummy); i++) {",
	    "        if( token_tbl[i].tk == tk ) return( token_tbl[i].name );",
	    "    }",
	    "    sprintf(ebuf, \"%d\", tk);",
	    "    return ebuf;",
	    "}",
	    "",
	    (do_debug =>
		sprintf "#define RET(tk) fprintf(stderr, \"Lex: |%%s| -> %%s in state %%d\\n\",yytext, tk2name(tk), YY_START); lvalp->str_t = copy_str(yytext); return(tk);"
	    |
		"#define RET(tk) lvalp->str_t = copy_str(yytext); return(tk);"
	    ),
	    (sprintf "int %sline_nbr = 1;" prefix_name),
	    "%}",
	    "",
	    "%%",
	    (sprintf "\\n { %sline_nbr++; }" prefix_name),
	    ""
	]
    in
    let postlude =
	[
	    "%%",
	    "",
	    "int",
	    PREF "yywrap()",
	    "{",
	    "    return(1);",
	    "}"
	] in
    let raw_out = map process rules then
    let max_len = itlist (\(p,c).\r. max r (strlen p)) raw_out 1 then
    let out = map (\(p,r). sprintf "%-*s  %s" max_len p r) raw_out then
    let all_tokens = rev (setify (deref tokensr)) then
    let res = (prelude all_tokens) @ out @ postlude then
    (all_tokens, res)
;


let rget pat s =
    str_reg_match pat s => tl (str_reg_extract pat s) |
    eprintf "No match for pattern:\n|%s|\nin string |%s|\n" pat s
;

let mk_bison_rule tokens fun_name used ids =
    let pre = list2str T "" " " "" id ids in
    let body =
	letrec build_call idx =
	    idx = 0 =>
		(sprintf "\n\t    $$ = Make_VAR_leaf(wastrsave(stringsp, \"%s\"));" fun_name)^
		(mem (-1) used
		    => "\n\t    "^
		       sprintf "$$=Make_APPL_ND($$,Make_INT_leaf(%sline_nbr));"
			prefix_name
		     | ""
		)
	    |
	    (build_call (idx-1))^
	    (NOT (mem idx used) => "" |
		let arg = NOT (mem (el idx ids) tokens)
		    => sprintf "$%d" idx
		     | sprintf "Make_STRING_leaf(wastrsave(stringsp,$%d))" idx
		in
		(sprintf "\n\t    $$ = Make_APPL_ND($$, %s);" arg)
	    )
	in
	"\n\t{ "^(build_call (length ids))^"\n\t    _parser_res = $$;\n\t}"
    in
    pre^body
;

let get_idx cs =
    letrec get cur (c:cs) =
	let co = ord c in
	(co < ord "0") OR (co > ord "9") => cur |
	get (10*cur + (co - ord "0")) cs
     /\    get cur [] = cur
    in
    get 0 cs
;

let emit_line_info line =
    let file = sprintf "set_file_name \"%s\" " yfl_file in
    let line = sprintf "set_line_number %d " line in
    file^line
;

let mk_fl_code line fun_name used ids body =
    let pre1 = emit_line_info line then
    let pre2 = "let "^fun_name^" "^(mem (-1) used => " _line_ " | "") in
    let post = sprintf " = %s;" body in
    let pr i = mem i used => sprintf "ARG%d" i | "" in
    list2str T (pre1^pre2) " " post pr (1 upto length ids)
;


let mk_type_code line fun_name used ids =
    let pre1 = sprintf "\n        %s (" (emit_line_info line) in
    let pre2 = fun_name^" "^(mem (-1) used => " _line_ " | "") in
    let post = ")" in
    let pr i = mem i used => sprintf "%s" (el i ids) | "" in
    list2str T (pre1^pre2) " " post pr (1 upto length ids)
;

letrec get_rhs s line ids sofar (c:cs) =
    c = "\n" => get_rhs s (line+1) ids (c:sofar) cs
    |
    c = "{" =>
	let ids = sofar = [] => ids | (implode (rev sofar)):ids in
	line, (rev ids), (c:cs)
    |
    (c == " ") OR (c == "\t") =>
	let ids = sofar = [] => ids | (implode (rev sofar)):ids in
	get_rhs s line ids [] cs
    |
    get_rhs s line ids (c:sofar) cs
 /\   get_rhs s line ids sofar [] =
	eprintf "Cannot extract rule in '%s'\n" s
;

let line_command_string = "$line$";

let is_line_cmd es =
    let ls = explode line_command_string in
    let lls = length ls in
    (atmost lls es []) == ls
;

let line_cmd_len_m1 = strlen line_command_string-1;


let extract_rule tokens sline lhs s =
    let fn = sprintf "fn_%s" lhs in
    letrec get_rules line idx es =
	val (line, ids, rems) = get_rhs s line [] [] es in
	letrec get_body line used sofar ccnt (c:cs) =
	    c = "\n" => get_body (line+1) used (c:sofar) ccnt cs |
	    c = "{" => 
		let sofar' = (ccnt > 0) => c:sofar | sofar in
		let ccnt' = ccnt + 1 in
		get_body line used sofar' ccnt' cs
	    |
	    c = "}" =>
		let sofar' = (ccnt > 1) => c:sofar | sofar in
		let ccnt' = ccnt - 1 in
		ccnt' = 0 => line, (setify used), (implode (rev sofar')), cs
			   | get_body line used sofar' ccnt' cs
	    |
	    is_line_cmd (c:cs) =>
		let sofar' = "_line_":sofar in
		let used' = -1:used in
		get_body line used' sofar' ccnt (butfirstn line_cmd_len_m1 cs)
	    |
	    c = "$" =>
		let sofar' = "ARG":sofar in
		let used' = (get_idx cs):used in
		get_body line used' sofar' ccnt cs
	    |
		let sofar' = c:sofar in
		get_body line used sofar' ccnt cs
	 /\   get_body line used sofar ccnt [] = 
		eprintf "Cannot extract body in |%s|\n" s
	in
	val (end_line, used, body, rems') = get_body line [] [] 0 rems in
	//
	let fun_name = sprintf "%s_%d" fn idx in
	//
	let fun = mk_fl_code line fun_name used ids body then
	//
	let ycode = mk_bison_rule tokens fun_name used ids then
	//
	let type_code = mk_type_code line fun_name used ids then
	//
	let bidx = find_first0 (\s. s = "|") rems' in
	bidx = 0 => [type_code], [ycode],[fun] |
	let lfs = length (filter (\s. s = "\n") (firstn bidx rems')) in
	val (type_codes, ycodes, funs) =
	    get_rules (end_line+lfs) (idx+1) (butfirstn bidx rems')
	in
	(type_code:type_codes), (ycode:ycodes), (fun:funs)
    in
    val (type_codes, ycodes, funs) = get_rules sline 1 (explode s) then
    (type_codes, ycodes, funs)
;

let compress_line lines =
    letrec count_space_lines cnt (c:cs) =
	(c = " ") OR (c == "\t") => count_space_lines cnt cs |
	(c = "\n") => count_space_lines (cnt+1) cs |
	(c = "") => count_space_lines (cnt+1) cs |
	(cnt, (list2str T "" "\n" "" id (c:cs)))
     /\    count_space_lines cnt [] = (cnt, "")
    in
    count_space_lines 0 lines
;

let extract_parser tokens start_line lines =
    let ridx = find_first0 (str_reg_match "^%%") lines in
    ridx = 0 =>
	eprintf "Missing %%%% in PARSER section in %s" yfl_file 
    |
    let base = firstn (ridx-1) lines in
    let rule_lines = butfirstn ridx lines in
    let start_line = start_line + ridx in
    let parser_prelude =
	[
	    "%{",
	    "#include <stdio.h>",
	    "#include <stdlib.h>",
	    "#include <string.h>",
	    "#include \"fl.h\"",
	    "#include \"graph.h\"",
	    "",
	    PREF "int yyget_lineno  (void);",
	    PREF "extern int	    yylex();",
	    (sprintf "extern int	    %sline_nbr;" prefix_name),
	    "extern g_ptr	    _parser_res;",
	    "extern str_mgr	    *stringsp;",
	    "extern symbol_tbl_ptr  symb_tbl;",
	    (sprintf "extern string	    %s_filename;" prefix_name),
	    PREF "static int        yyerror(const char *msg);",
	    "",
	    "%}",
	    "",
	    "%define api.pure",
	    "%define parse.lac full",
	    "%define parse.error verbose",
	    "%union { string str_t; g_ptr nd_t;}",
	    ""
	]@
	(map (\tk. sprintf "%%token <str_t> %s" tk) tokens)@ base
    in
    let parser_postlude =
	[
	    "",
	    "%%",
	    "",
	    "int",
	    PREF "yyerror(const char *msg)",
	    "{",
	    PREF (sprintf "    Fail_pr(\"Syntax error when parsing %s file around line %%d in file %%s\\n\", %sline_nbr, %s_filename);" prefix_name prefix_name prefix_name),
	    "}"
	]
    in
    letrec get_rules sline lines =
	let sidx = find_first0 (str_reg_match ";") lines then
	sidx = 0 => ([], [], [], []) |
	val (tcodes, lhss, rem_ycodes, all_funs) =
	    get_rules (sline+sidx)(butfirstn sidx lines)
	then
	val (space_lines, rule) = compress_line (firstn sidx lines) in
	let sline = sline + space_lines in
	val [lhs,spaces, rem] =
	    rget "[ \t]*([a-zA-Z][a-zA-Z0-9_]*)([ \t\n]*):(.*)$" rule
	in
	let lfs = length (filter (\s. s = "\n") (explode spaces)) in
	let sline = sline+lfs in
	val (type_codes, ycodes, funs) = extract_rule tokens sline lhs rem in 
	let tcode = 
	    let pre = sprintf "    let %s =" lhs in
	    list2str T pre " \n        catch" "\n    in" id type_codes
	in
	let ycode =
	    list2str T (sprintf "%s:\n\t" lhs) "\n\t| " "\n\t;\n" id ycodes
	in
	(tcode:tcodes, lhs:lhss, ycode:rem_ycodes, funs@all_funs)
    in
    val (tcodes,lhss, ycodes, all_funs) = get_rules start_line rule_lines then
    let bison_code = parser_prelude @
	    (map (\t. sprintf "%%type <nd_t> %s;" t) lhss)@["", "%%", ""]@
	    ycodes @ parser_postlude
    in
    (bison_code, tcodes, lhss, all_funs)
;


let emit_code fl_code tokens flex_code parser_res =
    // Parse the .yfl file and extract the pieces.
    val (bison_code, type_code, lhss, all_funs) = parser_res in
    // 
    let pr fp s = fprintf fp "%s" s in
    //
    // =============== Emit typechecking code ===============
    let filename = base_name^".typecheck" then
    let tfp = fopen filename "w" then
    (foreach (fprintf tfp "%s\n") fl_code) fseq
    (list2fp tfp T "" "\n\n" "\n" pr all_funs) fseq
    let pr_token fp t = fprintf fp "let %s = \"\";" t in
    (list2fp tfp T "" "\n" "\n\n" pr_token tokens) fseq
    (fprintf tfp "letrec _Q_ =\n") fseq
    (list2fp tfp T "    val (" ", " ") = _Q_ in\n" id lhss) fseq
    (list2fp tfp T "" "\n" "\n" pr type_code) fseq
    (list2fp tfp T "    (" ", " ")\n;\n\nlet _TyPe_ = fst _Q_;\n" id lhss) fseq
    (fprintf tfp "let rtype = get_return_type \"_TyPe_\";\n") fseq
    (fprintf tfp "system (sprintf \"echo '%%s' > %s.return_type\" rtype);\n"
		base_name) fseq
    (fprintf tfp "quit;\n") fseq
    (fclose tfp) fseq
    // =============== Extract the return type ===============
    val (ret, outs, errs) = system2 (sprintf "fl -noX -F %s" filename) then
    ret != 0 =>
	eprintf "Typechecking of %s failed.\n%s\n" yfl_file (sl2s errs)
    |
    let fp = fopen (sprintf "%s.return_type" base_name) "r" then
    let return_type = string_butlastn (fgets fp) 1 then
    (fclose fp) fseq
    // =============== Emit flex code ===============
    let lfp = fopen (base_name^".l") "w" then
    (list2fp lfp T "" "\n" "\n" pr flex_code) fseq
    (fclose lfp) fseq
    // =============== Emit bison code ===============
    let pr fp s = fprintf fp "%s" s in
    let yfp = fopen (base_name^".y") "w" then
    (list2fp yfp T "" "\n" "\n" pr bison_code) fseq
    (fclose yfp) fseq
    // =============== Emit C code ===============
    let Cfp = fopen (base_name^".c") "w" then
    let flfp = fopen (base_name^".fl") "w" then
    (fprintf Cfp "#include \"fl.h\"\n") fseq
    (fprintf Cfp "#include \"graph.h\"\n") fseq
    (fprintf Cfp "#include \"%s.tab.h\"\n\n" prefix_name) fseq
    (fprintf Cfp "extern FILE *%sin;\n" prefix_name) fseq
    (fprintf Cfp "extern str_mgr     *stringsp;\n") fseq
    (fprintf Cfp "extern symbol_tbl_ptr   symb_tbl;\n") fseq
    (fprintf Cfp "extern char         FailBuf[4096];\n") fseq
    (fprintf Cfp "static char fl_defs[] = {\n  ") fseq
    let put line = 
	(fprintf flfp "%s\n" line) fseq
	(foreach (\c. fprintf Cfp "%d, " (ord c)) (explode line)) fseq
	(fprintf Cfp "%d,\n  " (ord "\n"))
    in
    (foreach put fl_code) fseq
    (fprintf Cfp "  /* --------------------------------------------- */\n") fseq
    (foreach put all_funs) fseq
    (fclose flfp) fseq
    (fprintf Cfp "0};\n") fseq
    (fprintf Cfp "\n\ng_ptr   _parser_res;\n\n") fseq
    (fprintf Cfp "\n\nstring %s_filename;\n" prefix_name) fseq
    //
    (fprintf Cfp "static void\n") fseq
    (fprintf Cfp "do_parse_%s(g_ptr redex)\n" prefix_name) fseq
    (fprintf Cfp "{\n") fseq
    (fprintf Cfp "    g_ptr   gfile, gdo_debug;\n") fseq
    (fprintf Cfp "    string  filename;\n") fseq
    (fprintf Cfp "\n") fseq
    (fprintf Cfp "    EXTRACT_2_ARGS(redex, gfile, gdo_debug);\n") fseq
    (fprintf Cfp "    filename = GET_STRING(gfile);\n") fseq
    (fprintf Cfp "    %s_filename = filename;\n" prefix_name) fseq
    (fprintf Cfp "\n") fseq
    (do_debug => (fprintf Cfp "if(GET_BOOL(gdo_debug) == B_One()) { %sdebug = 1;}" prefix_name) | ()) fseq
    (fprintf Cfp "    // Call the bison/flex parser on the file given\n") fseq
    (fprintf Cfp "    if( (%sin = fopen(filename, \"r\")) == NULL ) {\n" prefix_name) fseq
    (fprintf Cfp "        MAKE_REDEX_FAILURE(redex,Fail_pr(\"Cannot open file %%s\\n\", filename));\n") fseq
    (fprintf Cfp "        return;\n") fseq
    (fprintf Cfp "    }\n") fseq
    (fprintf Cfp "    int ret = %sparse();\n" prefix_name) fseq
    (fprintf Cfp "    fclose(%sin);\n" prefix_name) fseq
    (fprintf Cfp "\n") fseq
    (fprintf Cfp "    if( ret != 0 ) {\n") fseq
    (fprintf Cfp "        MAKE_REDEX_FAILURE(redex, FailBuf);\n") fseq
    (fprintf Cfp "        return;\n") fseq
    (fprintf Cfp "    }\n") fseq

    (fprintf Cfp "    // Result of parsing is in _parser_res\n") fseq
    (fprintf Cfp "    // Should we provide the type????\n") fseq
    (fprintf Cfp "    result_ptr res = Compile(symb_tbl, _parser_res, NULL, FALSE, FALSE);\n") fseq
    (fprintf Cfp "    g_ptr gres = Eval(res->expr);\n") fseq
    (fprintf Cfp "    OVERWRITE(redex, gres);\n") fseq
    (fprintf Cfp "    return;\n") fseq
    (fprintf Cfp "}\n\n\n") fseq
    // -----------------------------------------------------------
    (fprintf Cfp "bool\n") fseq
    (fprintf Cfp "Install_%s()\n" prefix_name) fseq
    (fprintf Cfp "{\n") fseq
    (fprintf Cfp "\n") fseq
    (fprintf Cfp "    // Write out preamble fl file\n") fseq
    (fprintf Cfp "    FILE    *tfp;\n") fseq
    (fprintf Cfp "    string  tname;\n") fseq
    (fprintf Cfp "    if( !Mk_output_file_in_tmp_dir(\"%s_fl\", &tfp, &tname) ) {\n" prefix_name) fseq
    (fprintf Cfp "        Eprintf(\"Cannot create temporary filename!\");\n") fseq
    (fprintf Cfp "        return FALSE;\n") fseq
    (fprintf Cfp "    }\n") fseq
    (fprintf Cfp "    string s = fl_defs;\n") fseq
    (fprintf Cfp "    while( *s != 0 ) {\n") fseq
    (fprintf Cfp "        fputc(*s, tfp);\n") fseq
    (fprintf Cfp "        s++;\n") fseq
    (fprintf Cfp "    }\n") fseq
    (fprintf Cfp "    fclose(tfp);\n") fseq
    (fprintf Cfp "    // Now load preamble\n") fseq
    (fprintf Cfp "    if( Read_from_file(tname, FALSE, FALSE) != 0 ) {\n") fseq
    (fprintf Cfp "        Eprintf(\"Failed loading %%s\\n\", tname);\n") fseq
    (fprintf Cfp "        return FALSE;\n") fseq
    (fprintf Cfp "    }\n") fseq
    (fprintf Cfp "\n") fseq
    (fprintf Cfp "    typeExp_ptr return_type = Get_Type(\"%s\", NULL, TP_DONT_INSERT);\n" return_type) fseq
    (fprintf Cfp "    if( return_type == NULL ) {\n") fseq
    (fprintf Cfp "        Eprintf(\"Cannot find return type %s\\n\");\n" return_type) fseq
    (fprintf Cfp "        return( FALSE );\n") fseq
    (fprintf Cfp "    }\n") fseq
    (fprintf Cfp "\n") fseq
    (fprintf Cfp "    Add_ExtAPI_Function(\"parse_%s\", \"11\", FALSE," prefix_name) fseq
    (fprintf Cfp " GLmake_arrow(GLmake_string(), GLmake_arrow(GLmake_bool(), return_type)),") fseq
    (fprintf Cfp " do_parse_%s);\n" prefix_name) fseq
    (fprintf Cfp "    return TRUE;\n") fseq
    (fprintf Cfp "}\n") fseq
    (fclose Cfp)
;


let compile_c suffix_name =
    let src_dir = (get_vossrc "VOSS-BINARY-DIRECTORY")^"/../src" then
    let output = (string_butlastn (base_name^suffix_name) 2)^".o" in
    let c_cmd = sprintf "clang -I%s/bin/fl -I%s/include -c -g -fPIC -o %s %s%s"
		    src_dir src_dir output base_name suffix_name
    then
    val (ret, outs, errs) = system2 c_cmd then
    ret != 0 =>
	eprintf "Failed to compile %s%s with command: %s\n%s\n"
		base_name suffix_name c_cmd (sl2s errs)
    |
    NOT do_debug => () |
    (fprintf stdinfo "Succesfully compiled %s\n" output)
;


let parse_yfl {dummy::void} =
    let lines = read_file yfl_file then
    let gl_start = find_first0 (str_reg_match "%%FLCODE") lines in
    gl_start = 0 => eprintf "Missing %%FLCODE in %s\n" yfl_file |
    let sc_start = find_first0 (str_reg_match "%%SCANNER") lines in
    sc_start = 0 => eprintf "Missing %%SCANNER in %s\n" yfl_file |
    let p_start = find_first0 (str_reg_match "%%PARSER") lines in
    p_start = 0 => eprintf "Missing %%PARSER in %s\n" yfl_file |
    //
    let get_block start end =
	let tail = butfirstn start lines in
	end = (-1) => tail |
	firstn (end-start-1) tail
    in
    let fl_code = extract_fl_code gl_start (get_block gl_start sc_start) then
    val (tokens, flex_code) =
	extract_scanner (sc_start+1) (get_block sc_start p_start)
    then
    let parse_res =
	extract_parser tokens (p_start+1) (get_block p_start (-1))
    then
    (emit_code fl_code tokens flex_code parse_res) fseq
    // Now run bison and flex
    let bison_cmd = sprintf "bison -v -t --defines=%s.tab.h -o %s.tab.c -p %s %s.y"
		    base_name base_name prefix_name base_name
    then
    val (ret, outs, errs) = system2 bison_cmd then
    ret != 0 =>
	eprintf "bison failed for command %s\n%s" bison_cmd (sl2s errs)
    |
    let flex_cmd = sprintf "flex -o %s.lex.c -P %s %s.l"
		base_name prefix_name base_name then
    val (ret, outs, errs) = system2 flex_cmd then
    ret != 0 =>
	eprintf "flex failed for command %s\n%s\n" flex_cmd (sl2s errs)
    |
    // Now compile the C files
    (compile_c ".c") fseq
    (compile_c ".lex.c") fseq
    (compile_c ".tab.c") fseq
    // Create dynamic library
    let bin_dir = get_vossrc "VOSS-BINARY-DIRECTORY" then
    let lib_dir = bin_dir^"/../src/lib" then
    let lcmd = sprintf
	"clang -o lib%s.so -shared -fPIC %s.lex.o %s.o %s.tab.o %s/libfl.so"
	prefix_name base_name base_name base_name bin_dir
    then
    val (ret, outs, errs) = system2 lcmd then
    ret != 0 =>
	eprintf "Failed to build shared library!\nCommand: %s\n%s\n"
		lcmd (sl2s errs)
    |
    ()
;

parse_yfl ();

do_debug => () |
    let rm1 f =
	let cmd = sprintf "/bin/rm -f %s%s" base_name f in
	(system cmd) fseq ()
    in
    foreach rm1 [".fl",
		 ".l",
		 ".tab.c",
		 ".typecheck",
		 ".output",
		 ".y",
		 ".c",
		 ".lex.c",
		 ".tab.h",
		 ".return_type",
		 ".o",
		 ".lex.c",
		 ".lex.o",
		 ".tab.o"
];


fprintf stdinfo "Successfully built the dynamic libarary lib%s.so that installs the function parse_%s.\n" prefix_name prefix_name;

quit;
 
