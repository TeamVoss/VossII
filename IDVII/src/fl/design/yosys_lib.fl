//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

let yosys_PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs) =
    let get_act (PINST _ _ _ c_fa_inps c_fa_outs _ _) =
	(flatmap snd c_fa_inps) @ (flatmap snd c_fa_outs)
    in
    let used = filter (\n. NOT(str_is_prefix "0b" n)) (flatmap get_act chs) then
    let ios = map fst (fa_inps @ fa_outs) in
    let ints' = (ints @ used) vec_subtract ios then
    (PINST name attrs leaf fa_inps fa_outs ints' (P_HIER chs))
;

let mk_ifc_signal fa_r sz name act =
    let formal = mk_name sz name then
    let Wvar = W_VAR sz name then
    (fa_r := ((formal, act): deref fa_r)) fseq
    Wvar
;

let mk_int_signal int_r sz name =
    let formal = mk_name sz name then
    let Wvar = W_VAR sz name then
    (int_r := (formal: deref int_r)) fseq
    Wvar
;

let get_generic name =
    let file = sprintf "%s/generics/%s.pexlif" DIR name in
    read_pexlif file
;

let _SignExt sz avs =
    let bits = cexpand_vectors avs then
    let l = length bits in
    let msb = hd bits in
    let pref =
	msb = "0" => [sprintf "0b%*b" (sz-l) 0] |
	msb = "1" => [sprintf "0b%*b" (sz-l) (2**(sz-l)-1)] |
	replicate (sz-l) msb
    in
    let merge l =
	length l < 2 => l |
	val (b1:b2:rem) = l in
	NOT (str_is_prefix "0b" b1) => l |
	NOT (str_is_prefix "0b" b2) => l |
	(b1^(string_tl (string_tl b2))):rem
    in
    merge (pref@avs)
;

let _ZeroExt sz avs =
    let bits = cexpand_vectors avs then
    let l = length bits in
    let new = sprintf "0b%*b" (sz-l) 0 in
    new:avs
;

let mk_attr src file lineno =
    src = "" => [("fl_src", sprintf "%s:%d" file lineno)]
    | [("fl_src", sprintf "%s:%d" file lineno), ("src", src)]
;

let update_attrs_and_ios attrs fa_inps fa_outs p =
    val (PINST name oattrs lf ofa_inps ofa_outs ints body) = p in
    PINST name attrs lf fa_inps fa_outs ints body
;

let _not sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name sz "Y" in
    let Y = W_VAR sz "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_NOT A)] in
    PINST "draw_not" attrs T fa_inps fa_outs ints leaf
;

let _buf sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name sz "Y" in
    let Y = W_VAR sz "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y A] in
    PINST "draw_buffer" attrs T fa_inps fa_outs ints leaf
;

let _logic_not sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_EQ A (W_CONST sz 0))] in
    PINST "draw_unary_arithm {==0}" attrs T fa_inps fa_outs ints leaf
;

let mk_rtl op name attrs sz out inp1 inp2 =
    let f_out = mk_name sz "Y" in
    let Y = W_VAR sz "Y" in
    let f_inp1 = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let f_inp2 = mk_name sz "B" in
    let B = W_VAR sz "B" in
    let fa_inps = [(f_inp1, inp1), (f_inp2, inp2)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (op A B)] in
    PINST name attrs T fa_inps fa_outs ints leaf
;

let _sshl sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_SHL "draw_rtl {<<}" attrs sz
;

let _shl sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_SHL "draw_rtl {<<}" attrs sz
;

let _sub sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_SUB "draw_rtl {-}" attrs sz
;

let _add sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_ADD "draw_rtl {+}" attrs sz
;

let _mul sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_MUL "draw_rtl {*}" attrs sz
;

let _div sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_DIV "draw_rtl {/}" attrs sz
;

let _mod sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_MOD "draw_rtl {%}" attrs sz
;

let _and sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_AND "draw_and2" attrs sz
;

let _or sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_rtl W_OR "draw_or2" attrs sz
;

let _xor sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fn A B = W_OR (W_AND (W_NOT A) B) (W_AND A (W_NOT B)) in
    mk_rtl fn "draw_xor2" attrs sz
;

let _neg sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name sz "Y" in
    let Y = W_VAR sz "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_SUB (W_CONST sz 0) A)] in
    PINST "draw_unary_arithm {-}" attrs T fa_inps fa_outs ints leaf
;

let _shr  o_sz a_sz b_sz src out inp1 inp2 =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name o_sz "Y" in
    let Y = W_VAR o_sz "Y" in
    let f_inp1 = mk_name a_sz "A" in
    let A = W_VAR a_sz "A" in
    let f_inp2 = mk_name b_sz "B" in
    let B = W_VAR b_sz "B" in
    let fa_inps = [(f_inp1, inp1), (f_inp2, inp2)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_SHR A B)] in
    PINST "draw_rtl {>>}" attrs T fa_inps fa_outs ints leaf
;

let _ashr  o_sz a_sz b_sz src out inp1 inp2 =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name o_sz "Y" in
    let Y = W_VAR o_sz "Y" in
    let f_inp1 = mk_name a_sz "A" in
    let A = W_VAR a_sz "A" in
    let f_inp2 = mk_name b_sz "B" in
    let B = W_VAR b_sz "B" in
    let fa_inps = [(f_inp1, inp1), (f_inp2, inp2)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_ASHR A B)] in
    PINST "draw_rtl {|>>}" attrs T fa_inps fa_outs ints leaf
;

let _land sz src out inp1 inp2 =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let op A B = 
	let A_T = W_NOT (W_EQ A (W_CONST sz 0)) in
	let B_T = W_NOT (W_EQ B (W_CONST sz 0)) in
	W_AND A_T B_T
    in
    mk_rtl op "draw_and2" attrs sz out inp1 inp2
;

let _lor sz src out inp1 inp2 =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let op A B = 
	let A_T = W_NOT (W_EQ A (W_CONST sz 0)) in
	let B_T = W_NOT (W_EQ B (W_CONST sz 0)) in
	W_OR A_T B_T
    in
    mk_rtl op "draw_or2" attrs sz out inp1 inp2
;

let mk_cmp op name attrs sz out inp1 inp2 =
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp1 = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let f_inp2 = mk_name sz "B" in
    let B = W_VAR sz "B" in
    let fa_inps = [(f_inp1, inp1), (f_inp2, inp2)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (op A B)] in
    PINST name attrs T fa_inps fa_outs ints leaf
;

let _eqx sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp W_EQ "draw_rtl {=}" attrs sz
;

let base_eq sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp W_EQ "draw_rtl {=}" attrs sz
;

let _eq sz src out inp1 inp2 =
    let base = base_eq sz src out inp1 inp2 in
    length inp2 != 1 => base |
    let i2 = hd inp2 in
    NOT (str_is_prefix "0b" i2) => base |
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp1 = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp1, inp1)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let v = sscanf "0b%b" i2 in
    let B = W_CONST sz v in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_EQ A B)] in
    let pfn = sprintf "draw_unary_arithm {=0x%x}" v in
    PINST pfn attrs T fa_inps fa_outs ints leaf
;
    

let _ne sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp (\w1.\w2. W_NOT (W_EQ w1 w2)) "draw_rtl {!=}" attrs sz
;

let _gt sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp W_GR "draw_rtl {>}" attrs sz
;

let _ge sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp (\w1.\w2. W_OR (W_GR w1 w2) (W_EQ w1 w2)) "draw_rtl {>=}" attrs sz
;

let _lt sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp (\w1.\w2. W_GR w2 w1)  "draw_rtl {<}" attrs sz
;

let _le sz src =
    let attrs = mk_attr src __FILE__ __LINE__ then
    mk_cmp (\w1.\w2. W_OR (W_GR w2 w1) (W_EQ w1 w2)) "draw_rtl {<=}" attrs sz
;


let _mux sz src out inp1 inp2 s =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name sz "Y" in
    let Y = W_VAR sz "Y" in
    let f_inp1 = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let f_inp2 = mk_name sz "B" in
    let B = W_VAR sz "B" in
    let f_s = mk_name 1 "S" in
    let S = W_VAR 1 "S" in
    let fa_inps = [(f_s,s), (f_inp2, inp2), (f_inp1, inp1)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_ITE S B A)] in
    PINST "draw_ite" attrs T fa_inps fa_outs ints leaf
;

let _base_pmux out_sz sel_sz src out inp1 inp2 s =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name out_sz "Y" in
    let Y = W_VAR out_sz "Y" in
    let f_inp1 = mk_name out_sz "A" in
    let A = W_VAR out_sz "A" in
    let f_inp2 = mk_name (sel_sz * out_sz) "B" in
    let B = W_VAR (sel_sz * out_sz) "B" in
    let f_s = mk_name sel_sz "S" in
    let S = W_VAR sel_sz "S" in
    let fa_inps = [(f_inp2, inp2), (f_inp1, inp1), (f_s,s)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    letrec select cur seen i =
        i < 0 => cur |
        let Si = W_SLICE [i] S in
        let Bi = W_SLICE (((i+1)*out_sz-1)--(i*out_sz)) B in
        let cur' = W_ITE (W_NOT Si) cur (W_ITE (W_NOT seen) Bi (W_X out_sz)) in
        let seen' = W_OR seen Si in
        select cur' seen' (i-1)
    in
    let eq = select A (W_CONST 1 0) (sel_sz-1) in
    let leaf = P_LEAF [W_UPDATE_FN Y eq] in
    PINST (sprintf "draw_pmux %d %d" out_sz sel_sz) attrs T fa_inps fa_outs ints leaf
;   


let cluster_inputs out_sz inp =
    (
	let inp_l = md_expand_vectors inp in
        let chunks = cluster out_sz inp_l in
        map md_merge_vectors chunks
    ) catch eprintf "cluster_inputs failed for %d %S\n" out_sz inp
;
	


let _gen_pmux out_sz sel_sz src out inp1 inp2 s =
    let base = _base_pmux out_sz sel_sz src out inp1 inp2 s in
    (
	let attrs = mk_attr src __FILE__ __LINE__ then
	let f_out = mk_name out_sz "Y" in
	let Y = W_VAR out_sz "Y" in
	let f_inp1 = mk_name out_sz "A" in
	let A = W_VAR out_sz "A" in
	let bs = cluster_inputs out_sz inp2 in
	length bs != sel_sz => (
	    (fprintf stderr "Lengh mismatch in _gen_pmux\n|%S| != %d\n"
		    (map (sprintf "%S") bs) sel_sz) fseq
	    error "Length mismatch"
	) |
	let Bs = map (\i. W_VAR out_sz (sprintf "B_%d" i)) (1 upto sel_sz) in
	let f_b = map (\i. mk_name out_sz (sprintf "B_%d" i)) (1 upto sel_sz) in
	let fa_B_inps = zip f_b bs in
	let f_s = map (\i. mk_name 1 (sprintf "S_%d" i)) (1 upto sel_sz) in
	let Ss = map (\i. W_VAR 1 (sprintf "S_%d" i)) (1 upto sel_sz) in
	let fa_S_inps = map2 (\f.\a. f,[a]) f_s s in
	let fa_inps =
	    (flatmap (\p. [(fst p),(snd p)]) (zip fa_S_inps fa_B_inps)) @
	    [(f_inp1,inp1)]
	in
	let fa_outs = [(f_out, out)] in
	let ints = [] in
	letrec select (sel:sels) (b:bs) = 
		W_ITE sel b (select sels bs)
	 /\    select [] [] = A
	in
	let eq = select Ss Bs in
	let leaf = P_LEAF [W_UPDATE_FN Y eq] in
	PINST (sprintf "draw_CASE %d" sel_sz) attrs T fa_inps fa_outs ints leaf
    ) gen_catch (\msg. (fprintf stderr "Debug: %s\n" msg) fseq base)
;

let binarystring2wconst out_sz s =
    let s = str_is_prefix "0b" s => substr s 3 (-1) | s in
    let es = explode s in
    let tp = setify es in
    tp = ["x"] => W_X out_sz |
    ((setify es) subtract ["0", "1"]) = [] => W_CONST out_sz (sscanf "%b" s) |
    letrec merge cs =
	cs = [] => [] |
	let idxb = find_first0 (\x.x != "x") cs in
	idxb = 0 => [(W_X (length cs))] |
	let xs = firstn (idxb-1) cs in
	(xs = [] => [] |  [(W_X (length xs))])@
	let rem = butfirstn (idxb-1) cs in
	let idxx = find_first0 (\x.x = "x") rem in
	idxx = 0 => [(W_CONST (length rem) (sscanf "%b" (implode rem)))] |
	let bin = firstn (idxx-1) rem in
	(bin = [] => [] | [(W_CONST (length bin) (sscanf "%b" (implode bin)))])@
	merge (butfirstn (idxx-1) rem)
    in
    let res = merge es then
    length res = 1 => hd res |
    W_CAT res
;


let _pmux out_sz sel_sz src out inp1 inp2 s =
    let base = _gen_pmux out_sz sel_sz src out inp1 inp2 s in
    length inp1 != 1 => base |
    NOT (str_is_prefix "0b" (hd inp1)) => base |
    length inp2 != 1 => base |
    NOT (str_is_prefix "0b" (hd inp2)) => base |
    let i2 = hd inp2 in
    let i2 = str_is_prefix "0b" i2 => substr i2 3 (-1) | i2 in
    (
    // Special case statement
    let attrs = mk_attr src __FILE__ __LINE__ then
    let Y = W_VAR out_sz "Y" in
    let f_out = mk_name out_sz "Y" in
    let fa_outs = [(f_out, out)] in
    let f_s = map (\i. mk_name 1 (sprintf "S_%d" i)) (1 upto sel_sz) in
    let Ss = map (\i. W_VAR 1 (sprintf "S_%d" i)) (1 upto sel_sz) in
    let fa_inps = map2 (\f.\a. f,[a]) f_s s in
    let ints = [] in
    let A = binarystring2wconst out_sz (hd inp1) in
    let mkC t = W_CONST out_sz (sscanf "%b" t) in
    let choices = str_cluster i2 out_sz in
    let Bs = map (binarystring2wconst out_sz) choices in
    letrec select (sel:sels) (b:bs) =
	    W_ITE sel b (select sels bs)
     /\    select [] [] = A
    in
    let eq = select Ss Bs in
    let leaf = P_LEAF [W_UPDATE_FN Y eq] in
    let post = sprintf "} %s" (substr (hd inp1) 3 (-1)) in
    let pfn = list2str T "draw_vcase {" " " post id choices then
    PINST pfn attrs T fa_inps fa_outs ints leaf
    ) gen_catch (\msg.
	(fprintf stderr "Failure caught for %s\n" msg) fseq
	base
    )
;

let _logic_reduce_bool sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_NOT (W_EQ A (W_CONST sz 0)))] in
    PINST "draw_unary_arithm {!=0}" attrs T fa_inps fa_outs ints leaf
;

let _logic_reduce_or sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_NOT (W_EQ A (W_CONST sz 0)))] in
    PINST "draw_unary_arithm {!=0}" attrs T fa_inps fa_outs ints leaf
;

let _logic_reduce_and sz src out inp =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let f_out = mk_name 1 "Y" in
    let Y = W_VAR 1 "Y" in
    let f_inp = mk_name sz "A" in
    let A = W_VAR sz "A" in
    let fa_inps = [(f_inp, inp)] in
    let fa_outs = [(f_out, out)] in
    let ints = [] in
    let leaf = P_LEAF [W_UPDATE_FN Y (W_EQ A (W_CONST sz (2**sz-1)))] in
    PINST "draw_and_n" attrs T fa_inps fa_outs ints leaf
;

// NOTE: 'en' not used!
let _memrd src width abits mem {en::string list} addr data =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let lines = (md_size mem)/width in
    let mem_info = MEM abits lines width in
    let f_data = mk_name width "DATA" in
    let DATA = W_VAR width "DATA" in
    let f_addr = mk_name abits "ADDR" in
    let ADDR = W_VAR abits "ADDR" in
    let MEM = W_VAR (lines*width) "MEM" in
    let f_MEM = mk_name (lines*width) "MEM" in
    let child_leaf = P_LEAF [W_UPDATE_FN DATA (W_MEM_READ mem_info MEM ADDR)] in
    let child =
        PINST "mem" [] T [(f_MEM, [mem]), (f_addr,[f_addr])]
                         [(f_data,[f_data])] [] child_leaf
    in
    let pfn = sprintf "draw_mem_read %d" lines in
    PINST pfn attrs T [(f_addr,addr), (mem,[mem])] [(f_data,data)] []
                    (P_HIER [child])
;

// NOTE: Assumes this is only used for ROMs!!!!!
let _meminit src width abits mem inits =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let init = string_tl (string_tl (hd inits)) in
    let lines = (md_size mem)/width in
    let sz = lines*width in
    let MEM = W_VAR sz "MEM" in
    let f_MEM = mk_name sz "MEM" in
    let content = sscanf "%b" init then
    let child_leaf = P_LEAF [W_UPDATE_FN MEM (W_CONST sz content)] in
    let child = PINST "mem" [] T [] [(f_MEM, [mem])] [] child_leaf in
    let pfn = sprintf "draw_mem_init %d {%s}" width init in
    PINST pfn attrs T [] [(mem,[mem])] [] (P_HIER [child])
;

// Assumes only one write port!!!!!!
let _memwr src width abits mem en addr data =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let lines = (md_size mem)/width in
    let mem_info = MEM abits lines width in
    let bits = lines*width in
    //
    let f_DATA = mk_name width "DATA" in
    let DATA = W_VAR width "DATA" in
    let f_EN = mk_name width "EN" in
    let EN = W_VAR width "EN" in
    let f_ADDR = mk_name abits "ADDR" in
    let ADDR = W_VAR abits "ADDR" in
    let MEM = W_VAR bits "MEM" in
    let f_MEM = mk_name bits "MEM" in
    // Intermediate signals
    let OLD = W_VAR bits "OLD" in
    let f_OLD = mk_name bits "OLD" in
    let OLD_DATA = W_VAR width "OLD_DATA" in
    let f_OLD_DATA = mk_name width "OLD_DATA" in
    let f_NEG_EN = mk_name width "NEG_EN" in
    let NEG_EN = W_VAR width "NEG_EN" in
    let f_A1 = mk_name width "A1" in
    let A1 = W_VAR width "A1" in
    let f_A2 = mk_name width "A2" in
    let A2 = W_VAR width "A2" in
    let NEW_DATA = W_VAR width "NEW_DATA" in
    let f_NEW_DATA = mk_name width "NEW_DATA" in
    let phase_del =
	let lf = P_LEAF [W_PHASE_DELAY OLD MEM] in
	PINST "draw_delay" [] T [(f_MEM, [f_MEM])] [(f_OLD,[f_OLD])] [] lf
    in
    let read =
	let lf = P_LEAF [W_UPDATE_FN OLD_DATA (W_MEM_READ mem_info OLD ADDR)] in
        PINST "read" [] T [(f_OLD, [f_OLD]), (f_ADDR,[f_ADDR])]
                          [(f_OLD_DATA,[f_OLD_DATA])] [] lf
    in
    let neg =
	let lf = P_LEAF [W_UPDATE_FN NEG_EN (W_NOT EN)] in
	PINST "draw_not" [] T [(f_EN,[f_EN])] [(f_NEG_EN,[f_NEG_EN])] [] lf
    in
    let a1 =
	let lf = P_LEAF [W_UPDATE_FN A1 (W_AND EN DATA)] in
	PINST "draw_and2" [] T [(f_EN,[f_EN]),(f_DATA,[f_DATA])]
			       [(f_A1,[f_A1])] [] lf
    in
    let a2 =
	let lf = P_LEAF [W_UPDATE_FN A2 (W_AND NEG_EN OLD_DATA)] in
	PINST "draw_and2" [] T [(f_NEG_EN,[f_NEG_EN]),(f_OLD_DATA,[f_OLD_DATA])]
			[(f_A2,[f_A2])] [] lf
    in
    let or =
	let lf = P_LEAF [W_UPDATE_FN NEW_DATA (W_OR A1 A2)] in
	PINST "draw_or2" [] T [(f_A1,[f_A1]),(f_A2,[f_A2])]
			[(f_NEW_DATA,[f_NEW_DATA])] [] lf
    in
    let wr =
	let lf =
	    P_LEAF [W_UPDATE_FN MEM (W_MEM_WRITE mem_info OLD ADDR NEW_DATA)]
	in
	PINST "write" [] T
	    [(f_OLD,[f_OLD]),(f_ADDR,[f_ADDR]),(f_NEW_DATA,[f_NEW_DATA])]
	    [(f_MEM, [f_MEM])] [] lf
    in
    let pfn = sprintf "draw_mem_write %d" lines in
    PINST pfn attrs T
	    [(f_DATA,data), (f_EN, en), (f_ADDR,addr)]
	    [(f_MEM, [mem])]
	    [f_OLD, f_OLD_DATA, f_NEG_EN, f_A1, f_A2, f_NEW_DATA]
	    (P_HIER [phase_del,read,neg,a1,a2,or,wr])
;

// Assumes only one write port!!!!!!
let _memwr_v2 src width abits mem en addr data =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let lines = (md_size mem)/width in
    let mem_info = MEM abits lines width in
    let bits = lines*width in
    //
    let f_DATA = mk_name width "DATA" in
    let DATA = W_VAR width "DATA" in
    let f_EN = mk_name width "EN" in
    let EN = W_VAR width "EN" in
    let f_ADDR = mk_name abits "ADDR" in
    let ADDR = W_VAR abits "ADDR" in
    let MEM = W_VAR bits "MEM" in
    let f_MEM = mk_name bits "MEM" in
    // Intermediate signals
    let OLD = W_VAR bits "OLD" in
    let f_OLD = mk_name bits "OLD" in
    let OLD_DATA = W_VAR width "OLD_DATA" in
    let f_OLD_DATA = mk_name width "OLD_DATA" in
    let f_NEG_EN = mk_name width "NEG_EN" in
    let NEG_EN = W_VAR width "NEG_EN" in
    let f_A1 = mk_name width "A1" in
    let A1 = W_VAR width "A1" in
    let f_A2 = mk_name width "A2" in
    let A2 = W_VAR width "A2" in
    let NEW_DATA = W_VAR width "NEW_DATA" in
    let f_NEW_DATA = mk_name width "NEW_DATA" in
    let phase_del =
	let lf = P_LEAF [W_PHASE_DELAY OLD MEM] in
	PINST "draw_delay" [] T [(f_MEM, [f_MEM])] [(f_OLD,[f_OLD])] [] lf
    in
    let read =
	let lf = P_LEAF [W_UPDATE_FN OLD_DATA (W_MEM_READ mem_info OLD ADDR)] in
        PINST "read" [] T [(f_OLD, [f_OLD]), (f_ADDR,[f_ADDR])]
                          [(f_OLD_DATA,[f_OLD_DATA])] [] lf
    in
    let neg =
	let lf = P_LEAF [W_UPDATE_FN NEG_EN (W_NOT EN)] in
	PINST "draw_not" [] T [(f_EN,[f_EN])] [(f_NEG_EN,[f_NEG_EN])] [] lf
    in
    let a1 =
	let lf = P_LEAF [W_UPDATE_FN A1 (W_AND EN DATA)] in
	PINST "draw_and2" [] T [(f_EN,[f_EN]),(f_DATA,[f_DATA])]
			       [(f_A1,[f_A1])] [] lf
    in
    let a2 =
	let lf = P_LEAF [W_UPDATE_FN A2 (W_AND NEG_EN OLD_DATA)] in
	PINST "draw_and2" [] T [(f_NEG_EN,[f_NEG_EN]),(f_OLD_DATA,[f_OLD_DATA])]
			[(f_A2,[f_A2])] [] lf
    in
    let or =
	let lf = P_LEAF [W_UPDATE_FN NEW_DATA (W_OR A1 A2)] in
	PINST "draw_or2" [] T [(f_A1,[f_A1]),(f_A2,[f_A2])]
			[(f_NEW_DATA,[f_NEW_DATA])] [] lf
    in
    let wr =
	let lf =
	    P_LEAF [W_UPDATE_FN MEM (W_MEM_WRITE mem_info OLD ADDR NEW_DATA)]
	in
	PINST "write" [] T
	    [(f_OLD,[f_OLD]),(f_ADDR,[f_ADDR]),(f_NEW_DATA,[f_NEW_DATA])]
	    [(f_MEM, [f_MEM])] [] lf
    in
    let pfn = sprintf "draw_mem_write %d" lines in
    PINST pfn attrs T
	    [(f_DATA,data), (f_EN, en), (f_ADDR,addr)]
	    [(f_MEM, [mem])]
	    [f_OLD, f_OLD_DATA, f_NEG_EN, f_A1, f_A2, f_NEW_DATA]
	    (P_HIER [phase_del,read,neg,a1,a2,or,wr])
;

let _dff sz src out clk d =
    let base = resize_pexlif sz (get_generic "re_ff") then
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps = [((mk_name sz "d"), d), ("clk", clk)] then 
    let fa_outs = [((mk_name sz "q"), out)] then 
    update_attrs_and_ios attrs fa_inps fa_outs base
;


let _dlatch polarity sz src out clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let generic = polarity => get_generic "ah_latch" | get_generic "al_latch" in
    let base = resize_pexlif sz generic in
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps = [((mk_name sz "d"), d), ("clk", clk)] then 
    let fa_outs = [((mk_name sz "q"), out)] then 
    update_attrs_and_ios attrs fa_inps fa_outs base
;

let mk_constant sz pin_name value =
    let pfn = sprintf "draw_constant %s" value then
    let attrs = mk_attr "" __FILE__ __LINE__ then
    let fa_inps = [] in
    let fa_outs = let n = mk_name sz pin_name in [(n,[n])] then
    let ints = [] in
    let Z = W_VAR sz pin_name in
    let ch = P_LEAF [W_UPDATE_FN Z (W_CONST sz (sscanf "%b" value))] in
    PINST pfn attrs T fa_inps fa_outs ints ch
;

let _adlatch p_en p_arst rst_value sz src out clk arst d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let generic = get_generic (assoc (p_en,p_arst) [ ((F,F), "adlatch_0_0"),
						     ((F,T), "adlatch_0_1"),
						     ((T,F), "adlatch_1_0"),
						     ((T,T), "adlatch_1_1")])
    then
    val (PINST nm attrs lf fa_inps fa_outs ints (P_HIER (c:cs))) = generic then
    let c' = mk_constant sz "reset_value" rst_value then
    let p0 = PINST nm attrs lf fa_inps fa_outs ints (P_HIER (c' :cs)) then 
    let p = resize_pexlif sz p0 in
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps = [("clk", clk), ("arst", arst), ((mk_name sz "d"), d)] then 
    let fa_outs = [((mk_name sz "q"), out)] then 
    update_attrs_and_ios attrs fa_inps fa_outs p
;

//_adlatch T T "010" 3 "ds.we:12" ["Out[2:0]"] ["CLK"] ["ARST"] ["D[2:0]"];


let _aldff p_clk p_aload sz src q aload ad clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let generic = get_generic (assoc (p_clk,p_aload) [ ((F,F), "aldff_0_0"),
						       ((F,T), "aldff_0_1"),
						       ((T,F), "aldff_1_0"),
						       ((T,T), "aldff_1_1")])
    then
    let p = resize_pexlif sz generic then
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps = [((mk_name sz "ad"), ad), ("aload", aload),
		   ((mk_name sz "d"), d), ("clk", clk)]
    in
    let fa_outs = [((mk_name sz "q"), q)] then 
    update_attrs_and_ios attrs fa_inps fa_outs p
;

// _aldff T F 3 "ds.we:12" ["Out[2:0]"]  ["LD"] ["iv[2:0]"] ["CLK"] ["D[2:0]"];

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

begin_abstype;

let mk_vec sz name = (mk_name sz name, W_VAR sz name);

let <- lhs rhs =
    let l_sz = wexpr_size lhs in
    let r_sz = wexpr_size rhs in
    l_sz != r_sz =>
        eprintf "Size mismatch in update function\n%d=|%s|\n%d=|%s|)"
                l_sz (Pwexpr lhs) r_sz (Pwexpr rhs)
    |
    NOT (valid_lhs lhs) =>
        eprintf "%s is not a valid lhs expression" (Pwexpr lhs)
    |
    let mk_pinst {lhs::wexpr} {rhs::wexpr} =
        let dep_vars = (w_depends rhs) in
        let inps = map (\n.n,[n]) dep_vars in
        let driven = base_get_lhs_vars lhs in
        let sz = md_sizes driven in
        let lhs' = W_VAR sz "_tmp" in
        let outs = [(mk_name sz "_tmp", driven)] in
        let body = P_LEAF [W_UPDATE_FN lhs' rhs] in
        let pfn = mk_draw_cmd F rhs in
        PINST pfn [] T inps outs [] body
    in
    mk_pinst lhs rhs 
;
infixr 0 <-;

let <: lhs rhs =
    let l_sz = wexpr_size lhs in
    let r_sz = wexpr_size rhs in
    l_sz != r_sz =>
        eprintf "Size mismatch in phase delay\n%d=|%s|\n%d=|%s|)"
                l_sz (Pwexpr lhs) r_sz (Pwexpr rhs)
    |
    NOT (valid_lhs lhs) =>
        eprintf "%s is not a valid lhs expression" (Pwexpr lhs)
    |
    let body = P_LEAF [W_PHASE_DELAY lhs rhs ] in
    let outs = map (\n.n,[n]) (get_lhs_vars lhs) in
    let inps = map (\n.n,[n]) (w_depends rhs) in
    PINST (mk_draw_cmd T rhs) [] T inps outs [] body
;
infix 1 <:;

let '~' e = W_NOT e;
let '&' e f = W_AND e f;
infix 4 '&';
let '|' e f = W_OR e f;
infix 3 '|';
let '=' = W_EQ;
infix 5 '=';



let mk_mem mem_info name =
    val (MEM abits lines width) = mem_info in
    let bits = lines*width in
    let f = sprintf "%s[%d:0][%d:0]" name (lines-1) (width-1) in
    let w = W_EXPLICIT_VAR bits f in
    (f,w)
;

let prim_mem_read mem_info mem addr data =
    val (MEM abits lines width) = mem_info in
    let attrs = mk_attr "" __FILE__ __LINE__ then
    // Inputs
    val (f_data, DATA) = mk_vec width "DATA" in
    val (f_addr, ADDR) = mk_vec abits "DATA" in
    val (f_M, M)   = mk_mem mem_info "MEM" in
    let leaf = DATA <- (W_MEM_READ mem_info M ADDR) in
    let pfn = sprintf "draw_mem_read %d" lines in
    PINST pfn attrs T [(f_addr,addr), (f_M,[mem])] [(f_data,data)] []
                    (P_HIER [leaf])
;

let prim_mem_write mem_info clk_enable clk_polarity
		   w_clk old_mem w_addr w_din w_en new_mem masked_wdata
    =
    val (MEM abits lines width) = mem_info in
    let attrs = mk_attr "" __FILE__ __LINE__ then
    // Inputs
    val (f_M, M) = mk_mem mem_info "M" in
    val (f_ADDR, ADDR) = mk_vec abits "ADDR" in
    val (f_DATA, DATA) = mk_vec width "DATA" in
    val (f_EN, EN) = mk_vec width "EN" in
    val (f_CLK, CLK) = mk_vec 1 "CLK" in
    val (f_OCLK, OCLK) = mk_vec 1 "OCLK" in
    // Output
    val (f_M_OUT, M_OUT) = mk_mem mem_info "M_OUT" in
    val (f_MASKED_WDATA, MASKED_WDATA) = mk_vec width "MASKED_WDATA" in
    // Internal
    val (f_ACTIVE, ACTIVE) = mk_vec 1 "ACTIVE" in
    val (f_OLD, OLD) = mk_vec width "OLD" in
    val (f_INV_EN, INV_EN) = mk_vec width "INV_EN" in
    val (f_A1, A1) = mk_vec width "A1" in
    val (f_A2, A2) = mk_vec width "A2" in
    val (f_TMP, TMP) = mk_mem mem_info "TMP" in
    let leaves = [
	OCLK <: CLK,
	ACTIVE  <- (clk_enable = "0" => W_CONST 1 1 |
		    clk_polarity = "1" => '~' OCLK '&' CLK |
					 OCLK '&' '~' CLK),
        OLD     <- (W_MEM_READ mem_info M ADDR),
        INV_EN  <- '~' EN,
        A1      <- INV_EN '&' OLD,
        A2      <-  EN '&' DATA,
        MASKED_WDATA <-  A1 '|' A2,
        TMP     <-  (W_MEM_WRITE mem_info M ADDR DATA),
        M_OUT <- (W_ITE ACTIVE TMP M)
    ] in
    // Toplevel interfaces
    let fa_inps = [(f_M, old_mem), (f_ADDR, w_addr), (f_DATA, w_din), 
		   (f_EN, w_en), (f_CLK, w_clk)]
    in
    let fa_outs = [(f_M_OUT, new_mem), (f_MASKED_WDATA, masked_wdata)] in
    let ints    = [f_OLD,f_INV_EN,f_A1,f_A2,f_TMP,f_ACTIVE,f_OCLK] in
    let pfn     = "draw_hier prim_mem_write" in
    PINST pfn attrs F fa_inps fa_outs ints (P_HIER leaves)
;

let prim_rw_bypass // Parameters
		   mem_info wr_clk_enable wr_clk_polarity
		   rd_transparency_mask rd_collision_x_mask
		   // Signals
		   inp r_addr wr_clk w_addr w_din out
    =
    val (MEM abits lines width) = mem_info in
    let attrs = mk_attr "" __FILE__ __LINE__ then
    // Inputs
    val (f_INP, INP) = mk_vec width "INP" in
    val (f_CLK, CLK) = mk_vec 1 "CLK" in
    val (f_RD_ADDR, RD_ADDR) = mk_vec abits "RD_ADDR" in
    val (f_WR_ADDR, WR_ADDR) = mk_vec abits "WR_ADDR" in
    val (f_WR_DIN, WR_DIN) = mk_vec width "WR_DIN" in
    // Output
    val (f_OUT, OUT) = mk_vec width "OUT" in
    // Internal
    val (f_M1, M1) = mk_vec width "M1" in
    val (f_M2, M2) = mk_vec width "M2" in
    val (f_ACTIVE,ACTIVE) = mk_vec 1 "ACTIVE" in
    val (f_CTRL, CTRL) = mk_vec 1 "CTRL" in
    val (f_OCLK, OCLK) = mk_vec 1 "OCLK" in
    //
    let not_trans = rd_transparency_mask = "0" in
    let not_coll  = rd_collision_x_mask = "0" in
    let leaves = not_trans AND not_coll => [OUT <- INP] | [
		M1     <- (not_trans => INP  | WR_DIN),
		M2     <- (not_coll => M1 | (W_X width)),
		OUT    <- (W_ITE CTRL M2 INP),
		OCLK   <: CLK,
		ACTIVE <- (wr_clk_enable = "0"   => W_CONST 1 1 |
			   wr_clk_polarity = "1" => '~' OCLK '&' CLK |
						    OCLK '&' '~' CLK),
		CTRL   <- ACTIVE '&' (RD_ADDR '=' WR_ADDR)
	    ]
    in
    // Toplevel interfaces
    let fa_inps = [(f_INP,[inp]), (f_RD_ADDR, [r_addr]), (f_CLK, [wr_clk]),
		   (f_WR_ADDR, [w_addr]), (f_WR_DIN, [w_din])]
    in
    let fa_outs = [(f_OUT, [out])] in
    let ints    = [f_M1, f_M2, f_CTRL, f_OCLK, f_ACTIVE] in
    let pfn     = "draw_hier prim_rw_bypass" in
    PINST pfn attrs F fa_inps fa_outs ints (P_HIER leaves)
;

lettype sval_mode = INIT | XS int | BINS (string list);

let sval2wexpr s =
    let s = str_is_prefix "0b" s => substr s 3 (-1) | s in
    letrec cnv INIT ("x": vs) = cnv (XS 1) vs
     /\    cnv INIT (v:vs) = cnv (BINS [v]) vs
     /\    cnv INIT [] = []
     /\    cnv (XS cnt) ("x":vs) = cnv (XS (cnt+1)) vs
     /\    cnv (XS cnt) (v:vs) =
	(W_X cnt):(cnv (BINS [v]) vs)
     /\    cnv (XS cnt) [] = [(W_X cnt)]
     /\    cnv (BINS ds) ("x":vs) =
	(W_CONST (length ds) (sscanf "%b" (implode (rev ds)))):(cnv (XS 1) vs)
     /\    cnv (BINS ds) (v:vs) =
	    cnv (BINS (v:ds)) vs
     /\    cnv  (BINS ds) [] =
	[(W_CONST (length ds) (sscanf "%b" (implode (rev ds))))]
    in
    let res = cnv INIT (explode s) in
    length res = 1 => hd res |
    W_CAT res
;

let prim_mem_rd_port
		    // Parameters
		    mem_info rd_clk_enable rd_clk_polarity
		    rd_arst_value rd_srst_value
		    rd_ce_over_srst
		    wr_clk_enables wr_clk_polarities
		    rd_transparency_masks rd_collision_x_masks
		    // Signals
		    old_M new_M
		    arst srst
		    rd_clk rd_en rd_addr
		    wr_ports
		    dout
    =
    val (MEM abits lines width) = mem_info in
    let attrs = mk_attr "" __FILE__ __LINE__ then
    // Inputs
    val (f_OLD_M, OLD_M)     = mk_mem mem_info "OLD_M" in
    val (f_NEW_M, NEW_M)     = mk_mem mem_info "NEW_M" in
    val (f_ARST, ARST)       = mk_vec 1 "ARST" in
    val (f_SRST, SRST)       = mk_vec 1 "SRST" in
    val (f_RD_CLK, RD_CLK)   = mk_vec 1 "RD_CLK" in
    val (f_RD_EN, RD_EN)     = mk_vec 1 "RD_EN" in
    val (f_RD_ADDR, RD_ADDR) = mk_vec abits "RD_ADDR" in
    // Outputs
    val (f_DOUT, DOUT)       = mk_vec width "DOUT" in
    // Internal
    val (f_O_RD_CLK, O_RD_CLK) = mk_vec 1 "O_RD_CLK" in
    val (f_ACTIVE, ACTIVE) = mk_vec 1 "ACTIVE" in
    val (f_C1, C1) = mk_vec 1 "C1" in
    val (f_C2, C2) = mk_vec 1 "C2" in
    val (f_C3, C3) = mk_vec 1 "C3" in
    val (f_C4, C4) = mk_vec 1 "C4" in
    val (f_M1, M1) = mk_vec width "M1" in
    val (f_M2, M2) = mk_vec width "M2" in
    val (f_M3, M3) = mk_vec width "M3" in
    val (f_M4, M4) = mk_vec width "M4" in
    val (f_M5, M5) = mk_vec width "M5" in
    val (f_OTMP, OTMP)       = mk_vec width "OTMP" in
    val (f_NRES, NRES) = mk_vec width "NRES" in
    val (f_ORES, ORES) = mk_vec width "ORES" in
    //
    let NOT_CE_OVER_SRST = W_CONST 1 ((rd_ce_over_srst = "1") => 0 | 1) in
    let CLK_ENABLE = W_CONST 1 ((rd_clk_enable = "1") => 1 | 0) in
    let common_leaves = [
	O_RD_CLK   <: RD_CLK,
	ACTIVE <- (rd_clk_enable = "0"   => W_CONST 1 1 |
		   rd_clk_polarity = "1" => '~' O_RD_CLK '&' RD_CLK |
					    O_RD_CLK '&' '~' RD_CLK),
	C1   <- ARST,
	C2   <- SRST '&' ACTIVE '&' (RD_EN '|' NOT_CE_OVER_SRST),
	C3   <- CLK_ENABLE,
	C4   <- CLK_ENABLE '&' RD_EN '&' ACTIVE,
	OTMP <: M1,
	DOUT <- OTMP,
        M1   <- (W_ITE C1 (sval2wexpr rd_arst_value) M2),
        M2   <- (W_ITE C2 (sval2wexpr rd_srst_value) M3),
        M3   <- (W_ITE C3 M4 NRES),
        M4   <- (W_ITE C4 M5 ORES),
        NRES <- (W_MEM_READ mem_info NEW_M RD_ADDR),
        ORES <- (W_MEM_READ mem_info OLD_M RD_ADDR)
    ] in
    let wr_clk_enable_l        = explode wr_clk_enables in
    let wr_clk_polarity_l      = explode wr_clk_polarities in
    let rd_transparency_mask_l = explode rd_transparency_masks in
    let rd_collision_x_mask_l  = explode rd_collision_x_masks in
    let wparams = wr_ports = [] => [] |
		  zip4 wr_clk_enable_l
		       wr_clk_polarity_l
		       rd_transparency_mask_l
		       rd_collision_x_mask_l
    in
    letrec mk_bypass (wsig:wsigs) (wparam:wparams) (out,OUT) =
	val (wclk,waddr,wdin) = wsig in
	val (clk_enable, clk_polarity, trans_mask, coll_x_mask) = wparam in
        val (cur,CUR) = mk_vec width (sprintf "bp_%d" (length wsigs)) in
	val (ps, ints) = mk_bypass wsigs wparams (cur,CUR) in
	let p = prim_rw_bypass mem_info
			       clk_enable clk_polarity
			       trans_mask coll_x_mask
			       cur f_RD_ADDR wclk waddr wdin out
	in
	let ps' = p:ps in
	let ints' = cur:ints in
	(ps',ints')
     /\   mk_bypass [] [] (out,OUT) = [OUT <- ORES], []
    in
    val (bypass_leaves, bypass_ints) = mk_bypass wr_ports wparams (f_M5,M5) in
    let leaves = common_leaves @ bypass_leaves in
    //
    let wr_inps_fa =
	let get_ports (wclk,waddr,wdin) = 
	    [(wclk,[wclk]), (waddr,[waddr]), (wdin,[wdin])]
	in
	flatmap get_ports wr_ports
    in
    let fa_inps = [(f_OLD_M, [old_M]), (f_NEW_M, [new_M]),
		   (f_ARST, [arst]), (f_SRST, [srst]),
		   (f_RD_CLK, [rd_clk]), (f_RD_EN, [rd_en]),
		   (f_RD_ADDR, [rd_addr])] @ wr_inps_fa
    in
    let fa_outs = [(f_DOUT, [dout])] in
    let ints    = [f_O_RD_CLK, f_ACTIVE, f_C1, f_C2, f_C3, f_C4, f_OTMP,
		   f_M1, f_M2, f_M3, f_M4, f_M5, f_NRES, f_ORES]@bypass_ints
    in
    let pfn     = "draw_hier prim_mem_rd_port" in
    PINST pfn attrs F fa_inps fa_outs ints (P_HIER leaves)
;

let mk_mem_name mem_info base =
    val (MEM abits lines width) = mem_info in
    sprintf "%s[%d:0][%d:0]" base (lines-1) (width-1)
;

let mk_write_ports mem_info wsigs wparams out =
    val (MEM abits lines width) = mem_info in
    letrec mk_wport (wsig:wsigs) (wparam:wparams) out =
	val (w_clk,w_en,w_addr,w_din) = wsig in
	val (clk_enable, clk_polarity) = wparam in
	let cur = mk_mem_name mem_info (sprintf "mid_%d" (length wsigs)) in
	let m_wdata = mk_name width (sprintf "mwd_%d" (length wsigs)) in
	val (ps, ints, mwds) = mk_wport wsigs wparams [cur] in
	let p = prim_mem_write mem_info clk_enable clk_polarity
			       [w_clk] [cur] [w_addr] [w_din] [w_en]
			       out [m_wdata]
	in
	let ps' = p:ps in
	let ints' = cur:ints in
	let mwds' = m_wdata:mwds in
	(ps',ints', mwds')
     /\   mk_wport [] [] out = [], [], []
    in
    mk_wport wsigs wparams [out]
;

let splitn sz s =
    s = "" => [] |
    (map implode (cluster sz (butfirstn 2 (explode s))))
    gen_catch (\msg.
	eprintf "splitn %d |%s| failed\n%s\n" sz s msg)
;
let splitv sz n =
    let merge l = hd (md_merge_vectors l) in
    map merge (cluster sz (md_expand_vector n))
;

let _mem_v2 src mem wr_ports rd_ports lines width abits params
	    rd_clk rd_en rd_arst rd_srst rd_addr rd_data
	    wr_clk wr_en wr_addr wr_data
	    init
    =
    (wr_ports == 0 OR (init = []) => () |
	    printf "WANRING: Initial values only supported for ROMs. Ignored")
    fseq
    let attrs = mk_attr src __FILE__ __LINE__ then
    let mem_info = MEM abits lines width then
    //
    //
    let get_param key = (assoc key params) catch "" then
    let RD_CLK_ENABLE        = get_param "RD_CLK_ENABLE" then
    let RD_CLK_POLARITY      = get_param "RD_CLK_POLARITY" then
    let RD_TRANSPARENCY_MASK = get_param "RD_TRANSPARENCY_MASK" then
    let RD_COLLISION_X_MASK  = get_param "RD_COLLISION_X_MASK" then
    let RD_CE_OVER_SRST      = get_param "RD_CE_OVER_SRST" then
    let RD_INIT_VALUE        = get_param "RD_INIT_VALUE" then
    let RD_ARST_VALUE        = get_param "RD_ARST_VALUE" then
    let RD_SRST_VALUE        = get_param "RD_SRST_VALUE" then
    let WR_CLK_ENABLE        = get_param "WR_CLK_ENABLE" then
    let WR_CLK_POLARITY      = get_param "WR_CLK_POLARITY" then
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // WHAT TO DO WITH THESE?????
    let WR_WIDE_CONTINUATION = get_param "WR_WIDE_CONTINUATION" then
    let WR_PRIORITY_MASK     = get_param "WR_PRIORITY_MASK" then
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    //
    let f_RD_CLK  = mk_name rd_ports "RD_CLK" then
    let f_RD_EN   = mk_name rd_ports "RD_EN" then
    let f_RD_ARST = mk_name rd_ports "RD_ARST" then
    let f_RD_SRST = mk_name rd_ports "RD_SRST" then
    let f_RD_ADDR = mk_name (rd_ports * abits) "RD_ADDR" then
    let f_RD_DATA = mk_name (rd_ports * width) "RD_DATA" then
    let f_WR_CLK  = mk_name wr_ports "WR_CLK" then
    let f_WR_EN   = mk_name (wr_ports*width) "WR_EN" then
    let f_WR_ADDR = mk_name (wr_ports*abits) "WR_ADDR" then
    let f_WR_DATA = mk_name (wr_ports*width) "WR_DATA" then
    let fa_inps   = [
		    (f_RD_CLK, rd_clk),
		    (f_RD_EN, rd_en),
		    (f_RD_ARST, rd_arst),
		    (f_RD_SRST, rd_srst),
		    (f_RD_ADDR, rd_addr)
		    ] @
		    (wr_ports = 0 => [] |
		    [
		    (f_WR_CLK, wr_clk),
		    (f_WR_EN, wr_en),
		    (f_WR_ADDR, wr_addr),
		    (f_WR_DATA, wr_data) ])
    then
    let fa_outs = [(f_RD_DATA, rd_data)] then
    val (f_OLD_MEM,OLD_MEM) = mk_mem mem_info mem then
    val (f_NEW_MEM,NEW_MEM) = mk_mem mem_info ("new_"^mem) then
    // Writing part
    val (write_pexlifs, write_internals, masked_wdatas) =
	wr_ports = 0 =>
	    // ROM
	    let pfn = sprintf "draw_hier ROM" then
	    let mk_asignment row v =
		let LHS =
		    let name = sprintf "new_%s[%d][%d:0]" mem row (width-1) then
		    W_EXPLICIT_VAR width name
		then
		let RHS = W_CONST width (sscanf "%b" v) then
		LHS <- RHS
	    then
	    let leaves = map2 mk_asignment (0 upto (length init -1 )) init then
	    let ints = [] then
	    let fa_inps = [] then
	    let fa_outs = [(f_NEW_MEM, [f_NEW_MEM])] then
	    ([PINST pfn attrs F fa_inps fa_outs ints (P_HIER leaves)], [], [])
	|
	    // RAM
	    let wports =
		let w_clks = splitv 1 f_WR_CLK then
		let w_ens  = splitv width f_WR_EN then
		let w_addrs = splitv abits f_WR_ADDR then
		let w_dins = splitv width f_WR_DATA then
		zip4 w_clks w_ens w_addrs w_dins
	    then
	    let wparams =
		let clk_enables = splitn 1 WR_CLK_ENABLE then
		let clk_polarities = splitn 1 WR_CLK_POLARITY then
		zip clk_enables clk_polarities
	    then
	    mk_write_ports mem_info wports wparams f_NEW_MEM
    then
    // Memory storage part
    let mem_pexlifs = [OLD_MEM <: NEW_MEM] then
    // Read ports
    let read_pexlifs =
	let wrports =
	    wr_ports = 0 => [] |
	    let w_clks = splitv 1 f_WR_CLK then
	    let w_addrs = splitv abits f_WR_ADDR then
	    let w_dins = masked_wdatas then
	    zip3 w_clks w_addrs w_dins
	then
	// Parameters
	let rd_clk_enable_l        = splitn 1 RD_CLK_ENABLE then
	let rd_clk_polarity_l      = splitn 1 RD_CLK_POLARITY then
	let rd_arst_value_l        = splitn width RD_ARST_VALUE then
	let rd_srst_value_l        = splitn width RD_SRST_VALUE then
	let rd_ce_over_srst_l      = splitn 1 RD_CE_OVER_SRST then
	let wr_clk_enable_l        = splitn 1 WR_CLK_ENABLE then
	let wr_clk_polarity_l      = splitn 1 WR_CLK_POLARITY then
	let rd_transparency_mask_l = splitn wr_ports RD_TRANSPARENCY_MASK then
	let rd_collision_x_mask_l  = splitn wr_ports RD_COLLISION_X_MASK then
	// Signals
	let rd_clk_l  = splitv 1 f_RD_CLK then
	let rd_en_l   = splitv 1 f_RD_EN then
	let arst_l    = splitv 1 f_RD_ARST then
	let srst_l    = splitv 1 f_RD_SRST then
	let rd_addr_l = splitv abits f_RD_ADDR then
	let dout_l    = splitv width f_RD_DATA then
	//
	let mk_rd_port idx =
		// Parameters for this read port
		let rd_clk_enable = el idx rd_clk_enable_l then
		let rd_clk_polarity = el idx rd_clk_polarity_l then
		let rd_arst_value = el idx rd_arst_value_l then
		let rd_srst_value = el idx rd_srst_value_l then
		let rd_ce_over_srst = el idx rd_ce_over_srst_l then
		let wr_clk_enables =
		    wr_ports = 0 => "0" | implode wr_clk_enable_l
		then
		let wr_clk_polarity = 
		    wr_ports = 0 => "0" | implode wr_clk_polarity_l
		then
		let rd_transparency_masks =
		    wr_ports = 0 => "0" | el idx rd_transparency_mask_l
		then
		let rd_collision_x_masks =
		    wr_ports = 0 => "0" | el idx rd_collision_x_mask_l
		then
		// Signals for this read port
		let arst = el idx arst_l then
		let srst = el idx srst_l then
		let rd_clk = el idx rd_clk_l then
		let rd_en = el idx rd_en_l then
		let rd_addr = el idx rd_addr_l then
		let dout = el idx dout_l then
		// Instantiate readport module
		prim_mem_rd_port mem_info
			    rd_clk_enable rd_clk_polarity
			    rd_arst_value rd_srst_value
			    rd_ce_over_srst
			    wr_clk_enables wr_clk_polarity
			    rd_transparency_masks rd_collision_x_masks
			    // Signals
			    f_OLD_MEM f_NEW_MEM
			    arst srst
			    rd_clk rd_en rd_addr
			    wrports
			    dout
	in
	map mk_rd_port (1 upto rd_ports)
    then
    //
    let leaves = write_pexlifs @ mem_pexlifs @ read_pexlifs then
    let ints = f_OLD_MEM:f_NEW_MEM:(write_internals@masked_wdatas) then
    let pfn = sprintf "draw_hier _mem_v2" then
    PINST pfn attrs F fa_inps fa_outs ints (P_HIER leaves)
;




// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
let _adff p_clk p_arst rst_value sz src q arst clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let ARST	  = mk_ifc_signal fa_inps_r 1 "ARST" arst then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let d_del	  = W_PHASE_DELAY dD D then
    let y_del	  = W_PHASE_DELAY dQ Q then
    let ZERO	  =
	rst_value = "" => W_CONST sz 0 | W_CONST sz (sscanf "%b" rst_value)
    then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK
			   | W_AND dCLK (W_NOT CLK)
    then
    let rst_cond  = p_arst => ARST | W_NOT ARST then
    let mux	  = W_UPDATE_FN Q
		    (W_ITE rst_cond ZERO (W_ITE clk_cond dD dQ))
    then
    let subs	   = P_LEAF [clk_del, d_del, y_del, mux] then
    let pfn = sprintf "draw_adff %s %s"
		      (p_clk  => "1" | "0")
		      (p_arst => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _adffe p_clk p_en p_arst rst_value sz src q arst en clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let ARST	  = mk_ifc_signal fa_inps_r 1 "ARST" arst then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let EN	  = mk_ifc_signal fa_inps_r 1 "EN" en then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dEN	  = mk_int_signal ints_r 1 "EN_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let en_del	  = W_PHASE_DELAY dEN EN then
    let d_del	  = W_PHASE_DELAY dD D then
    let y_del	  = W_PHASE_DELAY dQ Q then
    let ZERO	  =
	rst_value = "" => W_CONST sz 0 | W_CONST sz (sscanf "%b" rst_value)
    then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK
			   | W_AND dCLK (W_NOT CLK)
    then
    let en_cond   = p_en  => dEN | W_NOT dEN then
    let rst_cond  = p_arst => ARST | W_NOT ARST then
    let mux	  = W_UPDATE_FN Q
		    (W_ITE rst_cond ZERO (W_ITE (W_AND en_cond clk_cond) dD dQ))
    then
    let subs	   = P_LEAF [clk_del, en_del, d_del, y_del, mux] then
    let pfn = sprintf "draw_adffe %s %s %s"
		      (p_clk  => "1" | "0")
		      (p_en   => "1" | "0")
		      (p_arst => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _dffe p_clk p_en sz src q en clk d = 
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let EN	  = mk_ifc_signal fa_inps_r 1 "EN" en then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dEN	  = mk_int_signal ints_r 1 "EN_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let en_del	  = W_PHASE_DELAY dEN EN then
    let d_del	  = W_PHASE_DELAY dD D then
    let y_del	  = W_PHASE_DELAY dQ Q then
    let ZERO	  = W_CONST sz 0 then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK
			   | W_AND dCLK (W_NOT CLK)
    then
    let en_cond   = p_en  => dEN | W_NOT dEN then
    let mux	  = W_UPDATE_FN Q
			(W_ITE (W_AND en_cond clk_cond) dD dQ) then
    let subs	   = P_LEAF [clk_del, d_del, en_del, y_del, mux] then
    let pfn = sprintf "draw_dffe %s %s"
		      (p_clk  => "1" | "0")
		      (p_en   => "1" | "0")
    then
    PINST pfn attrs T (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _sdff p_clk p_srst rst_value sz src q srst clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let SRST	  = mk_ifc_signal fa_inps_r 1 "SRST" srst then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let dSRST	  = mk_int_signal ints_r 1 "SRST_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let d_del	  = W_PHASE_DELAY dD D then
    let y_del	  = W_PHASE_DELAY dQ Q then
    let srst_del  = W_PHASE_DELAY dSRST SRST then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK | W_AND dCLK (W_NOT CLK) then
    let srst_cond = p_srst => dSRST | W_NOT dSRST then
    let ZERO	  =
	rst_value = "" => W_CONST sz 0 | W_CONST sz (sscanf "%b" rst_value)
    then
    let mux	  = W_UPDATE_FN Q
			(W_ITE clk_cond 
			    (W_ITE srst_cond ZERO dD) dQ) then
    let subs	   = P_LEAF [clk_del, d_del, y_del, srst_del, mux] then
    let pfn = sprintf "draw_sdff %s %s"
		      (p_clk  => "1" | "0")
		      (p_srst   => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _sdffe p_clk p_en p_srst rst_value sz src q srst en clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let SRST	  = mk_ifc_signal fa_inps_r 1 "SRST" srst then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let EN	  = mk_ifc_signal fa_inps_r 1 "EN" en then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dEN	  = mk_int_signal ints_r 1 "EN_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let dSRST	  = mk_int_signal ints_r 1 "SRST_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let en_del	  = W_PHASE_DELAY dEN EN then
    let d_del	  = W_PHASE_DELAY dD D then
    let q_del	  = W_PHASE_DELAY dQ Q then
    let srst_del  = W_PHASE_DELAY dSRST SRST then
    let ZERO	  =
	rst_value = "" => W_CONST sz 0 | W_CONST sz (sscanf "%b" rst_value)
    then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK | W_AND dCLK (W_NOT CLK) then
    let en_cond   = p_en => dEN | W_NOT dEN then
    let srst_cond = p_srst => dSRST | W_NOT dSRST then
    let mux	  = W_UPDATE_FN Q
			(W_ITE clk_cond 
			       (W_ITE srst_cond ZERO
					    (W_ITE en_cond dD dQ)) dQ) then
    let subs	   = P_LEAF [clk_del, d_del, en_del, q_del, srst_del, mux] then
    let pfn = sprintf "draw_sdffe %s %s %s"
		      (p_clk  => "1" | "0")
		      (p_en   => "1" | "0")
		      (p_srst => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _sdffce p_clk p_en p_srst rst_value sz src q srst en clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let SRST	  = mk_ifc_signal fa_inps_r 1 "SRST" srst then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let EN	  = mk_ifc_signal fa_inps_r 1 "EN" en then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dEN	  = mk_int_signal ints_r 1 "EN_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let dSRST	  = mk_int_signal ints_r 1 "SRST_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let en_del	  = W_PHASE_DELAY dEN EN then
    let d_del	  = W_PHASE_DELAY dD D then
    let q_del	  = W_PHASE_DELAY dQ Q then
    let srst_del  = W_PHASE_DELAY dSRST SRST then
    let ZERO	  =
	rst_value = "" => W_CONST sz 0 | W_CONST sz (sscanf "%b" rst_value)
    then
    let clk_cond  = p_clk => W_AND (W_NOT dCLK) CLK
			   | W_AND dCLK (W_NOT CLK)
    then
    let en_cond   = p_en => dEN | W_NOT dEN then
    let srst_cond = p_srst => dSRST | W_NOT dSRST then
    let mux	  = W_UPDATE_FN Q
			(W_ITE (W_AND en_cond clk_cond) 
			       (W_ITE srst_cond ZERO dD) dQ) then
    let subs	   = P_LEAF [clk_del, d_del, en_del, q_del, srst_del, mux] then
    let pfn = sprintf "draw_sdffce %s %s %s"
		      (p_clk  => "1" | "0")
		      (p_en   => "1" | "0")
		      (p_srst => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _dffsre p_clk p_set p_clr p_en sz src q clr set en clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let CLR	  = mk_ifc_signal fa_inps_r sz "CLR" clr then
    let SET	  = mk_ifc_signal fa_inps_r sz "SET" set then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let EN	  = mk_ifc_signal fa_inps_r 1 "EN" en then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dEN	  = mk_int_signal ints_r 1 "EN_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let dCLR	  = mk_int_signal ints_r sz "CLR_##_" then
    let dSET	  = mk_int_signal ints_r sz "SET_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let en_del	  = W_PHASE_DELAY dEN EN then
    let d_del	  = W_PHASE_DELAY dD D then
    let q_del	  = W_PHASE_DELAY dQ Q then
    let clr_del   = W_PHASE_DELAY dCLR CLR then
    let set_del   = W_PHASE_DELAY dSET SET then
    let ZERO	  = W_CONST sz 0 then
    let ONE	  = W_CONST sz (2**sz-1) then
    let clk_cond  = p_clk=> W_AND (W_NOT dCLK) CLK | W_AND dCLK (W_NOT CLK) then
    let en_cond   = p_en => dEN | W_NOT dEN then
    let clr_cond  = p_clr=> W_AND (W_NOT dCLR) CLR | W_AND dCLR (W_NOT CLR) then
    let set_cond  = p_set=> W_AND (W_NOT dSET) SET | W_AND dSET (W_NOT SET) then
    let mux	  = W_UPDATE_FN Q
			(W_AND (W_NOT clr_cond)
			       (W_OR set_cond 
				    (W_ITE (W_AND en_cond clk_cond) dD dQ)))
    then 
    let subs	  = P_LEAF [clk_del,d_del,en_del,q_del,clr_del,set_del,mux] then
    let pfn = sprintf "draw_dffsre %s %s %s %s"
		      (p_clk  => "1" | "0")
		      (p_clr => "1" | "0")
		      (p_set => "1" | "0")
		      (p_en   => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

let _dffsr p_clk p_set p_clr sz src q clr set clk d =
    let attrs = mk_attr src __FILE__ __LINE__ then
    let fa_inps_r = ref [] then
    let fa_outs_r = ref [] then
    let ints_r    = ref [] then
    let Q	  = mk_ifc_signal fa_outs_r sz "Q" q then
    let CLR	  = mk_ifc_signal fa_inps_r sz "CLR" clr then
    let SET	  = mk_ifc_signal fa_inps_r sz "SET" set then
    let CLK	  = mk_ifc_signal fa_inps_r 1 "CLK" clk then
    let D	  = mk_ifc_signal fa_inps_r sz "D" d then
    let dQ	  = mk_int_signal ints_r sz "Q_##_" then
    let dCLK	  = mk_int_signal ints_r 1 "CLK_##_" then
    let dD	  = mk_int_signal ints_r sz "D_##_" then
    let dCLR	  = mk_int_signal ints_r sz "CLR_##_" then
    let dSET	  = mk_int_signal ints_r sz "SET_##_" then
    let clk_del	  = W_PHASE_DELAY dCLK CLK then
    let d_del	  = W_PHASE_DELAY dD D then
    let q_del	  = W_PHASE_DELAY dQ Q then
    let clr_del   = W_PHASE_DELAY dCLR CLR then
    let set_del   = W_PHASE_DELAY dSET SET then
    let ZERO	  = W_CONST sz 0 then
    let ONE	  = W_CONST sz (2**sz-1) then
    let clk_cond  = p_clk=> W_AND (W_NOT dCLK) CLK | W_AND dCLK (W_NOT CLK) then
    let clr_cond  = p_clr=> W_AND (W_NOT dCLR) CLR | W_AND dCLR (W_NOT CLR) then
    let set_cond  = p_set=> W_AND (W_NOT dSET) SET | W_AND dSET (W_NOT SET) then
    let mux	  = W_UPDATE_FN Q
			(W_AND (W_NOT clr_cond)
			       (W_OR set_cond 
				    (W_ITE clk_cond dD dQ)))
    then 
    let subs	  = P_LEAF [clk_del,d_del,q_del,clr_del,set_del,mux] then
    let pfn = sprintf "draw_dffsr %s %s %s"
		      (p_clk  => "1" | "0")
		      (p_clr => "1" | "0")
		      (p_set => "1" | "0")
    then
    PINST pfn attrs T
	    (deref fa_inps_r) (deref fa_outs_r) (deref ints_r) subs
;

end_abstype  _mem_v2 _adff _adffe _dffe _sdff _sdffe _sdffce _dffsre _dffsr;
