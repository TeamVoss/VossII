//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

let is_number str =
    let non_digit s = 
	let v = ord s then
	(v < ord "0") OR (v > ord "9")
    in
    (find_first0 non_digit (explode str)) = 0
;

let bs_isv vec v =
    let nds = md_expand_vector vec in
    let sz = length nds in
    let vs = (
	let s2l s = map (\s. (s = "1") => bT | bF) (explode s) in
	str_is_prefix "0x" v =>
	    s2l (sprintf "%0*b" sz (sscanf "0x%x" v))
	|
	str_is_prefix "0b" v =>
	    s2l (sprintf "%0*b" sz (sscanf "0b%b" v))
	|
	is_number v =>
	    s2l (sprintf "%0*b" sz (sscanf "%d" v))
	|
	(sz = 1) AND (v = "T") => [bT] |
	(sz = 1) AND (v = "F") => [bF] |
	let ss = md_expand_vector v then
	length ss != sz => error "nope" |
	map bvariable ss
    ) catch 
	eprintf "Length mismatch in isv (|%s| != |%s|)" vec v
    in
    map2 (\n.\v. (bT,n,v,0,1)) nds vs
;

let bb_isv vec value_list =
    let nds = md_expand_vector vec in
    let sz = length nds in
    length value_list != sz =>
	eprintf "Length mismatch in isv for %s\n" vec
    |
    map2 (\n.\v. (bT,n,{v::bexpr},0,1)) nds value_list
;

let bbv_isv vec bv =
    let nds = md_expand_vector vec in
    let sz = length nds in
    let vl = map (bexpr2bdd []) (bv2list bv) in
    let szl = length vl in
    szl > sz => eprintf "bv larger than fits in %s" vec |
    let value_list = (replicate (sz-szl) (hd vl))@vl in
    map2 (\n.\v. (bT,n,{v::bexpr},0,1)) nds value_list
;

let s_isv vec v =
    let nds = md_expand_vector vec in
    let sz = length nds in
    let vs = (
	let s2l s = map (\s. s = "1") (explode s) in
	str_is_prefix "0x" v =>
	    s2l (sprintf "%0*b" sz (sscanf "0x%x" v))
	|
	str_is_prefix "0b" v =>
	    s2l (sprintf "%0*b" sz (sscanf "0b%b" v))
	|
	is_number v =>
	    s2l (sprintf "%0*b" sz (sscanf "%d" v))
	|
	(sz = 1) AND (v = "T") => [T] |
	(sz = 1) AND (v = "F") => [F] |
	let ss = md_expand_vector v then
	length ss != sz => error "nope" |
	map variable ss
    ) catch 
	eprintf "Length mismatch in isv (|%s| != |%s|)" vec v
    in
    map2 (\n.\v. (T,n,v,0,1)) nds vs
;

let b_isv vec value_list =
    let nds = md_expand_vector vec in
    let sz = length nds in
    length value_list != sz =>
	eprintf "Length mismatch in isv for %s\n" vec
    |
    map2 (\n.\v. (T,n,{v::bool},0,1)) nds value_list
;

let bv_isv vec bv =
    let nds = md_expand_vector vec in
    let sz = length nds in
    let vl = bv2list bv in
    let szl = length vl in
    szl > sz => eprintf "bv larger than fits in %s" vec |
    let value_list = (replicate (sz-szl) (hd vl))@vl in
    map2 (\n.\v. (T,n,{v::bool},0,1)) nds value_list
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// There are several versions, but you basically say:
// vector_name isv value.
// Vector_name is simply the name of the vector/node as a string.
// Value can be several things:
//	A constant, e.g., "0", "1", "0b1001", "0x3fa8", etc.
//	A variable name, e.g., "d", "c[3:0]", "m[3:0][7:0]", etc.
//	A list of bools, e.g., [F,T,T], [F,T, variable "b"]. etc.
//	A list of bexprs, e.g., [bF,bT,bT], [bF,bT, bvariable "b"]. etc.
//	A bv, e.g., (bv_constrained_variable "a[3:0]" (\v. v > '0 AND v < '10)
//
// Depending on the usage, it can either generate (bool#string#bool#int#int)
// tuple lists or (bexpr#string#bexpr#int#int) lists.
//
overload isv bs_isv bb_isv bbv_isv s_isv b_isv bv_isv;
infix 4 isv;

let bdd_from {l::(bool#string#bool#int#int) list} f =
    map (\(w,n,v,_,t). (w,n,v,f,t)) l
;

let bexpr_from {l::(bexpr#string#bexpr#int#int) list} f =
    map (\(w,n,v,_,t). (w,n,v,f,t)) l
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// This function sets all the "from" time values to t.
// Usage:    five_tuple_list from t;
overload from bdd_from bexpr_from;
infix 4 from;

let bdd_to {l::(bool#string#bool#int#int) list} t =
    map (\(w,n,v,f,_). (w,n,v,f,t)) l
;

let bexpr_to {l::(bexpr#string#bexpr#int#int) list} t =
    map (\(w,n,v,f,_). (w,n,v,f,t)) l
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// This function sets all the "to" time values to t.
// Usage:    five_tuple_list to t;
overload to bdd_to bexpr_to;
infix 3 to;

let bdd_and {ant1::(bool#string#bool#int#int) list} ant2 =
    ant1 @ ant2
;

let bexpr_and {ant1::(bexpr#string#bexpr#int#int) list} ant2 =
    ant1 @ ant2
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// This function catenates two five-tuple lists of the same type.
overload and bdd_and bexpr_and;
infix 1 and;

let bdd_when {ant::(bool#string#bool#int#int) list} {cond::bool} =
    map (\(w,n,v,f,t). (cond AND w),n,v,f,t) ant
;

let bexpr_when {ant::(bexpr#string#bexpr#int#int) list} {cond::bexpr} =
    map (\(w,n,v,f,t). (cond bAND w),n,v,f,t) ant
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// This function conjucts the condition cond into every five-tuple.
// Usage:  five_tuple_list when cond;
overload when bdd_when bexpr_when;
infix 2 when;

let gen_clock clk_signal cycles =
    map (\i. (T,{clk_signal::string}, ((i%2)=1),i, i+1)) (0 upto (2*cycles))
;


let bdd_is_clock nd cycles = map (\i. T, nd, (i%2=0), i, i+1) (0--(2*cycles-1));

let bexpr_is_clock nd cycles =
    map (\i. bT, nd, ((i%2=0)=>bT|bF), i, i+1) (0--(2*cycles-1))
;

// A simple interface for defining 5-tuple lists for (b)STE runs.
// Define a node nd to be a clock and generate cycs cycles of values.
// Usage: nd is_clock cycs;
overload is_clock bdd_is_clock bexpr_is_clock;
infix 2 is_clock;


let phase cnt = cnt;
postfix phase;

let phases cnt = cnt;
postfix phases;

let cycles cnt = 2*cnt;
postfix cycles;

let cycle cnt = 2*cnt;
postfix cycle;

lettype values =  STR_VAL   {v::string}
		| INT_VAL   {i::int}
		| BV_VAL    {v::bv}
		| BL_VAL    {v:: bool list}
		| WEXPR_VAL     {e::wexpr}
;


let s_in_phase v ph = [(T,STR_VAL v,ph,ph+1)];
let i_in_phase v ph = [(T,INT_VAL v,ph,ph+1)];
let bv_in_phase v ph = [(T,BV_VAL v,ph,ph+1)];
let bool_in_phase v ph = [(T,BL_VAL [v],ph,ph+1)];
let bl_in_phase v ph = [(T,BL_VAL v,ph,ph+1)];
let w_in_phase v ph = [(T,WEXPR_VAL (hw_destr v), ph, ph+1)];
overload in_phase s_in_phase i_in_phase bv_in_phase bool_in_phase
		  bl_in_phase w_in_phase
;
infix 6 in_phase;

let s_in_cycle v cyc    = [(T,STR_VAL v,2*cyc,2*cyc+2)];
let i_in_cycle v cyc    = [(T,INT_VAL v,2*cyc,2*cyc+2)];
let bv_in_cycle v cyc   = [(T,BV_VAL v,2*cyc,2*cyc+2)];
let bool_in_cycle v cyc = [(T,BL_VAL [v],2*cyc,2*cyc+2)];
let bl_in_cycle v cyc   = [(T,BL_VAL v,2*cyc,2*cyc+2)];
let w_in_cycle v cyc    = [(T,WEXPR_VAL (hw_destr v), 2*cyc, 2*cyc+2)];
overload in_cycle s_in_cycle i_in_cycle bv_in_cycle bool_in_cycle
			     bl_in_cycle w_in_cycle
;
infix 6 in_cycle;

// Keep???
//let at_phase v ph = [(T,v,ph,ph)];
//infix 6 at_phase;
//
//let at_cycle v cyc = [(T,v,2*cyc,2*cyc)];
//infix 6 at_cycle;

let sfor1 {v::string} {cnt::int} = [(F,STR_VAL v,0,cnt)];
let sfor2 [({fixed::bool},{v::string},{start::int},{end::int})] cnt =
    [(fixed, STR_VAL v, start, start+cnt)]
;
let ifor1 {i::int} {cnt::int} = [(F,INT_VAL i,0,cnt)];
let ifor2 [({fixed::bool},{i::int},{start::int},{end::int})] cnt =
    [(fixed, INT_VAL i, start, start+cnt)]
;
let bvfor1 {v::bv} {cnt::int} = [(F,BV_VAL v,0,cnt)];
let bvfor2 [({fixed::bool},{v::bv},{start::int},{end::int})] cnt =
    [(fixed, BV_VAL v, start, start+cnt)]
;
let boolfor1 {v::bool} {cnt::int} = [(F,BL_VAL [v], 0, cnt)];
let boolfor2 [({fixed::bool},{v::bool},{start::int},{end::int})] cnt =
    [(fixed, BL_VAL [v], start, start+cnt)]
;
let blfor1 {v::bool list} {cnt::int} = [(F,BL_VAL v,0,cnt)];
let blfor2 [({fixed::bool},{v::bool list},{start::int},{end::int})] cnt =
    [(fixed, BL_VAL v, start, start+cnt)]
;

let wfor1 v {cnt::int} = [(F,WEXPR_VAL (hw_destr v),0,cnt)];
let wfor2 [({fixed::bool},v,{start::int},{end::int})] cnt =
    [(fixed, WEXPR_VAL (hw_destr v), start, start+cnt)]
;


overload for sfor1 sfor2
	     ifor1 ifor2
	     bvfor1 bvfor2
	     boolfor1 boolfor2
	     blfor1 blfor2
	     wfor1 wfor2
;
infix 5 for;

let followed_by vtl1 vtl2 =
    let M = itlist (\(fixed, v,f,t).\m. max m t) vtl1 0 in
    let move tpl =
	val (fixed,v,f,t) = tpl in
	fixed => tpl |
	(fixed, v, f+M, t+M)
    in 
    vtl1 @ (map move vtl2)
;
infix 4 followed_by;

let gen_otherwise vt (v,end) =
    let is_def (fx,v,f,t) = f upto (t-1) in
    let defined = qsort (defix -) (setify (flatmap is_def vt)) then
    letrec add_default cur (t:ts) =
	cur+1 >= t => add_default (t+1) ts |
	(T, v, cur, t):(add_default (t+1) ts)
     /\    add_default cur [] = 
	cur+1 < end => [(T,v,cur,end)] | []
    in
    vt@(add_default 0 defined)
;

let s_otherwise vt (v,end)    = gen_otherwise vt (STR_VAL v, end);
let i_otherwise vt (v,end)    = gen_otherwise vt (INT_VAL v, end);
let bv_otherwise vt (v,end)   = gen_otherwise vt (BV_VAL v, end);
let bool_otherwise vt (v,end) = gen_otherwise vt (BL_VAL [v], end);
let bl_otherwise vt (v,end)   = gen_otherwise vt (BL_VAL v, end);
let w_otherwise vt (v,end)    = gen_otherwise vt (WEXPR_VAL (hw_destr v), end);
overload otherwise s_otherwise
		   i_otherwise
		   bv_otherwise
		   bool_otherwise
		   bl_otherwise
		   w_otherwise
;
infix 3 otherwise;

let until v cyc = (v,cyc);
infix 4 until;

let base_is nds vtlist =
    let nds = md_expand_vectors nds in
    let vec = list2str T "" "," "" id (md_merge_vectors nds) in
    let sz = length nds in
    let cnv (fixed, (STR_VAL v), f , t) =
	let vs = (
	    let s2l s = map (\s. s = "1") (explode s) in
	    str_is_prefix "0x" v =>
		s2l (sprintf "%0*b" sz (sscanf "0x%x" v))
	    |
	    str_is_prefix "0b" v =>
		s2l (sprintf "%0*b" sz (sscanf "0b%b" v))
	    |
	    is_number v =>
		s2l (sprintf "%0*b" sz (sscanf "%d" v))
	    |
	    (sz = 1) AND (v = "T") => [T] |
	    (sz = 1) AND (v = "F") => [F] |
	    let ss = md_expand_vector v then
	    length ss != sz => error "nope" |
	    map variable ss
	) catch
	    eprintf "Length mismatch in is (|%s| != |%s|)" vec v
	in
	map2 (\n.\v. (T,n,v,f,t)) nds vs
     /\ cnv (fixed, (INT_VAL i), f, t) =
	i < (-1*2**(sz-1)) =>
	    eprintf "Integer %d too small to fit %s" i vec
	| 
	i > (2**sz-1) =>
	    eprintf "Integer %d too large to fit %s" i vec
	| 
	let s = sprintf "%0*b" sz i in
	let vs = map (\s. s = "1") (explode s) in
	map2 (\n.\v. (T,n,v,f,t)) nds vs
     /\ cnv (fixed, (BV_VAL bv), f, t) =
	bv_size bv > sz =>
	    eprintf "Length mismatch in is (|%s| != |%s|)" vec (bv2str 3 bv)
	|
	let vs = fixed_bv2list sz F bv in
	map2 (\n.\v. (T,n,v,f,t)) nds vs
     /\ cnv (fixed, (BL_VAL vs), f, t) =
	length vs != sz =>
	    eprintf "Length mismatch in is (|%s| != length of list = %d)"
		    vec (length vs)
	|
	map2 (\n.\v. (T,n,v,f,t)) nds vs
     /\ cnv (fixed, (WEXPR_VAL e), f, t) =
	sz != wexpr_size e =>
	    eprintf "Length mismatch in is (|%s| != |%s|)" vec (Pwexpr e)
	|
	let vs  = wexpr2bool e in
	map2 (\n.\v. (T,n,v,f,t)) nds vs
    in
    flatmap cnv vtlist
;

let s_is vec vtlist = base_is [vec] vtlist;

let hw_is v vtlist = base_is (base_get_lhs_vars (hw_destr v)) vtlist;

overload is s_is hw_is;
infix 2 is;

let bool_ant {l::(bool#string#bool#int#int) list} = l;
let bexpr_ant {l::(bexpr#string#bexpr#int#int) list} = l;
