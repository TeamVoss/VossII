//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

lettype *a hw_type =
    HW_TYPE
      {hw_type_name:: *a -> string}
      {hw_mk_var:: *a -> string -> wexpr}
      {hw_is_arithmetic:: *a -> bool}
      {hw_size:: *a -> int}
      {hw_destr:: *a -> wexpr}
      {hw_constr:: wexpr -> *a}
      {hw_values:: *a -> string}
      {hw_bundle_parts:: *a -> (((string#string) list)#((string#string) list))}
;

open_overload {hw_type_destr :: ({*a} hw_type)};

// Make sure there are at least two possibilities for the open overloaded
// functions.
lettype dummy1 = DUMMY1;
let {dummy1_hw_type_destr :: {dummy1} hw_type} = error "dummy1";
lettype dummy2 = DUMMY2;
let {dummy2_hw_type_destr :: {dummy2} hw_type} = error "dummy2";
add_open_overload hw_type_destr dummy1_hw_type_destr dummy2_hw_type_destr;

let hw_constr w =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    {hw_constr w:: *a}
;

let hw_type_name {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_type_name o
;


let hw_mk_var {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_mk_var o
;

let hw_is_arithmetic {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_is_arithmetic o
;

let hw_size {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_size o
;

let hw_destr {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_destr o
;

let hw_values {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_values o
;

let hw_bundle_pairs {o:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts)
	= {hw_type_destr:: {*a} hw_type}
    in
    hw_bparts o
;


let hw_types_decl_ref = ref {[]::(string#int) list};

let is_hw_type name = mem name (map fst (deref hw_types_decl_ref));

let get_hw_type_size name =
    assoc name (deref hw_types_decl_ref)
;
non_lazy get_hw_type_size;

let bundle2field bundle field = bundle^"'"^field;

let get_bundle_var e =
    let we = hw_destr e in
    let get_var (W_VAR sz nm) = nm
    /\  get_var other = eprintf "Non-variable bundle (%s)" (Pwexpr we)
    in
    get_var we
; 

let CELL {name::string} {body::pexlif list} =
    (PINST name [] F [] [] [] (P_HIER body))
;

let ileq {i::int} {j::int} = i <= j;


// Convert a positive integer to a hw type, or X, or variable.
// E.g., if byte as an 8-bit hw type (TYPE "byte" 8;), then
//	{'10::byte};
//	{'0xa::byte};
//	{'0b1010::byte};
// all create a byte with bits 00001010.
//	{'X::byte}
// creates a byte with 8 Xs (undefined/unknown/don't cares)
//	{'a::byte}
// creates a byte with 8 symbolic variables named a[7] downto a[0].
//
let make_const_or_var s =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*r} hw_type}
    in
    let sz = hw_size {undefined:: *r} in
    let w =
	str_is_prefix "0x" s =>
	    let i = sscanf "0x%x" s in
	    W_CONST sz i
	|
	str_is_prefix "0b" s =>
	    let i = sscanf "0b%b" s in
	    W_CONST sz i
	|
	let s0 = string_hd s in
	let os = ord s0 in
	(ileq (ord "0") os) AND (ileq os (ord "9")) =>
	    let i = sscanf "%d" s in
	    W_CONST sz i
	|
	s == "X" => W_X sz | hw_mk_var {undefined :: *r} s
    in
    {hw_constr w:: *r}
;
nonfix ';
overload ' s2float s2int s2bev s2bv  make_const_or_var;
free_binder ';

// Convert a negative integer to a hw type.
let neg_make_const_or_var s =
    let o = {undefined:: *r} in
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*r} hw_type}
    in
    let sz = hw_size {undefined:: *r} in
    let w =
	str_is_prefix "0x" s =>
	    let i = sscanf "0x%x" s in
	    W_CONST sz (i_mul (i_minus 0 1) i)
	|
	str_is_prefix "0b" s =>
	    let i = sscanf "0b%b" s in
	    W_CONST sz (i_mul (i_minus 0 1) i)
	|
	let s0 = string_hd s in
	let os = ord s0 in
	(ileq (ord "0") os) AND (ileq os (ord "9")) =>
	    let i = sscanf "%d" s in
	    W_CONST sz (i_mul (i_minus 0 1) i)
	|
	s == "X" => W_X sz | eprintf "'- not defined for variables (%s)" s
    in
    {hw_constr w:: *r}
;
nonfix '-;
overload '- '- neg_make_const_or_var;
free_binder '-;

let compact_wprint rhs =
    let inps = get_wbase_names rhs then
    base_compact_wprint inps rhs
;

let dest_XOR (W_OR (W_AND (W_NOT a) b) (W_AND c (W_NOT d))) = [a,b]
 /\ dest_XOR (W_OR (W_AND a (W_NOT b)) (W_AND (W_NOT c) d)) = [a,b]
;

let dest_LEQ (W_NOT (W_GR a b)) = [a,b];


let is_wide_OR e  =
    letrec cnt (W_OR a b) = 1 + cnt a + cnt b
     /\    cnt other = 0
    in
    (cnt e) >= 2
;

let is_wide_AND e  =
    letrec cnt (W_AND a b) = 1 + cnt a + cnt b
     /\    cnt other = 0
    in
    (cnt e) >= 2
;

(cload (DIR^"/simplify.fl")) fseq ();

let get_cases e =
    letrec get_all_choices conds (W_ITE c t e) =
	    conds != [] =>
		let cond = hd conds in
		(get_all_choices [(W_AND cond c)] t)@
		(get_all_choices [(W_AND cond (W_NOT c))] e)
	    |
		(get_all_choices [c] t)@(get_all_choices [W_NOT c] e)
     /\    get_all_choices conds other = [(hd conds, other)]
    in
    let cases = get_all_choices [] e then
    let p = partition snd cases then
    let mk l =
	let res = snd (hd l) in
	let cond = accumulate (defix W_OR) (map fst l) then
	(cond,res)
    in
    map mk p
;

let is_case (W_ITE c (W_ITE c2 _ _) _) = T
 /\ is_case (W_ITE c _ (W_ITE c2 _ _)) = T
 /\ is_case other = F
;


let append_label lbl ps =
    let add1 (PINST name attrs lf fa_inps fa_outs ints body) =
	val (lbl_attrs, other) = split (\(an,av). an = "Label") attrs then
	let attrs' =
	    (lbl_attrs = []) => ("Label", lbl):other |
	    let cur_lbl = snd (hd lbl_attrs) in
	    let new_lbl = sprintf "%s/%s" cur_lbl lbl in
	    ("Label", new_lbl):other
	in
	(PINST name attrs' lf fa_inps fa_outs ints body)
    in
    map add1 ps
;

forward_declare {w_CASE :: wexpr ->
			   ((wexpr#wexpr) list) ->
			   wexpr ->
			   pexlif};

// Make a PINST from lhs/rhs wexpr in which we use anonymous names for the
// internal signals (so all same leaves will have identical SHA signatures)
let mk_pinst opt_pfn {lhs::wexpr} {rhs::wexpr} =
    let dep_vars = (w_depends rhs) in
    let nsub =
	let mk_sub n i =
	    let anon = mk_name (special_md_sizes [n]) (sprintf "i%d" i) in
	    (n,anon)
	in
	map2 mk_sub dep_vars (1 upto (length dep_vars))
    then
    let wsub =
	let mk_sub n i =
	    let anon = mk_name (special_md_sizes [n]) (sprintf "i%d" i) in
	    (n,anon)
	in
	map2 mk_sub dep_vars (1 upto (length dep_vars))
    then
    let inps = map (\(a,f).(f,[a])) nsub in
    let driven = base_get_lhs_vars lhs in
    let sz = special_md_sizes driven in
    let lhs' = W_VAR sz "o" in
    let outs = [(mk_name sz "o", driven)] in
    let rhs' = w_substitute wsub rhs then
    let body = P_LEAF [W_UPDATE_FN lhs' rhs'] then
    let pfn = has_value opt_pfn => get_value opt_pfn | mk_draw_cmd F rhs then
    PINST pfn [] T inps outs [] body
;

let base_assignment do_split lhs rhs =
    let l_sz = wexpr_size lhs in
    let r_sz = wexpr_size rhs in
    l_sz != r_sz =>
	eprintf "Size mismatch in update function\n%d=|%s|\n%d=|%s|)"
		l_sz (Pwexpr lhs) r_sz (Pwexpr rhs)
    |
    NOT (valid_lhs lhs) =>
	eprintf "%s is not a valid lhs expression" (Pwexpr lhs)
    |
    let rhs = const_prop rhs in
    NOT do_split => mk_pinst NONE lhs rhs |
    //
    let id_cnt_ref = ref 1 then
    let internals = ref [] then
    let mk_tmp sz =
	let cnt = deref id_cnt_ref then
	(id_cnt_ref := cnt+1) fseq
	let v = sz = 1 => sprintf "%s%d" BASE_TMP cnt
			| sprintf "%s%d[%d:0]" BASE_TMP cnt (sz-1)
	then
	(internals := v:(deref internals)) fseq
	W_VAR sz (sprintf "%s%d" BASE_TMP cnt)
    in
    letrec split lhs (W_ADD (W_CONST sz v) a) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_ADD (W_CONST sz v) a') then
	    p1@[p]
     /\    split lhs (W_ADD a (W_CONST sz v)) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_ADD a' (W_CONST sz v)) then
	    p1@[p]
     /\    split lhs (W_SUB a (W_CONST sz v)) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_SUB a' (W_CONST sz v)) then
	    p1@[p]
     /\    split lhs (W_EQ a (W_CONST sz v)) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_EQ a' (W_CONST sz v)) then
	    p1@[p]
     /\    split lhs (W_NOT (W_EQ a (W_CONST sz v))) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_NOT (W_EQ a' (W_CONST sz v))) then
	    p1@[p]
     /\    split lhs (W_GR a (W_CONST sz v)) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_GR a' (W_CONST sz v)) then
	    p1@[p]
     /\    split lhs (W_GR (W_CONST sz v) a) assuming (v < 10)  =
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_GR (W_CONST sz v) a') then
	    p1@[p]
     /\    split lhs op assuming (is_wide_OR op) =
		letrec split_OR (W_OR a b) = split_OR a @ split_OR b
		 /\    split_OR other = [other]
		in
		let raw_as = split_OR op then
		let mk1 a =
		    is_var a => (a,[]) |
		    let mid = mk_tmp (wexpr_size a) then
		    let p1 = split mid a then
		    (mid, p1)
		in
		val (as, pl) = unzip (map mk1 raw_as) then
		let ps = flat pl then
		let p =
		    let rhs = accumulate W_OR as in
		    let dep_vars = md_extract_vectors (w_depends rhs) in
		    let n = length dep_vars in
		    let pfn = sprintf "draw_explicit_or_n %d" n in
		    mk_pinst (SOME pfn) lhs rhs
		in
		p:ps
     /\    split lhs (W_NOT op) assuming (is_wide_OR op) =
		letrec split_OR (W_OR a b) = split_OR a @ split_OR b
		 /\    split_OR other = [other]
		in
		let raw_as = split_OR op then
		let mk1 a =
		    is_var a => (a,[]) |
		    let mid = mk_tmp (wexpr_size a) then
		    let p1 = split mid a then
		    (mid, p1)
		in
		val (as, pl) = unzip (map mk1 raw_as) then
		let ps = flat pl then
		let p =
		    let rhs = W_NOT (accumulate W_OR as) in
		    let dep_vars = md_extract_vectors (w_depends rhs) in
		    let n = length dep_vars in
		    let pfn = sprintf "draw_explicit_nor_n %d" n in
		    mk_pinst (SOME pfn) lhs rhs
		in
		p:ps
     /\    split lhs op assuming (is_wide_AND op) =
		letrec split_AND (W_AND a b) = split_AND a @ split_AND b
		 /\    split_AND other = [other]
		in
		let raw_as = split_AND op then
		let mk1 a =
		    is_var a => (a,[]) |
		    let mid = mk_tmp (wexpr_size a) then
		    let p1 = split mid a then
		    (mid, p1)
		in
		val (as, pl) = unzip (map mk1 raw_as) then
		let ps = flat pl then
		let p =
		    let rhs = accumulate W_AND as in
		    let dep_vars = md_extract_vectors (w_depends rhs) in
		    let n = length dep_vars in
		    let pfn = sprintf "draw_explicit_and_n %d" n in
		    mk_pinst (SOME pfn) lhs rhs
		in
		p:ps
     /\    split lhs (W_NOT op) assuming (is_wide_AND op) =
		letrec split_AND (W_AND a b) = split_AND a @ split_AND b
		 /\    split_AND other = [other]
		in
		let raw_as = split_AND op then
		let mk1 a =
		    is_var a => (a,[]) |
		    let mid = mk_tmp (wexpr_size a) then
		    let p1 = split mid a then
		    (mid, p1)
		in
		val (as, pl) = unzip (map mk1 raw_as) then
		let ps = flat pl then
		let p =
		    let rhs = W_NOT (accumulate W_AND as) in
		    let dep_vars = md_extract_vectors (w_depends rhs) in
		    let n = length dep_vars in
		    let pfn = sprintf "draw_explicit_nand_n %d" n in
		    mk_pinst (SOME pfn) lhs rhs
		in
		p:ps
     /\    split lhs op assuming (is_LEQ op) =
	    val [a,b] = dest_LEQ op in
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    val (b',p2) = is_var b => (b,[]) |
		let mid = mk_tmp (wexpr_size b) then
		let p1 = split mid b then
		(mid, p1)
	    in
	    let op' = W_NOT (W_GR a' b') in
	    let p = mk_pinst NONE lhs op' then
	    p1@p2@[p]
     /\    split lhs op assuming (is_XOR op) =
	    val [a,b] = dest_XOR op in
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    val (b',p2) = is_var b => (b,[]) |
		let mid = mk_tmp (wexpr_size b) then
		let p1 = split mid b then
		(mid, p1)
	    in
	    let op' = W_OR (W_AND (W_NOT a') b') (W_AND a' (W_NOT b')) in
	    let p = mk_pinst NONE lhs op' then
	    p1@p2@[p]
     /\    split lhs op assuming (is_binary op) =
	    val (constr, a, b) = split_binary op then
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    val (b',p2) = is_var b => (b,[]) |
		let mid = mk_tmp (wexpr_size b) then
		let p1 = split mid b then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (constr a' b') then
	    p1@p2@[p]
     /\    split lhs e assuming (is_case e) =
	    let raw_cases = get_cases e then
	    let p_cases = butlastn 1 raw_cases then
	    let c_default = snd (last raw_cases) then
	    let mk_cond (c,e) =
		val (c',p0) = is_var c => (c,[]) |
			      let mid = mk_tmp (wexpr_size c) then
			      let p0 = split mid c then
			      (mid, p0)
		then
		val (e',p1) = is_var e => (e,[]) |
			      let mid = mk_tmp (wexpr_size e) then
			      let p1 = split mid e then
			      (mid, p1)
		then
		((append_label "Ctrl" p0)@p1), (c',e')
	    in
	    let c_cases = map mk_cond p_cases then
	    let ps = flatmap fst c_cases then
	    let cases = map snd c_cases then
	    val (default,pd) = is_var c_default => (c_default,[]) |
			      let mid = mk_tmp (wexpr_size c_default) then
			      let p0 = split mid c_default then
			      (mid, p0)
	    then
	    let p = w_CASE lhs cases default then
	    pd@[p]@ps
     /\    split lhs (W_ITE c a b) =
	    val (c',p0) = is_var c => (c,[]) |
		let mid = mk_tmp (wexpr_size c) then
		let p0 = split mid c then
		(mid, p0)
	    in
	    val (a',p1) = is_var a => (a,[]) |
		let mid = mk_tmp (wexpr_size a) then
		let p1 = split mid a then
		(mid, p1)
	    in
	    val (b',p2) = is_var b => (b,[]) |
		let mid = mk_tmp (wexpr_size b) then
		let p1 = split mid b then
		(mid, p1)
	    in
	    let p = mk_pinst NONE lhs (W_ITE c' a' b') then
	    p0@p1@p2@[p]
     /\    split lhs (W_SX sz e) =
	    val (e',p0) = is_var e => (e,[]) |
		let mid = mk_tmp (wexpr_size e) then
		let p0 = split mid e then
		(mid, p0)
	    in
	    let p = mk_pinst NONE lhs (W_SX sz e') in
	    p0@[p]
     /\    split lhs (W_ZX sz e) =
	    val (e',p0) = is_var e => (e,[]) |
		let mid = mk_tmp (wexpr_size e) then
		let p0 = split mid e then
		(mid, p0)
	    in
	    let p = mk_pinst NONE lhs (W_ZX sz e') in
	    p0@[p]
     /\    split lhs (W_SLICE indices e) =
	    val (e',p0) = is_var e => (e,[]) |
		let mid = mk_tmp (wexpr_size e) then
		let p0 = split mid e then
		(mid, p0)
	    in
	    let p = mk_pinst NONE lhs (W_SLICE indices e') in
	    p0@[p]
     /\    split lhs (W_NAMED_SLICE name indices e) =
	    val (e',p0) = is_var e => (e,[]) |
		let mid = mk_tmp (wexpr_size e) then
		let p0 = split mid e then
		(mid, p0)
	    in
	    let p = mk_pinst NONE lhs (W_NAMED_SLICE name indices e') in
	    p0@[p]
     /\    split lhs (W_UPDATE_NAMED_SLICE b name indices n) =
	    val (b',p1) = is_simple_var b => (b,[]) |
		let mid = mk_tmp (wexpr_size b) then
		let p1 = split mid b then
		(mid, p1)
	    in
	    val (n',p2) = is_simple_var n => (n,[]) |
		let mid = mk_tmp (wexpr_size n) then
		let p2 = split mid n then
		(mid, p2)
	    in
	    let p = mk_pinst NONE lhs (W_UPDATE_NAMED_SLICE b' name indices n') then
	    p1@p2@[p]
     /\    split lhs rhs = [mk_pinst NONE lhs rhs]
    in
    let subfubs = split lhs rhs then
    length subfubs = 1 => hd subfubs |
    let outs = map (\n.n,[n]) (get_lhs_vars lhs) in
    let inps = map (\n.n,[n]) (w_depends rhs) in
    let dep_vars = get_wbase_names rhs then
    let pfn = "_WrApPeR_" then
    PINST pfn [] F inps outs (deref internals) (P_HIER subfubs)
;

let w_CASE w_out cond_res_list w_default_value =
    let sz = wexpr_size w_default_value then
    let n = length cond_res_list then
//    n = 1 =>
//	val (c,t) = hd cond_res_list in
//	let e = w_default_value in
//	let base = base_assignment T w_out (W_ITE c t e) in
//	resize_pexlif sz base
//    |
    let n_out = hd (w_depends w_out) then
    let fa_outs = [(n_out,[n_out])] then
    let var2name (W_VAR s b) = [mk_name s b]
     /\ var2name (W_EXPLICIT_VAR s b) = [b]
     /\ var2name other = []
    in
    letrec select cnt ((c,r):rem) =
        let bc = sprintf "%sc%02d" BASE_TMP cnt then
        let br = sprintf "%sr%02d" BASE_TMP cnt then
        let lc = W_VAR 1 bc then
        let lr = W_VAR sz br then
        val (c_ints, c_act, c_extra) =
	    let v = var2name c then
	    v = [] =>
		let en = mk_name 1 bc then
		let p = base_assignment T lc c then
		([en], en, [p])
	    |
	    ([], hd v, [])
        in
        val (r_ints, r_act, r_extra) =
	    let v = var2name r then
	    v = [] =>
		let en = mk_name sz br then
		let p = base_assignment T lr r then
		([en], en, [p])
	    |
	    ([], hd v, [])
        in
        val (fas, e, ints, extras) = select (cnt+1) rem then
        let fas = (mk_name 1 bc, [c_act]):(mk_name sz br, [r_act]):fas then
        let e = W_ITE lc lr e then
        let ints = c_ints@r_ints@ints then
        let extras = c_extra@r_extra@extras then
        (fas, e, ints, extras)
     /\    select cnt [] =
        let bd = sprintf "%sd%02d" BASE_TMP cnt then
        let ld = W_VAR sz bd then
        val (d_ints, d_act, d_extra) =
	    let v = var2name w_default_value then
	    v = [] =>
		let en = mk_name sz bd then
		let p = base_assignment T ld w_default_value then
		([en], en, [p])
	    |
	    ([], hd v, [])
        in
	let fas = [(mk_name sz bd, [d_act])] in
	(fas, ld, d_ints, d_extra)
    in
    val (fas, rhs, ints, extras) = select 1 cond_res_list then
    let body = base_assignment F w_out rhs then
    let pfn = sprintf "draw_CASE %d" n then
    let mux = PINST pfn [] T fas fa_outs [] (P_HIER [body]) then
    let children = mux:extras then
    let get_acts (PINST _ _ _ ifa _ _ _) = flatmap snd ifa then
    let inps = (setify (flatmap get_acts children)) subtract ints then
    let fa_inps = map (\v.v,[v]) inps then
    PINST "_WrApPeR_" [] F fa_inps fa_outs ints (P_HIER children)
;



// Create a combinational "circuit" in which the outputs L are assigned
// the values computed by the expression R.
// E.g.,
//	foo <- a '&' b
//	bar-->valid <- req `&` done '|' old_req
let <- {L:: *a} {R:: *a} =
    let lhs = hw_destr {L:: *a} in
    let rhs = hw_destr {R:: *a} in
    base_assignment T lhs rhs
;
infixr 0 <-;

let <<-- L R =
    let lhs = hw_destr {L:: *a} in
    let rhs = hw_destr {R:: *a} in
    base_assignment F lhs rhs
;
infixr 0 <<--;

let base_phase_delay lhs rhs =
    let l_sz = wexpr_size lhs in
    let r_sz = wexpr_size rhs in
    l_sz != r_sz =>
	eprintf "Size mismatch in phase delay\n%d=|%s|\n%d=|%s|)"
		l_sz (Pwexpr lhs) r_sz (Pwexpr rhs)
    |
    NOT (valid_lhs lhs) =>
	eprintf "%s is not a valid lhs expression" (Pwexpr lhs)
    |
    let body = P_LEAF [W_PHASE_DELAY lhs rhs ] in
    let outs = map (\n.n,[n]) (get_lhs_vars lhs) in
    let inps = map (\n.n,[n]) (w_depends rhs) in
    PINST (mk_draw_cmd T rhs) [] T inps outs [] body
;

// Create a phase delay "circuit" in which the outputs L are assigned
// the values computed by the expression R delayed by one phase.
// E.g.,
//	foo <- a '&' b
//	bar-->valid <- req `&` done '|' old_req
let <: L R =
    let lhs = hw_destr {L:: *a} in
    let rhs = hw_destr {R:: *a} in
    base_phase_delay lhs rhs
;
infix 1 <:;



let anon_arg_cnt = ref 0;


let get_act_args fn a =
    (
	let we = hw_destr a in
	let res = base_get_lhs_vars we then
	([], res)
    ) catch (
	let cnt = deref anon_arg_cnt then
	(anon_arg_cnt := (i_plus cnt 1)) fseq
	let nm = sprintf "%s%d_%s" BASE_TMP cnt fn then
	let tmp = hw_mk_var a nm then
	let we = hw_destr a in
	let asignm = base_assignment T tmp we then
	let vs = get_lhs_vars tmp then
	([asignm], vs)
    )
;

let mk_wrap_inps tmps pexlifs =
    let get_ainps (PINST _ _ _ inps _ _ _) = flatmap snd inps in
    let all_ainps = extract_vectors (flatmap get_ainps pexlifs) in
    let rel_ainps = all_ainps subtract tmps in
    map (\v.v,[v]) rel_ainps
;

let mk_wrap_outs pexlifs =
    let get_aouts (PINST _ _ _ _ outs _ _) = flatmap snd outs in
    let all_aouts = extract_vectors (flatmap get_aouts pexlifs) in
    map (\v.v,[v]) all_aouts
;

let get_tmp_outs pexlifs =
    let get_aouts (PINST _ _ _ _ outs _ _) = flatmap snd outs in
    let all_aouts = extract_vectors (flatmap get_aouts pexlifs) in
    all_aouts
;

let is_bundle a =
    val (left_signals, right_signals) = hw_bundle_pairs a in
    (left_signals != []) OR (right_signals != [])
;

// Declare inputs to a unit.
// Example:
//	input a b c.
//	    ...
let input body_fun {fs::string} acc =
        \{aa:: *a}.
	    is_bundle aa =>
		val (lefts,rights) = hw_bundle_pairs aa in
		let as = get_bundle_var aa in
                let wf = hw_mk_var aa fs in
                let f = {hw_constr wf:: *a} in
		let mk (n,t) =
		    let fn = mk_name (get_hw_type_size t) (bundle2field fs n) in
		    let an = mk_name (get_hw_type_size t) (bundle2field as n) in
		    (fn, [an])
		in
		let new_inps = map mk lefts in
		let new_outs = map mk rights in
		let acc' name bd =
		    let p0 = acc name bd in
		    val (PINST n attrs leaf inps outs ints body) = p0 in
		    let attrs' = attrs in
		    let inps_n = inps@new_inps in
		    let outs_n = outs@new_outs in
		    PINST n attrs' leaf inps_n outs_n ints body
		in
		body_fun f acc'
	    |
            let a = hw_destr aa in
            let sz = hw_size aa in
            let wf = hw_mk_var aa fs in
            let f = {hw_constr wf:: *a} in
            val (expr_pexlifs,av) = get_act_args fs aa in
            let fv = hd (get_lhs_vars wf) in
	    let values = hw_values {undefined :: *a} in
            let acc' name bd =
		let p0 = acc name bd in
                val (PINST n attrs leaf inps outs ints body) = p0 in
		val (p_main, p_exprs) =
		    n = "_WrApPeR_" =>
			val (P_HIER pexlifs) = body in
			// Get the main pexlif
			val (PINST n' attrs' leaf' inps' outs' ints' body') =
			    el 1 pexlifs
			in
			let prev_expr_pexlifs = tl pexlifs in
			let attrs'' =
			    values = "" => attrs' |
			    (sprintf "node_values_%s" fv, values):attrs'
			in
			let inps'' = inps'@[(fv,av)] in
			let p_main' =
			    PINST n' attrs'' leaf' inps'' outs' ints' body'
			in
			(p_main', (prev_expr_pexlifs@expr_pexlifs))
		    |
		    let attrs' =
			values = "" => attrs |
			(sprintf "node_values_%s" fv, values):attrs
		    in
		    let inps_n = inps@[(fv,av)] in
		    mem fv ints =>
			eprintf "Node %s declared both input and internal" fv
		    |
		    mem fv (map fst outs) =>
			eprintf "Node %s declared both input and output" fv
		    |
		    let p_main' = PINST n attrs' leaf inps_n outs ints body in
		    (p_main', expr_pexlifs)
		in
		p_exprs = [] => p_main |
		let c_ints = get_tmp_outs p_exprs in
		let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
		let c_outs = mk_wrap_outs [p_main] in
		let res = PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
			    (P_HIER (p_main:p_exprs)) in
		res
            in
            body_fun f acc'
;
binder_with_accumulator input CELL;

// Declare list inputs to a unit.
// Example:
//	list_input al bl.
//	    ...
let list_input body_fun {base_fs::string} acc =
        \{aa:: (*a list)}.
	    is_bundle (hd aa) =>
		val (lefts,rights) = hw_bundle_pairs (hd aa) in
		let as = map get_bundle_var aa in
		let fs =
		    map (sprintf "%s[%d]" base_fs) ((length aa-1) downto 0)
		in
                let wf = map (hw_mk_var (hd aa)) fs in
                let f = map hw_constr wf in
		let mkl fs as =
		    let mk (n,t) =
			let fn =
			    mk_name (get_hw_type_size t) (bundle2field fs n)
			in
			let an =
			    mk_name (get_hw_type_size t) (bundle2field as n)
			in
			(fn, [an])
		    in
		    let new_inps = map mk lefts in
		    let new_outs = map mk rights in
		    (new_inps, new_outs)
		in
		val (new_inps_l, new_outs_l) = unzip (map2 mkl fs as) in
		let new_inps = flat new_inps_l in
		let new_outs = flat new_outs_l in
		let acc' name bd =
		    let p0 = acc name bd in
		    val (PINST n attrs leaf inps outs ints body) = p0 in
		    let attrs' = attrs in
		    let inps_n = inps@new_inps in
		    let outs_n = outs@new_outs in
		    PINST n attrs' leaf inps_n outs_n ints body
		in
		body_fun {f:: *a list} acc'
	    |
            let a = map hw_destr {aa:: *a list} in
            let fs = map (sprintf "%s[%d]" base_fs) ((length aa-1) downto 0) in
	    let sz = hw_size {undefined:: *a} in
            let wfs = map (hw_mk_var {undefined:: *a}) fs in
            let f = map hw_constr wfs in
	    val (expr_pexlifs,avs) =
		unzip (map (\(fs,aa). get_act_args fs aa) (zip fs aa))
	    in
            let fv = map (\wf. hd (get_lhs_vars wf)) wfs in
            let acc' name bd =
		let p0 = acc name bd in
                val (PINST n attrs leaf inps outs ints body) = p0 in
		let fv1 = hd (md_merge_vectors fv) in
                let new_inps = aa = [] => []
					| [(fv1, (md_merge_vectors (flat avs)))]
		in
		val (p_main, p_exprs) =
		    n = "_WrApPeR_" =>
			val (P_HIER pexlifs) = body in
			// Get the main pexlif
			val (PINST n' attrs' leaf' inps' outs' ints' body') =
			    el 1 pexlifs
			in
			let prev_expr_pexlifs = tl pexlifs in
			let inps'' = inps'@new_inps in
			let p_main' =
			    PINST n' attrs' leaf' inps'' outs' ints' body'
			in
			(p_main', (prev_expr_pexlifs@(flat expr_pexlifs)))
		    |
		    let inps_n = inps@new_inps in
		    (aa != []) AND (mem fv1 ints) =>
			eprintf "Node %s declared both input and internal" fv1
		    |
		    (aa != []) AND (mem fv1 (map fst outs)) =>
			eprintf "Node %s declared both input and output" fv1
		    |
		    let p_main' = PINST n attrs leaf inps_n outs ints body in
		    (p_main', flat expr_pexlifs)
		in
		p_exprs = [] => p_main |
		let c_ints = get_tmp_outs p_exprs in
		let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
		let c_outs = mk_wrap_outs [p_main] in
		let res = PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
			    (P_HIER (p_main:p_exprs)) in
		res
            in
            body_fun {f:: *a list} acc'
;
binder_with_accumulator list_input CELL;


// Declare outputs to a unit.
// Example:
//	output a b c.
//	    ...
let output body_fun {fs::string} acc =
        \{aa:: *a}.
            is_bundle aa =>
                val (lefts,rights) = hw_bundle_pairs aa in
		let as = get_bundle_var aa in
                let wf = hw_mk_var aa fs in
                let f = {hw_constr wf:: *a} in
                let mk (n,t) =
                    let fn = mk_name (get_hw_type_size t) (bundle2field fs n) in
                    let an = mk_name (get_hw_type_size t) (bundle2field as n) in
		    (fn, [an])
                in
                let new_inps = map mk rights in
                let new_outs = map mk lefts in
                let acc' name bd =
                    let p0 = acc name bd in 
                    val (PINST n attrs leaf inps outs ints body) = p0 in
                    let attrs' = attrs in
                    let inps_n = inps@new_inps in
                    let outs_n = outs@new_outs in
                    PINST n attrs' leaf inps_n outs_n ints body
                in  
                body_fun f acc'
            |
            let a = hw_destr aa in
            let sz = hw_size aa in
            let wf = hw_mk_var aa fs in
            let f = {hw_constr wf:: *a} in
            let av = get_lhs_vars a in
            let fv = hd (get_lhs_vars wf) in
	    let values = hw_values {undefined :: *a} in
            let acc' name bd =
		let p0 = acc name bd in
                val (PINST n attrs leaf inps outs ints body) = p0 in
		val (p_main, p_exprs) =
		    n = "_WrApPeR_" =>
			val (P_HIER pexlifs) = body in
			// Get the main pexlif
			val (PINST n' attrs' leaf' inps' outs' ints' body') =
			    el 1 pexlifs
			in
			let prev_expr_pexlifs = tl pexlifs in
			let outs'' = outs'@[(fv,av)] in
			let attrs'' =
			    values = "" => attrs' |
			    (sprintf "node_values_%s" fv, values):attrs'
			in
			let p_main' =
			    PINST n' attrs'' leaf' inps' outs'' ints' body'
			in
			(p_main', prev_expr_pexlifs)
		    |
		    let attrs' =
			values = "" => attrs |
			(sprintf "node_values_%s" fv, values):attrs
		    in
		    let outs_n = outs@[(fv,av)] in
		    mem fv ints =>
			eprintf "Node %s declared both output and internal" fv
		    |
		    mem fv (map fst inps) =>
			eprintf "Node %s declared both input and output" fv
		    |
		    let p_main' = PINST n attrs' leaf inps outs_n ints body in
		    (p_main', [])
		in
		p_exprs = [] => p_main |
		let c_ints = get_tmp_outs p_exprs in
		let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
		let c_outs = mk_wrap_outs [p_main] in
		let res = PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
			    (P_HIER (p_main:p_exprs)) in
		res
            in
            body_fun f acc'
;
binder_with_accumulator output CELL;

// Declare list outputs to a unit.
// Example:
//	list_output al bl.
//	    ...
let list_output body_fun {base_fs::string} acc =
        \{aa:: *a list}.
	    is_bundle (hd aa) =>
		val (lefts,rights) = hw_bundle_pairs (hd aa) in
		let as = map get_bundle_var aa in
		let fs =
		    map (sprintf "%s[%d]" base_fs) ((length aa-1) downto 0)
		in
                let wf = map (hw_mk_var (hd aa)) fs in
                let f = map hw_constr wf in
		let mkl fs as =
		    let mk (n,t) =
			let fn =
			    mk_name (get_hw_type_size t) (bundle2field fs n)
			in
			let an =
			    mk_name (get_hw_type_size t) (bundle2field as n)
			in
			(fn, [an])
		    in
		    let new_inps = map mk rights in
		    let new_outs = map mk lefts in
		    (new_inps, new_outs)
		in
		val (new_inps_l, new_outs_l) = unzip (map2 mkl fs as) in
		let new_inps = flat new_inps_l in
		let new_outs = flat new_outs_l in
		let acc' name bd =
		    let p0 = acc name bd in
		    val (PINST n attrs leaf inps outs ints body) = p0 in
		    let attrs' = attrs in
		    let inps_n = inps@new_inps in
		    let outs_n = outs@new_outs in
		    PINST n attrs' leaf inps_n outs_n ints body
		in
		body_fun {f:: *a list} acc'
	    |
            let a = map hw_destr {aa:: *a list} in
            let fs = map (sprintf "%s[%d]" base_fs) ((length aa-1) downto 0) in
	    let sz = hw_size {undefined:: *a} in
            let wfs = map (hw_mk_var {undefined:: *a}) fs in
            let f = map hw_constr wfs in
            let av = map get_lhs_vars a in
            let fv = map (\wf. hd (get_lhs_vars wf)) wfs in
            let acc' name bd =
		let p0 = acc name bd in
                val (PINST n attrs leaf inps outs ints body) = p0 in
		let fv1 = hd (md_merge_vectors fv) in
                let new_outs = aa = [] => []
					| [(fv1, (md_merge_vectors (flat av)))]
		in
		val (p_main, p_exprs) =
		    n = "_WrApPeR_" =>
			val (P_HIER pexlifs) = body in
			// Get the main pexlif
			val (PINST n' attrs' leaf' inps' outs' ints' body') =
			    el 1 pexlifs
			in
			let prev_expr_pexlifs = tl pexlifs in
			let outs'' = outs'@new_outs in
			let p_main' =
			    PINST n' attrs' leaf' inps' outs'' ints' body'
			in
			(p_main', prev_expr_pexlifs)
		    |
		    let outs_n = outs@new_outs in
		    (aa != []) AND (mem fv1 ints) =>
			eprintf "Node %s declared both output and internal" fv1
		    |
		    (aa != []) AND (mem fv1 (map fst inps)) =>
			eprintf "Node %s declared both input and output" fv1
		    |
		    let p_main' = PINST n attrs leaf inps outs_n ints body in
		    (p_main', [])
		in
		p_exprs = [] => p_main |
		let c_ints = get_tmp_outs p_exprs in
		let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
		let c_outs = mk_wrap_outs [p_main] in
		let res = PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
			    (P_HIER (p_main:p_exprs)) in
		res
            in
            body_fun {f:: *a list} acc'
;
binder_with_accumulator list_output CELL;

//
// Declare inout to a unit.
// Example:
//	inout a b c.
//	    ...
let inout body_fun {fs::string} acc =
        \{aa:: *a}.
            let a = hw_destr aa in
            let sz = hw_size aa in
            let wf = hw_mk_var aa fs in
            let f = {hw_constr wf:: *a} in
            let av = get_lhs_vars a in
            let fv = hd (get_lhs_vars wf) in
	    let values = hw_values {undefined :: *a} in
            let acc' name bd =
		let p0 = acc name bd in
                val (PINST n attrs leaf inps outs ints body) = p0 in
		val (p_main, p_exprs) =
		    n = "_WrApPeR_" =>
			val (P_HIER pexlifs) = body in
			// Get the main pexlif
			val (PINST n' attrs' leaf' inps' outs' ints' body') =
			    el 1 pexlifs
			in
			let prev_expr_pexlifs = tl pexlifs in
			let outs'' = outs'@[(fv,av)] in
			let attrs'' =
			    values = "" => attrs' |
			    (sprintf "node_values_%s" fv, values):attrs'
			in
			let p_main' =
			    PINST n' attrs'' leaf' inps' outs'' ints' body'
			in
			(p_main', prev_expr_pexlifs)
		    |
		    let attrs' =
			values = "" => attrs |
			(sprintf "node_values_%s" fv, values):attrs
		    in
		    let outs_n = outs@[(fv,av)] in
		    let p_main' = PINST n attrs' leaf inps outs_n ints body in
		    (p_main', [])
		in
		p_exprs = [] => p_main |
		let c_ints = get_tmp_outs p_exprs in
		let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
		let c_outs = mk_wrap_outs [p_main] in
		let res = PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
			    (P_HIER (p_main:p_exprs)) in
		res
            in
            body_fun f acc'
;
binder_with_accumulator inout CELL;

// Declare internal signals to a unit.
let internal body_fun {fs::string} acc =
    is_bundle {undefined :: *a} =>
	val (lefts,rights) = hw_bundle_pairs {undefined :: *a} in
	let mk (n,t) = mk_name (get_hw_type_size t) (bundle2field fs n) in
	let new_ints = map mk (lefts@rights) in
	let wf = hw_mk_var {undefined :: *a} fs in
	let f = {hw_constr wf:: *a} in
	let acc' name bd =
	    let p0 = acc name bd then
	    val (PINST n attrs leaf inps outs ints body) = p0 in
	    base_PINST n attrs leaf inps outs (ints@new_ints) body
	in
	body_fun {f:: *a} acc'
    |
    let sz = hw_size {undefined :: *a} in
    let wf = hw_mk_var {undefined :: *a} fs in
    let f = {hw_constr wf:: *a} in
    let fv = hd (get_lhs_vars wf) in
    let values = hw_values {undefined :: *a} in
    let acc' name bd =
	let p0 = acc name bd then
	val (PINST n attrs leaf inps outs ints body) = p0 in
	val (p_main, p_exprs) =
	    n = "_WrApPeR_" =>
		val (P_HIER pexlifs) = body in
		// Get the main pexlif
		val (PINST n' attrs' leaf' inps' outs' ints' body') =
		    el 1 pexlifs
		in
		let attrs'' =
		    values = "" => attrs' |
		    (sprintf "node_values_%s" fv, values):attrs'
		in
		let prev_expr_pexlifs = tl pexlifs in
		let ints'' = fv:ints' in
		let p_main' =
		    base_PINST n' attrs'' leaf' inps' outs' ints'' body'
		in
		(p_main', prev_expr_pexlifs)
	    |
	    let attrs' =
		values = "" => attrs |
		(sprintf "node_values_%s" fv, values):attrs
	    in
	    let p_main' =
		base_PINST n attrs' leaf inps outs (fv:ints) body
	    in
	    (p_main', [])
	in
	p_exprs = [] => p_main |
	let c_ints = get_tmp_outs p_exprs then
	let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) then
	let c_outs = mk_wrap_outs [p_main] then
	let res = base_PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
		    (P_HIER (p_main:p_exprs)) then
	res
    in
    body_fun {f:: *a} acc'
;
binder_with_accumulator internal CELL;

// Make an internal wire named by an expression
// Should be used in conjunction with add_internal.
// For example:
//	let foo = mk_internal (sprintf "_KeY_%s" name) in
//	add_internal foo (CELL .... );
//
let mk_internal name = make_const_or_var name;
//    let sz = hw_size {undefined:: *r} in
//    val w =
//	let nsz = md_size name in
//	sz = nsz => W_EXPLICIT_VAR sz name |
//	W_EXPLICIT_VAR sz (sprintf "%s[%d:0]" name (sz-1))
//    in
//    {hw_constr w:: *r}
;

// Add an internal wire created by mk_internal to the internals list in pexlif.
// See mk_internal for example of use.
let add_internal new_int cell =
    let w_int = hw_destr new_int in
    let new_ints = base_get_lhs_vars w_int in
    val (PINST nm attrs leaf inps outs ints body) = cell in
    PINST nm attrs leaf inps outs (new_ints@ints) body
;


// Declare internal array of signals to a unit.
let list_internal cnt body_fun {base_fs::string} acc =
    is_bundle {undefined :: *a} =>
	val (lefts,rights) = hw_bundle_pairs {undefined :: *a} in
	let fsl = map (sprintf "%s[%d]" base_fs) ((cnt-1) downto 0) in
	let wf = map (hw_mk_var {undefined :: *a}) fsl in
	let f = map hw_constr wf in
	let mkl fs =
	    let mk (n,t) = mk_name (get_hw_type_size t) (bundle2field fs n) in
	    map mk (lefts@rights)
	in
	let new_ints = flatmap mkl fsl in
	let acc' name bd =
	    let p0 = acc name bd then
	    val (PINST n attrs leaf inps outs ints body) = p0 in
	    base_PINST n attrs leaf inps outs (ints@new_ints) body
	in
	body_fun {f:: *a list} acc'
    |
    let fs = map (sprintf "%s[%d]" base_fs) ((cnt-1) downto 0) in
    let sz = hw_size {undefined :: *a} in
    let wfs = map (hw_mk_var {undefined :: *a}) fs in
    let f  = {map  hw_constr wfs:: *a list} in
    let fv = map (mk_name sz) fs in
    let values = hw_values {undefined :: *a} in
    let acc' name bd =
	let p0 = acc name bd in
	val (PINST n attrs leaf inps outs ints body) = p0 in
	val (p_main, p_exprs) =
	    n = "_WrApPeR_" =>
		val (P_HIER pexlifs) = body in
		// Get the main pexlif
		val (PINST n' attrs' leaf' inps' outs' ints' body') =
		    el 1 pexlifs
		in
		let attrs'' =
		    values = "" => attrs' |
		    (map (\f. (sprintf "node_values_%s" f), values) fv)@attrs'
		in
		let prev_expr_pexlifs = tl pexlifs in
		let ints'' = md_extract_vectors (fv@ints') in
		let p_main' =
		    base_PINST n' attrs'' leaf' inps' outs' ints'' body'
		in
		(p_main', prev_expr_pexlifs)
	    |
	    let attrs' =
		values = "" => attrs |
		(map (\f. (sprintf "node_values_%s" f), values) fv)@attrs
	    in
	    let p_main' =
		let ints' = md_extract_vectors (fv@ints) in
		base_PINST n attrs' leaf inps outs ints' body
	    in
	    (p_main', [])
	in
	p_exprs = [] => p_main |
	let c_ints = get_tmp_outs p_exprs in
	let c_inps = mk_wrap_inps c_ints (p_main:p_exprs) in
	let c_outs = mk_wrap_outs [p_main] in
	let res = base_PINST "_WrApPeR_" attrs F c_inps c_outs c_ints
		    (P_HIER (p_main:p_exprs)) in
	res
    in
    body_fun {f:: *a list} acc'
;
sized_binder_with_accumulator list_internal CELL;



let eval_fl_code l =
    let fp = mktemp "eval_fl_code" then
    let fname = stream2filename  fp then
    (map (fprintf fp "%s\n") l) fseq
    (fclose fp) fseq
    (_load fname F) fseq
    // Comment out the next line to ease debugging...
//    (system (sprintf "/bin/rm -f %s" fname)) fseq
    T
;
non_lazy eval_fl_code;

let core_TYPE name size is_arithmetic value_list =
    let current = deref hw_types_decl_ref in
    mem name (map fst current) =>
	(fprintf stderr "A hw type called %s is already defined\n" name)
	seq F
    |
    let new = (name,size):current in
    (hw_types_decl_ref := new) fseq
    let ssz = sprintf "%d" size in
    let sarithm = is_arithmetic => "T" | "F" in
    eval_fl_code
    <{
	lettype `name` = BV_`name` wexpr;
	//
	let hw_`name`_is_arithmetic {bv::`name`} = `sarithm`;
	let hw_`name`_mk_var {bv::`name`} base = W_VAR `ssz` base;
	let hw_`name`_values {bv::`name`} = "`value_list`";
	let hw_`name`_type_name {bv::`name`} = "`name`";
	let hw_`name`_size {bv::`name`} = `ssz`;
	let hw_`name`_constr w = BV_`name` w;
	let hw_`name`_destr (BV_`name` w) = w;
	let hw_`name`_bundle_parts {bv::`name`} = [],[];
	let {`name`_hw_type_destr:: {`name`} hw_type} =
	    HW_TYPE hw_`name`_type_name
		    hw_`name`_mk_var
		    hw_`name`_is_arithmetic
		    hw_`name`_size
		    hw_`name`_destr
		    hw_`name`_constr
		    hw_`name`_values
		    hw_`name`_bundle_parts
	;
	add_open_overload hw_type_destr `name`_hw_type_destr;
	let `name`_input body_fun {fs::string} acc {a::`name`} =
	    (defix input) body_fun fs acc a;
	let `name`_output body_fun {fs::string} acc {a::`name`} =
	    (defix output) body_fun fs acc a;
	let `name`_inout body_fun {fs::string} acc {a::`name`} =
	    (defix inout) body_fun fs acc a;
	let `name`_internal {body_fun:: `name`->(string-> *a -> pexlif)-> *b}
			    {fs::string} acc =
	    (defix internal) body_fun fs acc;
	let `name`_list_internal
		    {cnt::int}
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
		=
	    (defix list_internal) cnt  body_fun fs acc
	;
	let `name`_list_input
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
	    =
		(defix list_input) body_fun fs acc
	;
	let `name`_list_output
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
	    =
		(defix list_output) body_fun fs acc
	;
	binder_with_accumulator `name`_input CELL;
	binder_with_accumulator `name`_output CELL;
	binder_with_accumulator `name`_inout CELL;
	binder_with_accumulator `name`_internal CELL;
	sized_binder_with_accumulator `name`_list_internal CELL;
	binder_with_accumulator `name`_list_input CELL;
	binder_with_accumulator `name`_list_output CELL;
	let P_`name` t =
	    let we = hw_`name`_destr t then
	    NOT (wexpr_is_binary we) =>
		let pX (W_X sz) = sprintf "X[%d:0]" (sz-1)
		 /\\ pX other = "-"
		in
		pX we
	    |
	    let bits = wexpr2bool [] we then
	    let raw_res0 = map (sprintf "%B") bits in
	    let tr s = s = "F" => "0" | s = "T" => "1" | s in
	    let raw_res = map tr raw_res0 in
	    depends bits = [] =>
		sprintf "0x%x" (sscanf "%b" (implode raw_res))
	    |
	    let compressed = md_merge_vectors raw_res in
	    letrec merge cur cnt (c:cs) =
		    c = cur => merge cur (cnt+1) cs |
		    cnt = 1 => cur:(merge c 1 cs) |
		    cnt = 2 => cur:cur:(merge c 1 cs) |
		    cnt = 3 => cur:cur:cur:(merge c 1 cs) |
		    (sprintf "%s^%d" cur cnt):(merge c 1 cs)
	      /\\  merge cur cnt [] =
		    cnt = 1 => [cur] |
		    cnt = 2 => cur:cur:[] |
		    cnt = 3 => cur:cur:cur:[] |
		    [(sprintf "%s^%d" cur cnt)]
	    in
	    let final = merge (hd compressed) 1 (tl compressed) then
	    list2str T "<" "," ">" id final
	;
	install_print_function  P_`name`;
    }> "functor"
;

// Declare a new hw type with name 'name' and size number of bits as width.
let TYPE name size = (core_TYPE name size T "") fseq ();

TYPE "bit" 1;

let wexpr_hw_type_name {bv::wexpr} = "wexpr";
let wexpr_hw_mk_var {we::wexpr} base = W_VAR 0 base;
let wexpr_hw_is_arithmetic {e::wexpr} = T;
let wexpr_hw_size {e::wexpr} = 0; // or (wexpr_size e) ????????????
let wexpr_hw_destr {e::wexpr} = e;
let wexpr_hw_constr {e::wexpr} = e;
let wexpr_hw_values {e::wexpr} = "";
let wexpr_hw_bundle_parts {e::wexpr} = [], [];
let {wexpr_hw_type_destr :: {wexpr} hw_type} =
            HW_TYPE wexpr_hw_type_name
                    wexpr_hw_mk_var
                    wexpr_hw_is_arithmetic
                    wexpr_hw_size
                    wexpr_hw_destr
                    wexpr_hw_constr
                    wexpr_hw_values
                    wexpr_hw_bundle_parts
;
add_open_overload hw_type_destr wexpr_hw_type_destr;

let _i2_const i =
    let sz = hw_size {undefined:: *r} in
    let w = W_CONST sz i in
    {hw_constr w:: *r}
;

let _s2_var s =
    let sz = hw_size {undefined:: *r} in
    let nsz = md_size s in
    (sz != nsz) => eprintf "Size mismatch in '' (%d != %d) for %s" sz nsz s |
    let w = W_EXPLICIT_VAR sz s in
    {hw_constr w:: *r}
;

overload '' '' _i2_const _s2_var;


let wNOT {a:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_NOT (hw_destr a) in
    {hw_constr res:: *a}
;
let '~' a = wNOT a;

let wAND {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_AND (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '&' = wAND;
infix 4 '&';

let wITE {c::bit} {t:: *a} {e:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_ITE (hw_bit_destr c) (hw_destr t) (hw_destr e) in
    {hw_constr res :: *a}
;
let ':' {a:: *a} {b:: *a} = (a,b);
let '?' c (t,e) = wITE c t e;
if_then_else_binder '?' ':';

let wTHEN {c::wexpr} ({t::wexpr},{e::wexpr}) = W_ITE c t e;

let IF c = c;
let ELSE {t:: *a} {e:: *a} = (t,e);
let bitTHEN c (t,e) = c '?' t ':' e;
overload tmp_THEN bTHEN bevTHEN bitTHEN wTHEN;

let THEN {c:: *b} ({te:: *a # *a}) =
    let res = tmp_THEN c te in
    {res :: *a}
;
if_then_else_binder THEN ELSE;

let wOR {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_OR (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '|' = wOR;
infix 3 '|';

let wleq {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_LAT_LEQ (hw_destr a) (hw_destr b) in
    hw_bit_constr res
;

//let '<#=' a b = W_LAT_LEQ a b;
overload '<#=' wleq W_LAT_LEQ;
infix 2 '<#=';

let wXOR a b = wOR (wAND (wNOT a) b) (wAND a (wNOT b));
let '^' = wXOR;
infix 4 '^';

let wEQ {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_EQ (hw_destr a) (hw_destr b) in
    hw_bit_constr res
;

overload '=' wEQ W_EQ;
infix 5 '=';


let wNEQ {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let res = W_NOT (W_EQ (hw_destr a) (hw_destr b)) in
    {hw_bit_constr res:: bit}
;
let '!=' = wNEQ;
infix 5 '!=';

let wGR {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform > on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_GR (hw_destr a) (hw_destr b) in
    {hw_bit_constr res:: bit}
;
let '>' = wGR;
infix 5 '>';

let wLT {a:: *a} {b:: *a} = wGR b a;
let '<' = wLT;
infix 5 '<';

let wGEQ {a:: *a} {b:: *a} = wNOT (wGR b a);
let '>=' = wGEQ;
infix 5 '>=';

let wLEQ {a:: *a} {b:: *a} = wNOT (wGR a b);
let '<=' = wLEQ;
infix 5 '<=';

let wADD {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform + on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_ADD (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '+' = wADD;
infix 7 '+';

let wDIV {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform / on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_DIV (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '/' = wDIV;
infix 8 '/';

let wMUL {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform * on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_MUL (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;

let '*' = wMUL;
infix 8 '*';

let wSUB {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform - on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_SUB (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '-' = wSUB;
infix 7 '-';

let wMOD {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform %% on vectors of type %s\n" (hw_type_name a)
    |
    let res = W_MOD (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '%' = wMOD;
infix 8 '%';

let wSHL {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform << on vectors of type %s\n" (hw_type_name a)
    |
    NOT (hw_is_arithmetic b) =>
	eprintf "Cannot perform << on vectors of type %s\n" (hw_type_name b)
    |
    let res = W_SHL (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '<<' = wSHL;
infix 9 '<<';	    // Fixity???????

let wSHR {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform >> on vectors of type %s\n" (hw_type_name a)
    |
    NOT (hw_is_arithmetic b) =>
	eprintf "Cannot perform >> on vectors of type %s\n" (hw_type_name b)
    |
    let res = W_SHR (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '>>' = wSHR;
infix 9 '>>';	    // Fixity???????

let wASHR {a:: *a} {b:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    NOT (hw_is_arithmetic a) =>
	eprintf "Cannot perform |>> on vectors of type %s\n" (hw_type_name a)
    |
    NOT (hw_is_arithmetic b) =>
	eprintf "Cannot perform |>> on vectors of type %s\n" (hw_type_name b)
    |
    let res = W_ASHR (hw_destr a) (hw_destr b) in
    {hw_constr res:: *a}
;
let '|>>' = wASHR;
infix 9 '|>>';	    // Fixity???????

let ZX {inp:: *a} =
    val (HW_TYPE ihw_type_name ihw_mk_var ihw_is_arithmetic
		 ihw_size ihw_destr ihw_constr ihw_values hw_bparts) =
	{hw_type_destr :: {*q} hw_type}
    in
    val (HW_TYPE ohw_type_name ohw_mk_var ohw_is_arithmetic
		 ohw_size ohw_destr ohw_constr ohw_values hw_bparts) =
	{hw_type_destr :: {*b} hw_type}
    in
    let sz_in = ihw_size inp in
    let sz_out = ohw_size {undefined :: *b} in
    ((sz_in > sz_out) AND (sz_out != 0))
        => eprintf "ZX can't extend into smaller type (%d bits into %d bits)" sz_in sz_out
        |
    let w_out = W_ZX sz_out (ihw_destr inp) in
    let out = ohw_constr w_out in
    {out :: *b}
;

let SX {inp:: *a} =
    val (HW_TYPE ihw_type_name ihw_mk_var ihw_is_arithmetic
		 ihw_size ihw_destr ihw_constr ihw_values hw_bparts) =
	{hw_type_destr :: {*q} hw_type}
    in
    val (HW_TYPE ohw_type_name ohw_mk_var ohw_is_arithmetic
		 ohw_size ohw_destr ohw_constr ohw_values hw_bparts) =
	{hw_type_destr :: {*b} hw_type}
    in
    let sz_in = ihw_size inp in
    let sz_out = ohw_size {undefined :: *b} in
    ((sz_in > sz_out) AND (sz_out != 0))
        => eprintf "SX can't extend into smaller type (%d bits into %d bits)"
		   sz_in sz_out
        |
    let w_out = W_SX sz_out (ihw_destr inp) in
    let out = ohw_constr w_out in
    {out :: *b}
;

// Binary encoded enum
let ENUM_binary name name_list =
    name_list = [] => error "ENUM must have at least one element" |
    let sz = bits_needed ((length name_list)-1) in
    let value_list =
	let mk (i,n) = sprintf "{%d %s}" i n in
	list2str T "{" "" "}" mk (zip (0 upto (length name_list-1)) name_list)
    in
    NOT (core_TYPE name sz F value_list) => () |
    letrec add_item cnt (n:ns) =
        let cmd1 =
            sprintf "let %s_%s = hw_%s_constr (W_NAMED_CONST \"%s\" %d %d);"
		    name n name n sz cnt
        then
	let cmd2 =
	    (is_defined n) => sprintf "overload %s = %s %s_%s;" n n name n
			    | sprintf "let %s = %s_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
	NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        let cmd1 =
           (sprintf "let %s_is_%s i = hw_bit_constr " name n)^
	   (sprintf "(W_PRED \"is_%s\" (W_EQ (hw_%s_destr i) (W_CONST %d %d)));"
		    n  name sz cnt)
        then
	let cmd2 =
	    (is_defined ("is_"^n))
		   => sprintf "overload is_%s = is_%s %s_is_%s;" n n name n
		   |  sprintf "let is_%s = %s_is_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
        NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        add_item (cnt+1) ns
     /\    add_item cnt [] = ()
    in
    add_item 0 name_list
;

let ENUM_custom name name_encoding_list =
    name_encoding_list = [] => error "ENUM must have at least one element" |
    let max_code = itlist (\(n,ec).\r. max ec r) name_encoding_list 0 then
    let sz = bits_needed max_code in
    let value_list =
	let mk (n,i) = sprintf "{%d %s}" i n in
	list2str T "{" "" "}" mk name_encoding_list
    in
    NOT (core_TYPE name sz F value_list) => () |
    letrec add_item ((n,cnt):ns) =
        let cmd1 =
            sprintf "let %s_%s = hw_%s_constr (W_NAMED_CONST \"%s\" %d %d);"
		    name n name n sz cnt
        then
	let cmd2 =
	    is_defined n => sprintf "overload %s = %s %s_%s;" n n name n
			  | sprintf "let %s = %s_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
	NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        let cmd1 =
           (sprintf "let %s_is_%s i = hw_bit_constr " name n)^
	   (sprintf "(W_PRED \"is_%s\" (W_EQ (hw_%s_destr i) (W_CONST %d %d)));"
		    n name sz cnt)
        then
	let cmd2 =
	    (is_defined ("is_"^n))
		   => sprintf "overload is_%s = is_%s %s_is_%s;" n n name n
		   |  sprintf "let is_%s = %s_is_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
        NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        add_item ns
     /\    add_item [] = ()
    in
    add_item name_encoding_list
;

overload ENUM ENUM_binary ENUM_custom;

// Unary encoded enum
let MUTEX_ENUM name name_list =
    name_list = [] => error "MUTEX_ENUM must have at least one element" |
    let sz = length name_list in
    let value_list =
	let mk (i,n) = sprintf "{%d %s}" (2**i) n in
	list2str T "{" "" "}" mk (zip (0 upto (length name_list-1)) name_list)
    in
    NOT (core_TYPE name sz F value_list) => () |
    letrec add_item cnt (n:ns) =
        let cmd1 =
            sprintf "let %s_%s = hw_%s_constr (W_NAMED_CONST \"%s\" %d %d);"
		    name n name n sz (2**cnt)
        then
	let cmd2 =
	    (is_defined n) => sprintf "overload %s = %s %s_%s;" n n name n
			    | sprintf "let %s = %s_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
	NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        let cmd1 =
           (sprintf "let %s_is_%s i = hw_bit_constr " name n)^
	   (sprintf "(W_PRED \"is_%s\" (W_SLICE [%d] (hw_%s_destr i)));"
		    n cnt name)
        then
	let cmd2 =
	    (is_defined ("is_"^n))
		   => sprintf "overload is_%s = is_%s %s_is_%s;" n n name n
		   |  sprintf "let is_%s = %s_is_%s;" n name n
	then
	let cmds = [cmd1,cmd2] in
        NOT (eval_fl_code cmds) => eprintf "Failed to evaluate: %S" cmds |
        add_item (cnt+1) ns
     /\    add_item cnt [] = ()
    in
    add_item 0 name_list
;

let --> obj field_fn = field_fn obj;
infix 9 -->;

let <-- {old:: *a} ({field_fn:: *a -> *b},{new:: *b}) =
    let old = hw_destr old in
    let new = hw_destr new in
    let sz = hw_size {'a:: *a} in
    val (W_NAMED_SLICE nm indices _) = hw_destr (field_fn {'a:: *a}) then
    let res = hw_constr (W_UPDATE_NAMED_SLICE old nm indices new) then
    {res :: *a}
;
infix 8 <--;

let ? fn v = fn,v;
infix 9 ?;

let i_merge ilist =
    let i_merge1 n (res,cur_dir, cur_start, cur_last) =
	(cur_dir = -2) => (res,0,n,n) |
	(cur_dir = 1) AND (n = cur_last+1) => (res,cur_dir,cur_start,n) |
	(cur_dir = -1) AND (n = cur_last-1) => (res,cur_dir,cur_start,n) |
	(cur_dir = 0) AND (n = cur_last+1) => (res,1,cur_start,n) |
	(cur_dir = 0) AND (n = cur_last-1) => (res,-1,cur_start,n) |
	(((cur_last, cur_start):res),0,n,n)
    in
    val (res,cdir,cur_start,cur_end) = sitlist i_merge1 ilist ([],-2,0,0) in
    (cur_end,cur_start):res
;

let eval1 cmd = eval_fl_code [cmd];
non_lazy eval1;

let field_name_info_ref = ref {[]::(string#((string#string)list)) list};

let base_STRUCT_explicit name size field_list do_check =
    letrec check ((field_name, type, bits):rem) =
        NOT (is_defined (sprintf "BV_%s" type)) =>
            eprintf "Type %s not defined!" type
        |
        let t_size = get_hw_type_size type then
        length bits != t_size =>
            eprintf "Field %s has type %s of size %d but is given %d indices\n"
                    field_name type t_size (length bits)
        |
        let M = sitlist max bits 0 in
        M >= size =>
            eprintf "Field %s has an index outside the size of %s\n"
                    field_name name
        |
        check rem
     /\     check [] = ()
    in
    (do_check => check field_list | ()) fseq
    NOT (core_TYPE name size F "") => () |
    let info = (name, map (\(field,type,_). (field,type)) field_list) in
    (field_name_info_ref := (info:(deref field_name_info_ref))) fseq
    let declare_field (fn, type, bits) =
	let ranges = i_merge bits then
	let pr_range (f,t) = sprintf "(%d -- %d)" f t in
        let indices = list2str T "(" "@" ")" pr_range ranges in
        let cmd =
            sprintf
		"let _%s s = BV_%s (W_NAMED_SLICE \"%s\" %s (hw_%s_destr s));"
		 fn type fn indices name
        then
        (eval1 cmd) fseq
        (is_defined fn =>
            eval1 (sprintf "overload %s %s _%s;" fn fn fn)
        |
            eval1 (sprintf "let %s = _%s;" fn fn)
        ) fseq ()
    in
    (foreach declare_field field_list) fseq
    // Make assembly function
    let comment =
	let c1 =
	    sprintf "//Assemble a %s from its individual fields.\n" name
	in
	let c2 =
	    let pre = sprintf "\n//Usage:\n//\tmk_%s " name in
	    list2str T pre " " ";\n" fst field_list
	in
	c1^c2
    in
    let def =
	letrec mk_anon cnt ((field,type,bits):fs) =
	    ((sprintf "a%d" cnt), type ):(mk_anon (cnt+1) fs)
	 /\    mk_anon cnt [] = []
	in
	let ft_list = mk_anon 1 field_list in
	let pre = sprintf "let mk_%s " name in
	let lhs = list2str T pre " " " = " fst ft_list in
	let mk (field,type) = sprintf "(hw_%s_destr %s)" type field in
	let pre = sprintf " hw_%s_constr (W_CAT [\n\t" name in
	let rhs = list2str T pre ",\n\t" "]);" mk ft_list in
	lhs^rhs
    in
    let cmd = sprintf "%s\n%s\n" comment def in
    (eval1 cmd) fseq ()
;

let STRUCT_explicit name size field_list =
	base_STRUCT_explicit name size field_list T
;

let STRUCT_implicit name field_list =
    letrec build ((field_name, type):rem) =
        NOT (is_defined (sprintf "BV_%s" type)) =>
            eprintf "Type %s not defined!" type
        |
	val (cur_start, field_type_range_list) = build rem then
        let t_size = get_hw_type_size type then
	let next_start = cur_start+t_size in
	let bits = (next_start-1) downto cur_start in
	next_start, ((field_name, type, bits):field_type_range_list)
     /\     build [] = (0,[])
    in
    val (size, ftb_list) = build field_list then
    base_STRUCT_explicit name size ftb_list F
;

overload STRUCT STRUCT_explicit STRUCT_implicit;


let BUNDLE name left_signals right_signals =
    let current = deref hw_types_decl_ref in
    mem name (map fst current) =>
	(fprintf stderr "A hw type called %s is already defined\n" name)
	fseq F
    |
    let new = (name,0):current in
    (hw_types_decl_ref := new) fseq
    let pr (n,t) = sprintf "(\"%s\",\"%s\")" n t in
    let ssz =
	let sz = itlist (\(n,t).\r. get_hw_type_size t + r)
			(left_signals@right_signals) 0
	then
	sprintf "%d" sz
    then
    let slefts = list2str T "[" "," "]" pr left_signals then
    let srights = list2str T "[" "," "]" pr right_signals then
    (eval_fl_code
    <{
	lettype `name` = BUNDLE_`name` wexpr;
	//
	let hw_`name`_is_arithmetic {bv::`name`} = F;
	let hw_`name`_mk_var {bv::`name`} base = W_VAR 0 base;
	let hw_`name`_values {bv::`name`} = "";
	let hw_`name`_type_name {bv::`name`} = "`name`";
	let hw_`name`_size {bv::`name`} = `ssz`;
	let hw_`name`_constr w = BUNDLE_`name` w;
	let hw_`name`_destr (BUNDLE_`name` w) = w;
	let hw_`name`_bundle_parts {b::`name`} = `slefts`, `srights`;
	let {`name`_hw_type_destr:: {`name`} hw_type} =
	    HW_TYPE hw_`name`_type_name
		    hw_`name`_mk_var
		    hw_`name`_is_arithmetic
		    hw_`name`_size
		    hw_`name`_destr
		    hw_`name`_constr
		    hw_`name`_values
		    hw_`name`_bundle_parts
	;
	add_open_overload hw_type_destr `name`_hw_type_destr;
	let `name`_input body_fun {fs::string} acc {a::`name`} =
	    (defix input) body_fun fs acc a;
	let `name`_output body_fun {fs::string} acc {a::`name`} =
	    (defix output) body_fun fs acc a;
	let `name`_internal {body_fun:: `name`->(string-> *a -> pexlif)-> *b}
			    {fs::string} acc =
	    (defix internal) body_fun fs acc;
	;
	let `name`_list_internal
		    {cnt::int}
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
		=
	    (defix list_internal) cnt  body_fun fs acc
	;
	let `name`_list_input
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
	    =
		(defix list_input) body_fun fs acc
	;
	let `name`_list_output
		    {body_fun:: (`name` list) -> (string-> *a -> pexlif)-> *b}
		    {fs::string} acc
	    =
		(defix list_output) body_fun fs acc
	;
	binder_with_accumulator `name`_input CELL;
	binder_with_accumulator `name`_output CELL;
	binder_with_accumulator `name`_inout CELL;
	binder_with_accumulator `name`_internal CELL;
	sized_binder_with_accumulator `name`_list_internal CELL;
	binder_with_accumulator `name`_list_input CELL;
	binder_with_accumulator `name`_list_output CELL;
	let P_`name` {b::`name`} =
	    let bn = get_bundle_var b in
	    (list2str T "{<" " " "> " (\\p. bundle2field bn (fst p)) `slefts`)^
	    (list2str T "| <" " " ">}" (\\p. bundle2field bn (fst p)) `srights`)
	;
	install_print_function P_`name`;
    }> "functor"
    ) fseq
    let declare_field (field, type) =
	let cmd =
	    let p1 = sprintf "let _%s {b::%s} = " field name in
	    let p2 = sprintf "let bn = get_bundle_var b then " in
	    let p3 = sprintf "BV_%s (W_VAR %d (bundle2field bn \"%s\"));\n"
			    type (get_hw_type_size type) field
	    in
	    p1^p2^p3
        then
        (eval1 cmd) fseq
        (is_defined field =>
            eval1 (sprintf "overload %s %s _%s;" field field field)
        |
            eval1 (sprintf "let %s = _%s;" field field)
        ) fseq ()
    in
    (foreach declare_field (left_signals @ right_signals))
    fseq
    T
;

let MEMORY name size_list word_type =
    let width = get_hw_type_size word_type in
    let tot_size = itlist (\(lines,tp).\r. lines*r) size_list width in
    let current = deref hw_types_decl_ref in
    mem name (map fst current) =>
	(fprintf stderr "A hw type called %s is already defined\n" name)
	seq F
    |
    let new = (name,tot_size):current in
    (hw_types_decl_ref := new) fseq
    let ssz = sprintf "%d" tot_size in
    let swidth = sprintf "%d" width in
    let addr_sz =
	itlist (\(lns,atp).\r. get_hw_type_size atp+r) size_list 0
    in
    let s_addr_sz = sprintf "%d" addr_sz in
    let stot_lines = sprintf "%d" (itlist (\(lns,_).\r. lns*r) size_list 1) in
    let sVAR =
	let gen (lines,atype) = sprintf "[%d:0]" (lines-1) in
	let post = width == 1 => "\")" | sprintf "[%d:0]\")" (width-1) in
	let base_and_dims = list2str T "(base^\"" "" post gen size_list in
	sprintf "W_EXPLICIT_VAR %d %s" tot_size base_and_dims
    in
    let saddr_list =
        letrec mk_args cnt ((lns,atp):rem) =
            (sprintf " {addr%d :: %s}" cnt atp)^(mk_args (cnt+1) rem)
         /\    mk_args cnt [] = " "
        in
        mk_args 1 size_list
    in
    let saddr_args =
        letrec mk_args cnt ((lns,atp):rem) =
            (sprintf "    %s_input  addr%d.\n" atp cnt)^(mk_args (cnt+1) rem)
         /\    mk_args cnt [] = " "
        in
        mk_args 1 size_list
    in
    let lsz = length size_list in
    let rd_draw_fn =
	let pre = "\"draw_hfl {i1" in
	let sep = "" in
	let post = sprintf "}\"" in
	let pr i = sprintf "[i%d]" i in
	list2str T pre sep post pr (2 upto (lsz+1))
    in
    let wr_draw_fn =
	let pre = "\"draw_hfl {i1" in
	let sep = "" in
	let post = sprintf "<-i%d}\"" (lsz+2) in
	let pr i = sprintf "[i%d]" i in
	list2str T pre sep post pr (2 upto (lsz+1))
    in
    let saddr_w_adr_comp =
        letrec mk_expr cnt [(lns,atp)] =
	    get_hw_type_size atp = addr_sz =>
		(sprintf "hw_%s_destr addr%d" atp cnt)
	    |
		(sprintf "(W_ZX %s (hw_%s_destr addr%d))" s_addr_sz atp cnt)
         /\    mk_expr cnt ((lns,atp):rem) =
            let rest = mk_expr (cnt-1) rem in
            (sprintf "(W_ADD (W_ZX %s (hw_%s_destr addr%d))" s_addr_sz atp cnt)^
            (sprintf " (W_MUL (W_CONST %s %d) %s))" s_addr_sz lns rest)
         /\    mk_expr cnt [] = ""
        in
        mk_expr (lsz) (rev size_list)
    in
    eval_fl_code
    <{
	lettype `name` = BV_`name` wexpr;
	let hw_`name`_is_arithmetic {bv::`name`} = F;
	let hw_`name`_mk_var {bv::`name`} base = `sVAR`;
	let hw_`name`_values {bv::`name`} = "";
	let hw_`name`_type_name {bv::`name`} = "`name`";
	let hw_`name`_size {bv::`name`} = `ssz`;
	let hw_`name`_constr w = BV_`name` w;
	let hw_`name`_destr (BV_`name` w) = w;
	let hw_`name`_bundle_parts {b :: `name`} = [], [];
	let `name`_hw_type_destr =
	    HW_TYPE hw_`name`_type_name
		    hw_`name`_mk_var
		    hw_`name`_is_arithmetic
		    hw_`name`_size
		    hw_`name`_destr
		    hw_`name`_constr
		    hw_`name`_values
		    hw_`name`_bundle_parts
	;
	add_open_overload hw_type_destr `name`_hw_type_destr;
	let `name`_input body_fun {fs::string} acc {a::`name`} =
	    (defix input) body_fun fs acc a;
	let `name`_output body_fun {fs::string} acc {a::`name`} =
	    (defix output) body_fun fs acc a;
	let `name`_internal {body_fun:: `name`->(string-> *a -> pexlif)-> *b}
			    {fs::string} acc =
	    (defix internal) body_fun fs acc;
	binder_with_accumulator `name`_input CELL;
	binder_with_accumulator `name`_output CELL;
	binder_with_accumulator `name`_internal CELL;
	let `name`_info = MEM `s_addr_sz` `stot_lines` `swidth`;
	let read_`name` {mem :: `name`} `saddr_list` =
		hw_`word_type`_constr (W_MEM_READ `name`_info
						  (hw_`name`_destr mem)
						  (`saddr_w_adr_comp`))
	;
	let write_`name` {mem :: `name`} `saddr_list` {din:: `word_type`} =
		hw_`name`_constr (W_MEM_WRITE `name`_info
					      (hw_`name`_destr mem)
					      (`saddr_w_adr_comp`)
					      (hw_destr din))
	;
	let Read_`name` =
	    `name`_input        mem.
	    `saddr_args`
	    `word_type`_output	out.
	    CELL `rd_draw_fn` [
		out <- (hw_`word_type`_constr (W_MEM_READ `name`_info
						  (hw_`name`_destr mem)
						  (`saddr_w_adr_comp`)))
	];
	let Write_`name` =
	    `name`_input        mem.
	    `saddr_args`
	    `word_type`_input	din.
	    `name`_output	new_mem.
	    CELL `wr_draw_fn` [
		new_mem <- (hw_`name`_constr (W_MEM_WRITE `name`_info
						      (hw_`name`_destr mem)
						      (`saddr_w_adr_comp`)
						      (hw_destr din)))
	];
	let P_`name` t =
	    let bits = wexpr2bool [] (hw_`name`_destr t) then
	    let raw_res0 = map (sprintf "%B") bits in
	    let tr s = s = "F" => "0" | s = "T" => "1" | s in
	    let raw_res = map tr raw_res0 in
	    depends bits = [] =>
		sprintf "%x" (sscanf "%b" (implode raw_res))
	    |
	    let compressed = md_merge_vectors raw_res in
	    letrec merge cur cnt (c:cs) =
		    c = cur => merge cur (cnt+1) cs |
		    cnt = 1 => cur:(merge c 1 cs) |
		    cnt = 2 => cur:cur:(merge c 1 cs) |
		    cnt = 3 => cur:cur:cur:(merge c 1 cs) |
		    (sprintf "%s^%d" cur cnt):(merge c 1 cs)
	      /\\  merge cur cnt [] =
		    cnt = 1 => [cur] |
		    cnt = 2 => cur:cur:[] |
		    cnt = 3 => cur:cur:cur:[] |
		    [(sprintf "%s^%d" cur cnt)]
	    in
	    let final = merge (hd compressed) 1 (tl compressed) then
	    list2str T "<" "," ">" id final
	;
	install_print_function  P_`name`;
    }> "functor"
;

let emit_hw_type_info filename =
    let fp = fopen filename "w" then
    let fields = deref field_name_info_ref in
    let types = rev (deref hw_types_decl_ref) in
    let pr1 (name, sz) =
	(name = "bit") => () |
	(fprintf fp "type %s => \"%s\";\n" name name) fseq
	let fields = (assoc name fields) catch [] then
	let pre = sprintf "fields %s = [" name in
	let pfn fp (field,type) = fprintf fp "%s:%s" field type in
	(list2fp fp F pre ", " "];\n" pfn fields) fseq
	()
    in
    (foreach pr1 types) fseq
    (fclose fp)
;

let hw_split v =
    let sz = hw_size v in
    let wE = hw_destr v in
    letrec split i =
        i < 0 => [] |
        let bwE = W_SLICE [i] wE in
        (hw_bit_constr bwE):(split (i-1))
    in
    split (sz-1)
;

let hw_unsplit l =
    let wEs = map hw_bit_destr l then
    (
	let cnv (W_SLICE [idx] (W_VAR sz base)) =
		(idx,(W_VAR sz base))
	 /\ cnv (W_SLICE [idx] (W_EXPLICIT_VAR sz base)) =
		(idx,(W_EXPLICIT_VAR sz base))
	 /\ cnv _ = error "complex"
	in
	let res = map cnv wEs then
	val [var] = setify (map snd res) then
	hw_constr (W_SLICE (map fst res) var)
    ) catch (
	let wE = W_CAT wEs in
	hw_constr wE
    )
;

//
// A circuit that takes an input (vector) and outputs a 1 only after the
// input has been the same for duration_in_phases phases.
//
let is_stable duration_in_phases inp ok =
    duration_in_phases = 0 =>
	(
	    input	inp.
	    bit_output	ok.
	    CELL "draw_hfl {is stable\nfor 0  \nphases }" [
		ok <- '1
	    ]
	) inp ok
    |
    duration_in_phases = 1 =>
	(
	    input	inp.
	    bit_output	ok.
	    internal	old.
	    CELL "draw_hfl {is stable\nfor 0  \nphases }" [
		old <: inp,
		ok <- old '=' inp
	    ]
	) inp ok
    |
	(
	    input       inp.
	    bit_output  ok.
	    internal        old.
	    bit_internal    same.
	    bit_list_internal (duration_in_phases-1) same_list.
	    CELL (sprintf "draw_hfl {is stable\nfor %d  \nphases }"
			   duration_in_phases) 
	    (
		(map2 (\o.\i. o <: i) same_list ((tl same_list)@[same]))
		@
		[
		    old <: inp,
		    same <- (old '=' inp),
		    ok <- itlist (\s.\r. s '&' r) same_list same
		]
	    )
	) inp ok
;


// MUX between two signals.
let MUX =
    bit_input c.
    input a b.
    output out.
    CELL "MUX" [
	out <- (IF c THEN a ELSE b)
];


begin_abstype;
// ---------------------------------------------------
// Needed to make the drawing functions happy....
let base_re_ff =
    input d.
    bit_input clk.
    output q.
    internal TmP_d_o TmP_clk_o TmP_q_o TmP_en.
    CELL "draw_ff_re" [
	TmP_d_o <: d,
	TmP_q_o <: q,
	TmP_clk_o <: clk,
	TmP_en <- '~'TmP_clk_o '&' clk,
	MUX TmP_en TmP_d_o TmP_q_o q
];

let base_re_ff_en =
    input	d.
    bit_input	en.
    bit_input	clk.
    output	q.
    internal	mid.
    CELL "draw_ff_re_with_en" [
	MUX en d q mid,
	base_re_ff mid clk q
];

let base_re_ff_reset =
    input	d.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	mid cur.
    CELL "draw_ff_re_reset" [
	MUX reset '0 d mid,
	base_re_ff mid clk cur,
	MUX reset '0 cur q
];

let base_re_ff_sreset =
    input	d.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	mid.
    CELL "draw_ff_re_reset" [
	MUX reset '0 d mid,
	base_re_ff mid clk q
];

let base_re_ff_en_reset =
    input	d.
    bit_input	en.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	tmp mid cur.
    CELL "draw_ff_re_with_en_reset" [
	MUX en d q tmp,
	MUX reset '0 tmp mid,
	base_re_ff mid clk cur,
	MUX reset '0 cur q
];

let base_re_ff_en_sreset =
    input	d.
    bit_input	en.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	tmp mid.
    CELL "draw_ff_re_with_en_reset" [
	MUX en d q tmp,
	MUX reset '0 tmp mid,
	base_re_ff mid clk q
];

let base_re_ff_en_reset_with_value reset_value =
    input	d.
    bit_input	en.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	tmp mid cur.
    CELL "draw_ff_re_with_en_reset" [
	MUX en d q tmp,
	MUX reset reset_value tmp mid,
	base_re_ff mid clk cur,
	MUX reset reset_value cur q
];

let base_re_ff_en_sreset_with_value reset_value =
    input	d.
    bit_input	en.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	tmp mid.
    CELL "draw_ff_re_with_en_reset" [
	MUX en d q tmp,
	MUX reset reset_value tmp mid,
	base_re_ff mid clk q
];

//
// A rising edge D flip-flop.
// 
slet re_ff clk d q = base_re_ff d clk q;

// A rising edge D flip-flop with asynchronous reset (active high).
slet re_ff_reset clk reset d q = base_re_ff_reset d reset clk q;

// A rising edge D flip-flop with enable.
slet re_ff_en clk en d q = base_re_ff_en d en clk q;

// A rising edge D flip-flop with enable and asynchronous reset (active high).
slet re_ff_en_reset clk en reset d q = base_re_ff_en_reset d en reset clk q;

// A rising edge D flip-flop with enable and asynchronous reset (active high).
slet re_ff_en_reset_with_value reset_value clk en reset d q =
    base_re_ff_en_reset_with_value reset_value d en reset clk q;

// A rising edge D flip-flop with synchronous reset (active high).
slet re_ff_sreset clk reset d q = base_re_ff_sreset d reset clk q;

// A rising edge D flip-flop with enable and synchronous reset (active high).
slet re_ff_en_sreset clk en reset d q = base_re_ff_en_sreset d en reset clk q;

// A rising edge D flip-flop with enable and synchronous reset (active high).
slet re_ff_en_sreset_with_value reset_value clk en reset d q =
    base_re_ff_en_sreset_with_value reset_value d en reset clk q;

// ---------------------------------------------------
// Needed to make the drawing functions happy....
let base_fe_ff =
    input d.
    bit_input clk.
    output q.
    bit_internal nclk.
    CELL "draw_ff_fe" [
	base_re_ff d nclk q,
	nclk <- '~' clk
];

let base_fe_ff_en =
    input	d.
    bit_input	en.
    bit_input	clk.
    output	q.
    internal	mid.
    CELL "draw_ff_fe_with_en" [
	MUX en d q mid,
	base_fe_ff mid clk q
];

let base_fe_ff_reset =
    input	d.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	mid cur.
    CELL "draw_ff_fe_reset" [
	MUX reset '0 d mid,
	base_fe_ff mid clk cur,
	MUX reset '0 cur q
];

let base_fe_ff_en_reset =
    input	d.
    bit_input	en.
    bit_input	reset.
    bit_input	clk.
    output	q.
    internal	tmp mid cur.
    CELL "draw_ff_fe_with_en_reset" [
	MUX en d q tmp,
	MUX reset '0 tmp mid,
	base_fe_ff mid clk cur,
	MUX reset '0 cur q
];

//
// A falling edge D flip-flop.
// 
let fe_ff clk d q = base_fe_ff d clk q;

// A falling edge D flip-flop with asynchronous reset (active high).
let fe_ff_reset clk reset d q = base_fe_ff_reset d reset clk q;

// A falling edge D flip-flop with enable.
let fe_ff_en clk en d q = base_fe_ff_en d en clk q;

// A falling edge D flip-flop with enable and asynchronous reset (active high).
let fe_ff_en_reset clk en reset d q = base_fe_ff_en_reset d en reset clk q;

end_abstype re_ff re_ff_reset re_ff_en re_ff_en_reset re_ff_en_reset_with_value
	    re_ff_sreset re_ff_en_sreset re_ff_en_sreset_with_value
	    fe_ff fe_ff_reset fe_ff_en fe_ff_en_reset
;


begin_abstype;
// ---------------------------------------------------
// Needed to make the drawing functions happy....
let base_ah_latch =
    input	d.
    bit_input	clk.
    output	q.
    //
    internal TmP_q_o.
    CELL "draw_ah_latch" [
	TmP_q_o <: q,
	MUX clk d TmP_q_o q
];

let base_al_latch =
    input d.
    bit_input clk.
    output q.
    internal TmP_q_o.
    CELL "draw_al_latch" [
	TmP_q_o <: q,
	MUX clk TmP_q_o d q
];

// An active high transparent latch.
let ah_latch en d out = base_ah_latch d en out;

// An active low transparent latch.
let al_latch en d out = base_al_latch d en out;

end_abstype ah_latch al_latch;


let extract_bit v idx =
    let wbits = hw_destr v in
    let sz = hw_size v in
    idx >= 0 AND ((sz = 0) OR idx < sz) => BV_bit (W_SLICE [idx] wbits) |
    eprintf "Range error: Trying to extract bit %d in vector of size [%d:0]"
	    idx (sz-1)
;

let extract_range v range =
        let wbits = hw_destr v in
        hw_constr (W_SLICE range wbits)
;

let ++ a b =
    let aw = hw_destr a in
    let bw = hw_destr b in
    let rw = W_CAT [aw,bw] in
    hw_constr rw
;
infix 1 ++;


// Extract a single bit from a word
let  ~~ = extract_bit;
infix 9 ~~;

// Extract a range from a word
let  ~~~ = extract_range;
infix 9 ~~~;

let default = {'1::bit};

// Covert a hardware type to a list of bits
let tobits {t:: *a} =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*a} hw_type}
    in
    let sz = hw_size t in
    let w = hw_destr t in
    sz = 1 => [hw_bit_constr w] |
    map (\i. hw_bit_constr (W_SLICE [i] w)) ((sz-1) downto 0)
;

// Covert a list of bits to a hardware type
let frombits bl =
    val (HW_TYPE hw_type_name hw_mk_var hw_is_arithmetic
		 hw_size hw_destr hw_constr hw_values hw_bparts) =
	{hw_type_destr :: {*r} hw_type}
    in
    let rsz = hw_size {undefined:: *r} in
    rsz != length bl =>
        eprintf "Length mismatch in frombits (%d != %d)" rsz (length bl)
    |
    {hw_constr (W_CAT (map hw_bit_destr bl)) :: *r}
;

//begin_abstype;

let R_excluded e =
    let res =
	letrec get_prods (W_AND a b) = (get_prods a)@(get_prods b)
	 /\    get_prods other = [other]
	in
	let not_t (W_CONST 1 1) = F
	 /\ not_t other = T
	in
	let prods = filter not_t (setify (get_prods e)) then
	prods = [] => W_CONST 1 1 |
	length prods = 1 => hd prods |
	//
	let is_neg (W_NOT _) = T
	 /\ is_neg other = F
	in
	val (negs, pos) = split is_neg prods then
	let pos = rev pos then
	negs = [] => sitlist W_AND (tl pos) (hd pos) |
	//
	let is_unsat e =
	    let bv = wexpr2bool [] e in
	    bv == [F]
	in
	pos = [] => sitlist W_AND (tl negs) (hd negs) |
	let P = sitlist W_AND (tl pos) (hd pos) then
	let keep e = NOT (is_unsat (W_AND P (W_NOT e))) then
	let negs' = filter keep negs then
	sitlist W_AND negs' P
    in
    res catch e
;

let rewrite e =
    e fseq
    let rewrite (W_AND (W_CONST 1 1) e) = e
     /\ rewrite (W_AND (W_CONST 1 0) e) = (W_CONST 1 0)
     /\ rewrite (W_AND e (W_CONST 1 1)) = e
     /\ rewrite (W_AND e (W_CONST 1 0)) = (W_CONST 1 0)
     /\ rewrite (W_AND e f) assuming (e == f) = e
     /\ rewrite (W_AND e f) = R_excluded (W_AND e f)
     /\ rewrite (W_OR (W_CONST 1 0) e) = e
     /\ rewrite (W_OR (W_CONST 1 1) e) = (W_CONST 1 1)
     /\ rewrite (W_OR e (W_CONST 1 0)) = e
     /\ rewrite (W_OR e (W_CONST 1 1)) = (W_CONST 1 1)
     /\ rewrite (W_OR e f) assuming (e == f) = e
     /\ rewrite (W_NOT (W_OR (W_NOT e) f)) = W_AND e (W_NOT f)
     /\ rewrite (W_NOT (W_OR e (W_NOT f))) = W_AND (W_NOT e) f
     /\ rewrite (W_NOT (W_AND (W_NOT e) f)) = W_OR e (W_NOT f)
     /\ rewrite (W_NOT (W_AND e (W_NOT f))) = W_OR (W_NOT e) f
     /\ rewrite (W_NOT (W_CONST 1 0)) = (W_CONST 1 1)
     /\ rewrite (W_NOT (W_CONST 1 1)) = (W_CONST 1 0)
     /\ rewrite (W_NOT (W_NOT e)) = e
     /\ rewrite e = e
    in
    rewrite e
;

letrec simp (W_AND a b) = rewrite (W_AND (simp a) (simp b))
 /\    simp (W_OR a b)  = rewrite (W_OR (simp a) (simp b))
 /\    simp (W_PRED name cond) = rewrite (W_PRED name (simp cond))
 /\    simp (W_EQ a b)  = rewrite (W_EQ (simp a) (simp b))
 /\    simp (W_GR a b)  = rewrite (W_GR (simp a) (simp b))
 /\    simp (W_ADD a b) = rewrite (W_ADD (simp a) (simp b))
 /\    simp (W_SUB a b) = rewrite (W_SUB (simp a) (simp b))
 /\    simp (W_MUL a b) = rewrite (W_MUL (simp a) (simp b))
 /\    simp (W_DIV a b) = rewrite (W_DIV (simp a) (simp b))
 /\    simp (W_MOD a b) = rewrite (W_MOD (simp a) (simp b))
 /\    simp (W_SHL a b) = rewrite (W_SHL (simp a) (simp b))
 /\    simp (W_SHR a b) = rewrite (W_SHR (simp a) (simp b))
 /\    simp (W_ASHR a b) = rewrite (W_ASHR (simp a) (simp b))
 /\    simp (W_SX sz w) = rewrite (W_SX sz (simp w))
 /\    simp (W_ZX sz w) = rewrite (W_ZX sz (simp w))
 /\    simp (W_NOT w) = rewrite (W_NOT (simp w))
 /\    simp (W_ITE c t e) = rewrite (W_ITE (simp c) (simp t) (simp e))
 /\    simp (W_SLICE indices w) = rewrite (W_SLICE indices (simp w))
 /\    simp (W_NAMED_SLICE name indices w) =
	    rewrite (W_NAMED_SLICE name indices (simp w))
 /\    simp (W_UPDATE_NAMED_SLICE base name indices w) =
	    rewrite (W_UPDATE_NAMED_SLICE (simp base) name indices (simp w))
 /\    simp (W_CAT parts) = rewrite (W_CAT (map simp parts))
 /\    simp (W_MEM_READ info mem addr) =
	    rewrite (W_MEM_READ info (simp mem) (simp addr))
 /\    simp (W_MEM_WRITE info mem addr data) =
	    rewrite (W_MEM_WRITE info (simp mem) (simp addr) (simp data))
 /\    simp other = other
;

let cond_simplify e =
    letrec do cnt e =
	cnt > 20 => e |
	let e' = simp e then
	e' == e => e | do (cnt+1) e'
    in
    do 0 e
;

//end_abstype cond_simplify;

begin_abstype;

let draw_fsm reset S0 orig_trans base_inps =
    let reset = Pwexpr (hw_destr reset) in
    let S0n =
	val (W_NAMED_CONST n _ v) = hw_destr S0 in
	(n,v)
    in
    let cnv (f,on',t) =
        val (W_NAMED_CONST fn _ fv) = hw_destr f in
        val (W_NAMED_CONST tn _ tv) = hw_destr t in
	let w_on = hw_destr on' in
        (fn,fv), w_on, (tn,tv)
    in
    let trans = map cnv orig_trans in
    let get_state (f,_,t) =  [f,t] in
    let r_states = setify (S0n:(flatmap get_state trans)) then
    let cmp (s1,v1) (s2,v2) = v1-v2 in
    let states = qsort cmp r_states then
    let res = ref [] in
    let append s = (res := (s:(deref res))) in
    (append (sprintf "digraph finite_state_machine {\n")) fseq
    (append (sprintf "rankdir=LR;\n")) fseq
    (append (sprintf "size=\"8,5\"\n")) fseq
    (append (sprintf "dummy_inp [shape = point];\n")) fseq
    let mk_state (name,v) =
        append (sprintf "%s [shape = circle, fixedsize=true, label = \"S%d\"]\n"
			name v)
    in
    (foreach mk_state states) fseq
    let ptrans = partition fst trans in
    let emit_edge ((f,fv),on',(t,tv)) =
        append (sprintf "%s -> %s [ label = \"%s\" ];\n" f t on')
    in
    letrec mk_edges done ((f,on',t):rem) =
	let cond = W_AND on' (W_NOT done) in
	let scond = cond_simplify cond in
	let s_cond = base_compact_wprint base_inps scond in
	let f_cond = Pwexpr scond in
	(emit_edge (f,s_cond,t)) fseq
	(s_cond,f_cond):(mk_edges (W_OR done on') rem)
     /\    mk_edges done [] = []
    in
    let edges = flatmap (mk_edges (W_CONST 1 0)) ptrans then
    (emit_edge (("dummy_inp",0), reset, S0n)) fseq
    (append (sprintf "}\n")) fseq
    let code = accumulate (defix ^) (rev (deref res)) then
    code, states, edges
;

let build_cond w_state conds =
    letrec build_cond (same_src:rest) =
	let from_state = fst (hd same_src) then
	letrec build covered ((_,wcond,to_state):rem) =
	    let ncond = W_AND wcond (W_NOT covered) then
	    W_ITE ncond to_state (build (W_OR covered wcond) rem)
	 /\    build covered [] = from_state
	in
	W_ITE (W_EQ w_state from_state) (build (W_CONST 1 0) same_src)
				      (build_cond rest)
     /\   build_cond [] = w_state
    in
    build_cond conds
;

// Create a Moore finite state machine named 'name'.
// The FSM uses a rising edge triggered flip-flop whose clock is clk.
// The `state' is the names of the vector of wires that will record the
// state of the machine.
// The reset_condition is a pair of (reset_signal, reset_state).
// Finally, transitions is a list of (from_state, condition, to_state) triples.
// It is convenient to use the --- function instead of , for the transitions.
// For example,
//	(INIT --- req --- PROCESS)
// is (arguably) easier to read than:
//	(INIT, req, PROCESS).
// However, both are equally valid.
//
// Note that this function will create an explicit visualization of the
// finite state machine that can be seen by clicking on the FSM symbol
// in the circuit browser.
let Moore_FSM name clk state reset_condition transitions =
    val (reset,S0) = reset_condition then
    let w_state = hw_destr {state:: *a} in
    let cnv (from_state, cond, to_state) =
	(hw_destr {from_state:: *a}),
	(hw_destr {cond::bit}),
	(hw_destr {to_state:: *a})
    in
    let wtransitions = map cnv transitions then
    let wS0 = hw_destr {S0:: *a} then
    //
    val (W_VAR ssz b_state) = w_state then
    let n_state = mk_name ssz b_state then
    let b_nstate = "_new_"^b_state then
    let w_nstate = W_VAR ssz b_nstate then
    let n_nstate = mk_name ssz b_nstate then
    let b_istate = "_intermediate_"^b_state then
    let w_istate = W_VAR ssz b_istate then
    let n_istate = mk_name ssz b_istate then
    let s_clk = hd (w_depends (hw_bit_destr clk)) then
    let w_reset = hw_bit_destr reset then
    let reset_name = hd (w_depends w_reset) then
    let get_we (from_state, cond, to_state) = w_depends cond then
    let wes = flatmap get_we wtransitions then
    let raw_inps = qsort node_name_cmp (setify wes) then
    let fa_inps = (map (\n.n,[n]) (raw_inps subtract [n_state]))@
		  [(reset_name, [reset_name]), (s_clk, [s_clk])]
    then
    let fa_outs = [(n_state, [n_state])] then
    let ints = [n_nstate, n_istate] then
    let ssz = hw_size state then
    let part_trans = partition fst wtransitions then
    let w_new_state = W_ITE w_reset wS0 (build_cond w_state part_trans) then
    let comb = {(hw_constr w_nstate):: *a} <- (hw_constr w_new_state) then
    let w_final_state = W_ITE w_reset wS0 w_istate then
    let comb2 = state <- {(hw_constr w_final_state):: *a} then
    let body = P_HIER [
	re_ff clk {(hw_constr w_nstate):: *a} {(hw_constr w_istate):: *a},
	comb,
	comb2
    ] then
    let base_inps = map (\(f,a). hd (str_split f "[")) fa_inps then
    val (code,states,edges) = draw_fsm reset S0 transitions base_inps then
    let pr (f,a) = sprintf "{%s}" f in
    let s_fa_inps = list2str T "{" " " "}" pr fa_inps then
    let ps (n,v) = sprintf "{S%d %s}" v n in
    let s_states = list2str T "{" " " "}" ps states then
    let pe (s_on, f_on) = sprintf "{%s {%s}}" s_on f_on in
    let s_edges = list2str T "{" " " "}" pe edges then
    let pfn =
	sprintf "draw_fsm {%s} {%s} %s %s %s"
		name code s_states s_edges s_fa_inps
    then
    let res = PINST pfn [] T fa_inps fa_outs ints body then
    res
;

end_abstype Moore_FSM;

let CASE {out:: *a} {cond_res_list:: (bit # *a) list} {default_value:: *a} =
    let w_out = hw_destr out then
    let cnv (cond,res) = hw_bit_destr cond, hw_destr res then
    let w_cond_res_list = map cnv cond_res_list then
    let w_default_value = hw_destr default_value then
    w_CASE w_out w_cond_res_list w_default_value
;

let STATE {clk::bit} {state:: *a} {cond_res_list:: (bit # *a) list} =
    let sz = hw_size state in
    let n = length cond_res_list then
    let w_clk = hw_destr clk then
    let n_clk = hd (w_depends w_clk) then
    let w_state = hw_mk_var {undefined :: *a} (sprintf "%ss" BASE_TMP) then
    let new_state = {hw_constr w_state :: *a} then
    let w_new_state = hw_destr new_state then
    let n_new_state = hd (w_depends w_new_state) then
    let w_state = hw_destr state then
    let n_state = hd (w_depends w_state) then
    let fa_states = [(n_state,[n_state])] in
    let fa_outs = [(n_new_state,[n_new_state])] in
    let cnv (cond,res) = hw_bit_destr cond, hw_destr res in
    let w_crl = map cnv cond_res_list then
    let var2name (W_VAR s b) = [mk_name s b]
     /\ var2name (W_EXPLICIT_VAR s b) = [b]
     /\ var2name other = []
    in
    let ld = W_VAR sz (sprintf "%sd" BASE_TMP) in
    let nd = mk_name sz (sprintf "%sd" BASE_TMP) in
    let d_fas = [(nd,[nd])] in
    let default_p = (hw_constr ld) <- state then
    letrec select cnt ((c,r):rem) =
        let bc = sprintf "%sc%02d" BASE_TMP cnt in
        let br = sprintf "%sr%02d" BASE_TMP cnt in
        let lc = W_VAR 1 bc in
        let lr = W_VAR sz br in
        val (c_ints, c_act, c_extra) =
	    let v = var2name c in
	    v = [] =>
		let en = mk_name 1 bc in
		([en], en, [((hw_bit_constr lc) <- (hw_bit_constr c))])
	    |
	    ([], hd v, [])
        in
        val (r_ints, r_act, r_extra) =
	    let v = var2name r in
	    v = [] =>
		let en = mk_name sz br in
		([en], en, [((hw_bit_constr lr) <- (hw_bit_constr r))])
	    |
	    ([], hd v, [])
        in
        val (fas, e, ints, extras) = select (cnt+1) rem then
        let fas = (mk_name 1 bc, [c_act]):(mk_name sz br, [r_act]):fas then
        let e = W_ITE lc lr e then
        let ints = c_ints@r_ints@ints in
        let extras = c_extra@r_extra@extras in
        (fas, e, ints, extras)
     /\    select cnt [] = [], ld, [], []
    in
    val (fas, rhs, ints, extras) = select 1 w_crl then
    let ints = n_new_state:nd:ints in
    let body = new_state <- (hw_constr rhs) then
    let pfn = sprintf "draw_CASE %d" n then
    let mux = PINST pfn [] T (fas@d_fas) fa_outs [] (P_HIER [body]) in
    let ff = re_ff clk new_state state then
    let children = ff:default_p:mux:extras in
    let get_acts (PINST _ _ _ ifa _ _ _) = flatmap snd ifa in
    let inps = (setify (flatmap get_acts children)) subtract ints then
    let fa_inps = (map (\v.v,[v]) inps) then
    PINST "_WrApPeR_" [] F fa_inps fa_states ints (P_HIER children)
;

let EN_STATE {clk::bit} {enable::bit} {state:: *a}
	     {cond_res_list:: (bit # *a) list}
    =
    let sz = hw_size state in
    let n = length cond_res_list then
    let w_clk = hw_destr clk then
    let n_clk = hd (w_depends w_clk) then
    let w_state = hw_mk_var {undefined :: *a} (sprintf "%ss" BASE_TMP) then
    let new_state = {hw_constr w_state :: *a} then
    let w_new_state = hw_destr new_state then
    let n_new_state = hd (w_depends w_new_state) then
    let w_state = hw_destr state then
    let n_state = hd (w_depends w_state) then
    let fa_states = [(n_state,[n_state])] in
    let fa_outs = [(n_new_state,[n_new_state])] in
    let cnv (cond,res) = hw_bit_destr cond, hw_destr res in
    let w_crl = map cnv cond_res_list then
    let var2name (W_VAR s b) = [mk_name s b]
     /\ var2name (W_EXPLICIT_VAR s b) = [b]
     /\ var2name other = []
    in
    let ld = W_VAR sz (sprintf "%sd" BASE_TMP) in
    let nd = mk_name sz (sprintf "%sd" BASE_TMP) in
    let d_fas = [(nd,[nd])] in
    let default_p = (hw_constr ld) <- state then
    letrec select cnt ((c,r):rem) =
        let bc = sprintf "%sc%02d" BASE_TMP cnt in
        let br = sprintf "%sr%02d" BASE_TMP cnt in
        let lc = W_VAR 1 bc in
        let lr = W_VAR sz br in
        val (c_ints, c_act, c_extra) =
	    let v = var2name c in
	    v = [] =>
		let en = mk_name 1 bc in
		([en], en, [((hw_bit_constr lc) <- (hw_bit_constr c))])
	    |
	    ([], hd v, [])
        in
        val (r_ints, r_act, r_extra) =
	    let v = var2name r in
	    v = [] =>
		let en = mk_name sz br in
		([en], en, [((hw_bit_constr lr) <- (hw_bit_constr r))])
	    |
	    ([], hd v, [])
        in
        val (fas, e, ints, extras) = select (cnt+1) rem then
        let fas = (mk_name 1 bc, [c_act]):(mk_name sz br, [r_act]):fas then
        let e = W_ITE lc lr e then
        let ints = c_ints@r_ints@ints in
        let extras = c_extra@r_extra@extras in
        (fas, e, ints, extras)
     /\    select cnt [] = [], ld, [], []
    in
    val (fas, rhs, ints, extras) = select 1 w_crl then
    let ints = n_new_state:nd:ints in
    let body = new_state <- (hw_constr rhs) then
    let pfn = sprintf "draw_CASE %d" n then
    let mux = PINST pfn [] T (fas@d_fas) fa_outs [] (P_HIER [body]) in
    let ff = re_ff_en clk enable new_state state then
    let children = ff:default_p:mux:extras in
    let get_acts (PINST _ _ _ ifa _ _ _) = flatmap snd ifa in
    let inps = (setify (flatmap get_acts children)) subtract ints then
    let fa_inps = (map (\v.v,[v]) inps) then
    PINST "_WrApPeR_" [] F fa_inps fa_states ints (P_HIER children)
;

let SELECT =
    input   inp.
    input   addr.
    output  out.
    CELL "draw_SELECT" [
	let inp_sz = hw_size inp in
	let addr_sz = hw_size addr in
	let out_sz = hw_size out in
	(inp_sz % out_sz) != 0 =>
	    eprintf "Input size %d not a multiple of output size %d in SELECT\n"
		    inp_sz out_sz
	|
	let lines = inp_sz / out_sz in
	lines > 2**addr_sz =>
	    eprintf "Too many lines (%d) in SELECT for address size (%d)"
		    lines addr_sz
	|
        CASE out
            (map (\i. ((addr '=' ''i),
                      inp~~~(((i+1)*out_sz-1) downto (i*out_sz))))
                (0--(lines-1))
            ) ('X)
];


let SELECT_list =
    list_input  {inps:: *a list}.
    input       addr.
    output      {out:: *a}.
    CELL "draw_SELECT" [
        let lines = length inps in
        let addr_sz = hw_size addr in
        lines > 2**addr_sz =>
            eprintf "Too many lines (%d) in SELECT_list for address size (%d)"
                    lines addr_sz
        |
        let sel i = el (lines-i) inps in
        CASE out
             (map (\i. ((addr '=' ''i), sel i)) (0--(lines-1))) ('X)
];

let DECODER =
    input   inp.
    output  out.
    let isz = hw_size inp in
    let osz = hw_size out in
    osz != (2**isz) =>
	eprintf "Output size (%d) of DECODER not power of input size (%d)"
		osz isz
    |
    let pfn = sprintf "draw_DECODER 0 %d %d" isz osz in
    let mk i = hw_bit_destr (inp '=' (''i)) in
    CELL pfn [
	out <- hw_constr (W_CAT (map mk ((2**(hw_size inp)-1) downto 0)))
];

let DECODER_list =
    input	inp.
    list_output	{outs:: bit list}.
    let isz = hw_size inp in
    let osz = length outs in
    osz != (2**isz) =>
	eprintf "Output size (%d) of DECODER not power of input size (%d)"
		osz isz
    |
    let pfn = sprintf "draw_DECODER 0 %d %d" isz osz in
    CELL pfn (
	map2 (\i.\o. o <- (inp '=' (''i))) ((2**(hw_size inp)-1) downto 0) outs
);

let EN_DECODER =
    bit_input	enable.
    input	inp.
    output	out.
    let isz = hw_size inp in
    let osz = hw_size out in
    osz != (2**isz) =>
	eprintf "Output size (%d) of EN_DECODER not power of input size (%d)"
		osz isz
    |
    let pfn = sprintf "draw_DECODER 1 %d %d" isz osz in
    let mk i = hw_bit_destr (enable '&' (inp '=' (''i))) in
    CELL pfn [
	out <- hw_constr (W_CAT (map mk ((2**(hw_size inp)-1) downto 0)))
];

let EN_DECODER_list =
    bit_input	enable.
    input	inp.
    list_output	{outs :: bit list}.
    let isz = hw_size inp in
    let osz = length outs in
    let pfn = sprintf "draw_DECODER 1 %d %d" isz osz in
    CELL pfn (
	map2 (\i.\o. o <- (enable '&' (inp '=' (''i))))
	     ((length outs-1) downto 0) outs
);


begin_abstype;

letrec encode_rec =
    list_input  {bl :: bit list}.
    bit_output  valid.
    output      {addr :: *a}.
    bit_internal    l_valid h_valid.
    internal        {l_addr:: *a} {h_addr:: *a} {base:: *a}.
    CELL "draw_hier ENCODER" (
        bl = [] => [addr <- '0, valid <- '0] |
        length bl = 1 => [addr <- '0, valid <- (hd bl)] |
        let n = length bl in
        let lsbs = lastn (n/2) bl in
        let msbs = butlastn (n/2) bl in
        [
            encode_rec lsbs l_valid l_addr,
            encode_rec msbs h_valid h_addr,
            valid <- l_valid '|' h_valid,
            base <- ''(n/2),
            addr <- (IF l_valid THEN l_addr ELSE (base '|' h_addr))
        ]
);

//
// A module that takes a list of inputs and returns the address of the
// least significant input that is 1. If there is at least one
// such bit, the valid signal is 1. Otherwise valid is 0.
//
let list_ENCODER =
    list_input  {bl :: bit list}.
    bit_output  valid.
    output      addr.
    CELL "draw_hier ENCODER" [
        let lbl = length bl in
        let n = bits_needed (lbl-1) in
        encode_rec ((replicate (2**n-lbl) {'0::bit})@bl) valid addr
];

//
// A module that takes an input and returns the address of the
// least significant bit that is 1. If there is at least one
// such bit, the valid signal is 1. Otherwise valid is 0.
//
let ENCODER =
    input   iv.
    bit_output  valid.
    output      addr.
    CELL "draw_hier ENCODER" [
	list_ENCODER (tobits iv) valid addr
];

end_abstype ENCODER list_ENCODER;



let --- a b = (a, b);
infixr 2 ---;

let ROM name lines addr out = (
    input   addr.
    output  out.
    let a_sz = hw_size addr in
    lines > 2**a_sz => eprintf "Too many lines in ROM for address size" |
    let d_sz = hw_size out in
    let s_mem = sprintf "%s[%d:0][%d:0]" name (lines-1) (d_sz-1) then
    let w_addr = hw_destr addr in
    let s_addr = hd (get_lhs_vars w_addr) in
    let w_out = hw_destr out in
    let s_out = hd (get_lhs_vars w_out) in
    letrec read i =
        i < 0 => W_X d_sz |
        let line = W_VAR d_sz (sprintf "%s[%d]" name i) in
        let cond = W_EQ w_addr (W_CONST a_sz i) then
        W_ITE cond line (read (i-1))
    in
    letrec mk_keep i =
        i < 0 => [] |
        let line = W_VAR d_sz (sprintf "%s[%d]" name i) in
	(W_PHASE_DELAY line line):(mk_keep (i-1))
    in
    let keeper = mk_keep (lines-1) then
    let lf = P_LEAF ((W_UPDATE_FN w_out (read (lines-1))):keeper) then
    let bd =
	PINST "read" [] F [(s_addr,[s_addr])] [(s_out,[s_out])] [s_mem] lf
    then
    CELL (sprintf "draw_rom %s %d" name lines) [bd]
) addr out;


let RAM name lines {raddr:: *a} {waddr:: *a} {din:: *d} {we::bit} {out:: *d} =
    let a_sz = hw_size raddr in
    lines > 2**a_sz => eprintf "Too many lines in RAM for address size" |
    let d_sz = hw_size out in
    let mk_name base sz = sz = 1 => base | sprintf "%s[%d:0]" base (sz-1) in
    let s_mem = mk_name (sprintf "%s[%d:0]" name (lines-1)) d_sz then
    let s_raddr = mk_name "ra" a_sz in
    let s_waddr = mk_name "wa" a_sz in
    let s_we    = "we" in
    let s_din   = mk_name "din" d_sz in
    let s_out   = mk_name "out" d_sz in
    let W_raddr = W_VAR a_sz "ra" in
    let W_waddr = W_VAR a_sz "wa" in
    let W_din   = W_VAR d_sz "din" in
    let W_we    = W_VAR 1 "we" in
    let W_out   = W_VAR d_sz "out" in
    letrec read i =
        i < 0 => W_X d_sz |
        let line = W_VAR d_sz (sprintf "%s[%d]" name i) in
        let cond = W_EQ W_raddr (W_CONST a_sz i) then
        W_ITE cond line (read (i-1))
    in
    let rlf = P_LEAF [W_UPDATE_FN W_out (read (lines-1))] then
    let rd =
      PINST "read" [] F [(s_raddr,[s_raddr]),(s_mem,[s_mem])]
                    [(s_out,[s_out])] [] rlf
    then
    //
    let old =
      W_CAT (map (\i. W_VAR d_sz (sprintf "%s[%d]" name i)) ((lines-1)--0))
    then
    letrec write i =
          i < 0 => [] |
          let old = W_VAR d_sz (sprintf "%s[%d]" name i) in
          let cond = W_EQ W_waddr (W_CONST a_sz i) then
          let res = W_ITE cond W_din old then
          res:(write (i-1))
    in
    let new = W_CAT (write (lines-1)) then
    let wlf = P_LEAF [W_PHASE_DELAY old (W_ITE W_we new old)] then
    let wr =
      let inps = [(s_we,[s_we]), (s_din, [s_din]), (s_waddr,[s_waddr])] in
      PINST "write" [] F inps [(s_mem,[s_mem])] [] wlf
    then
    let pfn = sprintf "draw_ram %s %d" name lines then
    let fa_inps = [
                  (s_raddr, (get_lhs_vars (hw_destr raddr))),
                  (s_din, (get_lhs_vars (hw_destr din))),
                  (s_we, (get_lhs_vars (hw_bit_destr we))),
                  (s_waddr, (get_lhs_vars (hw_destr waddr)))
                ]
    in
    let fa_outs = [(s_out, (get_lhs_vars (hw_destr out)))] in
    PINST pfn [] T fa_inps fa_outs [s_mem] (P_HIER [rd,wr])
;

begin_abstype;

let delay_0 =
    bit_input	clk.
    input	din.
    output	dout.
    CELL "DEL(0)" [
	dout <- din
];

let delay_n N =
    bit_input	clk.
    input	din.
    output	dout.
    //
    list_internal (N-1) mids.
    //
    CELL (sprintf "DEL(%d)" N) (
	map2 (\i.\o. re_ff clk i o) (din:mids) (mids@[dout])
);

// Return a pexlif that delays a signal N clock cycles.
let delay N = N = 0 => delay_0 | delay_n N;

end_abstype delay;

begin_abstype;

let rst_delay_0 =
    bit_input	clk.
    bit_input	reset.
    input	din.
    output	dout.
    CELL "DEL(0)" [
	dout <- din
];

let rst_delay_n N =
    bit_input	clk.
    bit_input	reset.
    input	din.
    output	dout.
    //
    list_internal (N-1) mids.
    //
    CELL (sprintf "DEL(%d)" N) (
	map2 (\i.\o. re_ff_reset clk reset i o) (din:mids) (mids@[dout])
);

// Return a pexlif that delays a signal N clock cycles.
// If reset is high, then all the delayed signals are set to 0.
let rst_delay N = N = 0 => rst_delay_0 | rst_delay_n N;

end_abstype rst_delay;


let phase_delay_non_zero N =
    input   din.
    output  dout.
    list_internal (N-1)  mids.
    CELL (sprintf "phase_delay(%d)" N) (
	map2 (\i.\o. o <: i) (din:mids) (mids@[dout])
);

let phase_delay_zero =
    input   din.
    output  dout.
    CELL "phase_delay(%0)" [
	dout <- din
];

let phase_delay N =
    N = 0 => phase_delay_zero | phase_delay_non_zero N
;

let rst_phase_delay_non_zero N =
    bit_input	reset.
    input	din.
    output	dout.
    list_internal (N-1)  mids.
    CELL (sprintf "rst_phase_delay(%d)" N) (
	map2 (\i.\o. o <: (IF reset THEN '0 ELSE i)) (din:mids) (mids@[dout])
);

let rst_phase_delay_zero =
    bit_input	reset.
    input	din.
    output	dout.
    CELL "rst_phase_delay(%0)" [
	dout <- din
];

let rst_phase_delay N =
    N = 0 => rst_phase_delay_zero | rst_phase_delay_non_zero N
;

let hw__pair__type_name {p:: *a # *b} =
    let a = {undefined :: *a} in
    let b = {undefined :: *b} in
    sprintf "pair_%s_%s" (hw_type_name a) (hw_type_name b)
;

let hw__pair__is_arithmetic {p:: *a # *b} = F;

let hw__pair__size {p:: *a # *b} =
    let a = {undefined :: *a} in
    let b = {undefined :: *b} in
    i_plus (hw_size a) (hw_size b)
;

let hw__pair__destr (a,b) = W_CAT [hw_destr a, hw_destr b];

let hw__pair__constr we =
    let res = {undefined:: (*a # *b) } in
    let sz1 = hw_size {undefined:: *a} in
    let sz2 = hw_size {undefined:: *b} in
    let sz = i_plus sz1 sz2 in
    let e1 = W_SLICE ((i_minus sz 1) downto sz2) we in
    let e2 = W_SLICE ((i_minus sz2 1) downto 0) we in
    {hw_constr e1:: *a}, {hw_constr e2:: *b}
;

let hw__pair__mk_var p base =
    let sz = hw__pair__size p in
    W_VAR sz base
;

let hw__pair__values {p:: *a # *b} = "";

let hw__pair__bundle_parts {p:: *a # *b} = [], [];

let hw_pair_hw_type_destr =
	    HW_TYPE hw__pair__type_name
		    hw__pair__mk_var
		    hw__pair__is_arithmetic
		    hw__pair__size
		    hw__pair__destr
		    hw__pair__constr
		    hw__pair__values
		    hw__pair__bundle_parts
;
add_open_overload hw_type_destr hw_pair_hw_type_destr;


let hw__list__destr as = W_CAT (map hw_destr as);

let hw__list__constr (W_CAT l) = map hw_constr l
 /\ hw__list__constr (W_ITE c (W_CAT l1) (W_CAT l2)) =
	map2 (\e1.\e2. hw_constr (W_ITE c e1 e2)) l1 l2
;

let hw__list__values {p:: *a list} = "";

let hw__list__bundle_parts {p:: *a list} = [], [];

let hw_list_hw_type_destr =
	    HW_TYPE (error "Not defined for lists")
		    (error "Not defined for lists")
		    (error "Not defined for lists")
		    (error "Not defined for lists")
		    hw__list__destr
		    hw__list__constr
		    hw__list__values
		    hw__list__bundle_parts
;
add_open_overload hw_type_destr hw_list_hw_type_destr;



let INSERT =
    input   {old_vec :: *a}.
    input   new_value.
    input   addr.
    output  {out :: *a}.
    CELL "draw_INSERT" [
        let vec_sz = hw_size out in
        let val_sz = hw_size new_value in
        let addr_sz = hw_size addr in
        (vec_sz % val_sz) != 0 =>
            eprintf "Out size %d not a multiple of value size %d in REPLACE\n"
                    vec_sz val_sz
        |
        let lines = vec_sz / val_sz in
        lines > 2**addr_sz => 
            eprintf "Too many lines (%d) in REPLACE for address size (%d)"
                    lines addr_sz
        |
        let vs = tobits new_value in
        let ovs = tobits old_vec in
        let mk i =
            let msb = vec_sz - ((i+1)*val_sz-1) in
            let lsb = vec_sz - i*val_sz in
            let old = gather ovs (msb--lsb) in
            IF (addr '=' ''i) THEN vs ELSE old
        in
        out <- frombits (flatmap mk ((lines-1) -- 0))
];





let posedge clk = (T,clk);
let negedge clk = (F,clk);

let always_ff gclk assignments =
    val (rising,clk) = gclk in
    let mk (lhs,rhs) =
        rising => re_ff clk rhs lhs | fe_ff clk rhs lhs
    in
    let ffs = map mk assignments then
    let get_outs (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_outs in
    let raw_outs = setify (md_expand_vectors (flatmap get_outs ffs)) then
    let get_inps (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_inps then
    let raw_inps = setify (md_expand_vectors (flatmap get_inps ffs)) then
    let outs = md_extract_vectors raw_outs then
    let inps = md_extract_vectors (raw_inps subtract raw_outs) then
    let mk_fa v = (v,[v]) in
    PINST "always_ff" [] F (map mk_fa inps) (map mk_fa outs) [] (P_HIER ffs)
;

let <== {lhs:: *a} {rhs:: *a} = (lhs,rhs);
infix 1 <==;

// A function that helps in declaring internal signals
// Use:
//    find_free_vars [:  expr :];
let find_free_vars expr =
   letrec findfree bound (APPLY e1 e2) =
        (findfree bound e1) union (findfree bound e2)
     /\   findfree bound (VAR s) =
          mem s bound => [] |
          is_defined s => [] | [s]
     /\   findfree bound (LAMBDA v e) =
            findfree (v:bound) e
     /\   findfree bound (CONS e1 e2) =
        (findfree bound e1) union (findfree bound e2)
     /\   findfree bound other = []
    in
    let free = findfree [] expr then
    print (list2str T "" "\n" "\n" (sprintf "    internal  %s.") (setify free))
;

// Expression for bitwise OR-ing together a list of signals.
let OR_n l =
    l = [] => '0 |
    accumulate (defix '|') l
;

// Expression for bitwise AND-ing together a list of signals.
let AND_n l =
    l = [] => '1 |
    accumulate (defix '&') l
;

// Expression for bitwise XOR-ing together a list of signals.
let XOR_n l =
    l = [] => error "XOR_n for empty list" |
    accumulate (defix '^') l
;


// User contribution: flip-flops that wish they were latches.
// Flip-flops with bypass muxes.

// A rising edge D flip-flop with enable and bypass mux.
let re_ff_en_mux =
    bit_input	clk.
    bit_input	en.
    input	d.
    output	q.
    internal    qtmp.
    CELL "draw_hier re_ff_en_mux" [
	re_ff_en clk en d qtmp,
        q <- (IF en THEN d ELSE qtmp)
];

// A rising edge D flip-flop with enable and asynchronous reset (active high) and bypass mux.
let re_ff_en_reset_mux =
    bit_input	clk.
    bit_input	en.
    bit_input	reset.
    input	d.
    output	q.
    internal    qtmp.
    CELL "draw_hier re_ff_en_reset_mux" [
	re_ff_en_reset clk en reset d qtmp,
        q <- (IF (en '&' ('~' reset)) THEN d ELSE qtmp)
];

// A rising edge D flip-flop with enable and synchronous reset (active high) and bypass mux.
let re_ff_en_sreset_mux =
    bit_input	clk.
    bit_input	en.
    bit_input	reset.
    input	d.
    output	q.
    internal    qtmp.
    // Should use different drawing symbol....
    CELL "draw_hier re_ff_en_reset_mux" [
	re_ff_en_sreset clk en reset d qtmp,
        q <- (IF (en '&' ('~' reset)) THEN d ELSE qtmp)
];


let is_HIER (P_HIER _) = T
 /\ is_HIER other = F
;

let is_wrapper_or_empty (PINST nm _ _ _ _ _ _) =
    (nm = "_WrApPeR_") OR (nm = "")
;

let remove_wrappers p =
    letrec clean p =
        val (PINST name attrs leaf fa_inps fa_outs ints cont) = p in
        NOT (is_HIER cont) => p |
        val (P_HIER chs) = cont in
        let chs' = map clean chs in
        let p' = (chs == chs') => p |
                    (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs'))
        in
        letrec cl1 p =
            val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
            let idx = find_first0 is_wrapper_or_empty chs in
            idx = 0 => p |
            let p' = unfold_pexlif p idx then
            cl1 p'
        in
        cl1 p'
    in
    clean p
;

let ` typed_result = hw_destr typed_result;


let pexlif_compile_dir = ref {(error "No pexlif cache directory"):: string};

let set_pexlif_cache dir =
    (file_exists dir => () |
	let cmd = sprintf "mkdir -p %s" dir then
	system cmd != 0 =>
	    eprintf "Cannot create pexlif cache directory (%s)" dir
	|
	()
    ) fseq
    (pexlif_compile_dir := dir);
;

set_pexlif_cache (sprintf "/tmp/%s/Pexlif_Cache" USER);

let mk_fas_for_simple_actuals name e =
    let sz = hw_size e in
    let var2name (W_VAR s b) = [mk_name s b]
     /\ var2name (W_EXPLICIT_VAR s b) = [b]
     /\ var2name other = []
    in
    (mk_name sz name), (var2name (hw_destr e))
;

let only_simple conns = (find_first0 (\(f,as). as = []) conns) = 0;

clet pcompile_read_pexlif fn pexlif_file =
    (fprintf stdinfo "-- Loading pre-compiled version of %s--\n" fn) fseq
    read_pexlif pexlif_file
;

let pcompile fn =
    let pdir = (deref pexlif_compile_dir) in
    // Make sure it is a pexlif generating function with simple hw-types inputs
    let rtype = get_return_type fn then
    rtype != "pexlif" =>
	(fprintf stderr "Return type not pexlif (%s). pcompile aborted\n" rtype)
	fseq ()
    |
    let args = get_args fn then
    let idx = find_first0 (\(a,tp). NOT (is_hw_type tp)) args in
    idx != 0 =>
	val (arg,tp) = el idx args in
	(fprintf stderr
	     "Argument %s not a simple hw_type (%s). pcompile for %s aborted\n"
	      arg tp fn
	) fseq ()
    |
    // Now re-define the function to load/store a compiled version
    let mk_top_arg (nm,tp) = sprintf "{%s :: %s}" nm tp in
    let top = list2str T (sprintf "let %s " fn) " " " =\n" mk_top_arg args in
    let mid1 =
      (sprintf "\tlet sig = get_symbol_signature \"%s\" in\n" fn)^
      (sprintf "\tlet pdir = (deref pexlif_compile_dir) in\n")^
      (sprintf "\tlet pexlif_file = sprintf \"%%s/%%s.pexlif\" pdir sig in\n")^
      (sprintf "\tlet exists = file_exists pexlif_file in\n")
    in
    let mk_conn (nm,tp) = sprintf "mk_fas_for_simple_actuals \"%s\" %s" nm nm in
    let mid2 =
	list2str T "\tlet conns = [\n\t\t" ",\n\t\t" "]\n\tin\n" mk_conn args
    in
    let case1 =
	let pre =
	  (sprintf "\tNOT (only_simple conns) =>\n")^
	  (sprintf "\t    (fprintf stdinfo \"-- Building %s--\\n\") fseq\n" fn)^
	  (sprintf "\t    %s " fn)
	in
	let mk_arg (nm,tp) = nm in
	list2str T pre " " "\n\t|\n" mk_arg args
    in
    let case2 = 
      (sprintf "\texists =>\n")^
      (sprintf "\t  val (PINST nm attrs lf fa_inps fa_outs ints body) =\n")^
      (sprintf "\t       pcompile_read_pexlif \"%s\" pexlif_file\n" fn)^
      (sprintf "\t  then\n")^
      (sprintf "\t  let fa_inps' = map (\\(f,as). f, assoc f conns) fa_inps in\n")^
      (sprintf "\t  let fa_outs' = map (\\(f,as). f, assoc f conns) fa_outs in\n")^
      (sprintf "\t  (PINST nm attrs lf fa_inps' fa_outs' ints body)\n")^
      (sprintf "\t|\n")
    in
    let case3 =
      let pre =
        (sprintf "\t  (fprintf stdinfo \"-- Compiling %s--\\n\") fseq\n" fn)^
        (sprintf "\t  let p = %s " fn)
      in
      let mk (nm,tp) = sprintf "'%s" nm in
      (list2str T pre " " " then\n" mk args)^
      (sprintf "\t  (write_pexlif pexlif_file p) fseq\n")^
      (sprintf "\t  val (PINST nm attrs lf fa_inps fa_outs ints body) = p in\n")^
      (sprintf "\t  let fa_inps' = map (\\(f,as). f, assoc f conns) fa_inps in\n")^
      (sprintf "\t  let fa_outs' = map (\\(f,as). f, assoc f conns) fa_outs in\n")^
      (sprintf "\t  (PINST nm attrs lf fa_inps' fa_outs' ints body)\n")
    in
    let cmd = top^mid1^mid2^case1^case2^case3^";\n" in
    (eval cmd) fseq ()
;
free_binder pcompile;


let _pExLiF_ = ref {(error "No pexlif") :: pexlif};

let flfun2pexlif_core fn =
    let rtype = get_return_type fn then
    rtype != "pexlif" =>
	eprintf "Return type not pexlif (%s). VIS aborted\n" rtype
    |
    let args = get_args fn then
    let idx = find_first0 (\(a,tp). NOT (is_hw_type tp)) args in
    idx != 0 =>
	val (arg,tp) = el idx args in
	eprintf "Argument %s not a simple hw_type (%s). VIS for %s aborted\n"
	      arg tp fn
    |
    let pre = sprintf "let foo = %s " fn in
    let post = " then (_pExLiF_ := foo);" in
    let cmd = list2str T pre " " post (sprintf "'%s") (map fst args) then
    (eval cmd) fseq (deref _pExLiF_)
;

let flfun2pexlif fn = flfun2pexlif_core fn;
free_binder flfun2pexlif;

let ASSERT {name::string} {expr::bit} =
    let oa = ord "a" in
    let oz = ord "z" in
    let oA = ord "A" in
    let oZ = ord "Z" in
    let o0 = ord "0" in
    let o9 = ord "9" in
    let tr c =
	let o = ord c in
	oa <= o AND o <= oz => c |
	oA <= o AND o <= oZ => c |
	o0 <= o AND o <= o9 => c |
	"_"
    in
    let clean_name = implode (map tr (explode name)) in
    let assert_wire = sprintf "assert__%s" clean_name then
    let name' = sprintf "{%s}" name then
    let pred = hw_bit_constr (W_PRED name' (hw_destr expr)) then
    let lhs = hw_bit_constr (W_VAR 1 assert_wire) in
    lhs <- pred
;

// Create a balanced tree of 'op' functions.
// op needs to be of type *a->*a->*a.
letrec reduce_tree op =
    list_input  il.
    output      o.
    internal    m1 m2.
    CELL "draw_hier reduce_tree" (
        let l = length il in
        l = 1 => [o <- (hd il)] |
        let high = firstn (l/2) il in
        let low  = butfirstn (l/2) il in
	[
            reduce_tree op high m1,
            reduce_tree op low m2,
            o <- op m1 m2
	]
);

let ::: lbl p =
    val (PINST nm attrs lf fa_inps fa_outs ints body) = p in
    let attrs' = attrs@[("Label", lbl)] in
    (PINST nm attrs' lf fa_inps fa_outs ints body)
;
infixr 0 :::;

// Connect a pexlif inside an Hfl CELL
// The connections are a list of (act,wva) where
//	act is a vector name for an actual connection in p and
//	wva is a wexpr denoting the pin/vector in the CELL to connect to.
// Example:
//
// If p has actual input names "a[7:0]", "b[7:0]", and
// outputs "o[7:0]" and "cout" and "word" is a HW type of size 8,
// then one might do:
//
//   let top =
//	word_input  x y z.
//	word_output res.
//	bit_output  cout.
//	word_internal mid.
//	CELL "top" [
//	    connect p [("a[7:0]", `x),("b[7:0]", `mid),("o[7:0]", `res)],
//	    mid <- y '-' z
//  ];
//
//  Note that "cout" did not need a connection since it has the same name
//  and size in the CELL as in the pexlif. 
//
let connect p conns =
    let sub = flatmap (\(v,w). vec_zip [v] (get_lhs_vars w)) conns then
    val (PINST name attrs lf fa_inps fa_outs ints body) = p in
    let tr (f,as) =
        let as' = flatmap (\v. (vec_assoc v sub) catch [v]) as then
        (f, as')
    in
    let fa_inps' = map tr fa_inps then
    let fa_outs' = map tr fa_outs then
    (PINST name attrs lf fa_inps' fa_outs' ints body)
;

