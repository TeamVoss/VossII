(cload (DIR^"../../../../vosslib/vector_names.fl")) fseq ();
fprintf stdinfo ".";

//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

let get_number_of_children (PINST _ _ _ _ _ _ (P_HIER chs)) =
    length chs
 /\ get_number_of_children other = 0
;

let special_md_size v =
    str_is_substr "[-1:0]" v => 0 |
    md_size v
;

let special_md_sizes vs =
    md_sizes (filter (\v. NOT (str_is_substr "[-1:0]" v)) vs)
;

let special_md_extract_vectors vs =
    val (special, other) = split (str_is_substr "[-1:0]") vs in
    (setify special)@(md_extract_vectors other)
;

// Determines if the pexlif p contains any state holding element.
let has_state p =
    letrec has_state (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) =
	(find_first0 has_state cs) != 0
     /\ has_state (PINST name attrs lf fa_inps fa_outs ints (P_LEAF fs)) =
	let is_state (W_PHASE_DELAY lhs rhs) = T
	 /\ is_state _ = F
	in
	(find_first0 is_state fs) != 0
    in
    has_state p
;

// Create a (potential vector) name given size and base.
let mk_name sz base = sz = 1 => base | sprintf "%s[%d:0]" base (sz-1);

// Function to determine if a node is a user given or automatically created.
let is_user_given s = NOT (str_is_substr "_$" s);


clet get_base_name s = 
    (
	let l = str_reg_extract "(.*)(\\[[-0-9:]+\\])$" s in
	el 2 l
    ) catch s
;

// todo: Pexlif's generated randomly doesn't follow this name schema.

// A type to represent continous bit ranges
// and individual index bits
lettype bit_range = BR_SINGLE int | BR_SLICE {msb::int} {lsb::int};

// The size (in bits) of a bit range
let bit_range_size (BR_SINGLE _) = 1
 /\ bit_range_size (BR_SLICE msb lsb) = msb - lsb + 1;

// Checks if a bit range contains a specific value
let bit_range_contains (BR_SINGLE i) j = i == j
 /\ bit_range_contains (BR_SLICE msb lsb) j =
	msb > lsb
		=> (msb >= j AND j >= lsb)
		|  (lsb >= j AND j >= msb);

// least significant bit position of a bit range
let bit_range_lsb (BR_SINGLE i) = i
 /\ bit_range_lsb (BR_SLICE _ lsb) = lsb;

// least significant bit position of a bit range
let bit_range_msb (BR_SINGLE i) = i
 /\ bit_range_msb (BR_SLICE msb _) = msb;

// Prints a bit range to a string
// format: "nb" or "msb:lsb"
let sprint_bit_range (BR_SINGLE i) = int2str i
 /\ sprint_bit_range (BR_SLICE msb lsb) = sprintf "%d:%d" msb lsb;

// Groups indices into continous slices
// Input: non-empty list of ints in decreasing order
// Outputs list grouping continuous slices
// Ex: [5,4,3,0] -> [BR_SLICE 5 3, BR_SINGLE 0]
let group_indices indices =
	letrec merge msb cur (idx:rem) =
		idx = cur-1 => merge msb idx rem |
		msb > cur => (BR_SLICE msb cur):(merge idx idx rem)
		          |  (BR_SINGLE msb):(merge idx idx rem)
	   /\  merge msb cur [] =
		msb > cur => [BR_SLICE msb cur] | [BR_SINGLE msb]
	in
	let i0 = hd indices in
	merge i0 i0 (tl indices)
;

// Groups indices by continous ranges and
// prints the results
let pr_indices indices =
	let ranges = group_indices indices in
    list2str T "[" "," "]" sprint_bit_range ranges
;


let update_fn_get_lhs (W_UPDATE_FN lhs rhs) = lhs
 /\ update_fn_get_lhs (W_PHASE_DELAY lhs rhs) = lhs
;
let update_fn_get_rhs (W_UPDATE_FN lhs rhs) = rhs
 /\ update_fn_get_rhs (W_PHASE_DELAY lhs rhs) = rhs
;

let Pupdate_fn (W_UPDATE_FN lhs rhs) =
    sprintf "%s <- %s" (Pwexpr lhs) (Pwexpr rhs)
 /\ Pupdate_fn (W_PHASE_DELAY lhs rhs) =
    sprintf "%s <: %s" (Pwexpr lhs) (Pwexpr rhs)
;
install_print_function Pupdate_fn;


let pexlif_get_name (PINST name attrs leaf fa_inps fa_outs ints cont) = name;
let pexlif_get_attrs (PINST name attrs leaf fa_inps fa_outs ints cont) = attrs;
let pexlif_get_leaf (PINST name attrs leaf fa_inps fa_outs ints cont) = leaf;
let pexlif_get_fa_inps (PINST name attrs leaf fa_inps fa_outs ints cont) = fa_inps;
let pexlif_get_fa_outs (PINST name attrs leaf fa_inps fa_outs ints cont) = fa_outs;
let pexlif_get_internals (PINST name attrs leaf fa_inps fa_outs ints cont) = ints;
let pexlif_get_content (PINST name attrs leaf fa_inps fa_outs ints cont) = cont;
let content_get_children (P_HIER children) = children;
let content_get_leaf (P_LEAF fns) = fns;

letrec prim_Ppexlif ind fp (inst,pexlif) =
    val (PINST name attrs leaf inps outs ints body) = pexlif then
    (fprintf fp "%s:\n%*s(PINST \"%s\" " inst ind "" name) fseq

    let pattr a v = ((a == "FP") OR (a == "SHA")) AND (strlen v > 6)
	    => (substr v 1 4) ^ ".." | v
    in
    (list2fp fp T "[" "," "]" (\fp.\(a,v). fprintf fp "%s->%s" a (pattr a v))
	     attrs)
    fseq
    (fprintf fp " %s\n" (leaf => "T" | "F"))
    fseq
    let sinp  = list2str T "[" "," "]" (\(f,a). sprintf "(%s,%S)" f a) inps in
    (fprintf fp "%*s  %s\n" ind "" sinp) fseq
    let sout  = list2str T "[" "," "]" (\(f,a). sprintf "(%s,%S)" f a) outs in
    (fprintf fp "%*s  %s\n" ind "" sout) fseq
    let sints = list2str T "[" "," "]" id ints then
    (fprintf fp "%*s  %s\n" ind "" sints) fseq
    let prim_Pcontent ind fp (P_HIER children) =
	letrec pp cnt (ch:chs) =
	    let inst' = sprintf "%si%d/" inst cnt in
	    (prim_Ppexlif (ind+3) fp (inst', ch)) fseq
	    (pp (cnt+1) chs)
	 /\    pp cnt [] = ()
	in
	pp 1 children
     /\ prim_Pcontent ind fp (P_LEAF fns) =
	(fprintf fp "%*s LEAF [\n" ind "") fseq
	let pr ufn = fprintf fp "%*s%s\n" (ind+3) "" (Pupdate_fn ufn) in
	(foreach pr fns) fseq
	(fprintf fp "%*s ]\n" ind "")
    in
    (prim_Pcontent (ind+1) fp body) fseq
    (fprintf fp "%*s)\n" ind "")
;

let Ppexlif fp pexlif = prim_Ppexlif 0 fp ("",pexlif);

let pretty_pexlif p = (Ppexlif stdout p) fseq "";
install_print_function pretty_pexlif;

let Emit_pexlif file pexlif =
    let fp = fopen file "w" then
    (prim_Ppexlif 0 fp ("",pexlif)) fseq
    (fclose fp) fseq
    (printf "Saved ASCI version of pexlif in %s\n" file)
;

let E_update_fn fp (W_UPDATE_FN lhs rhs) =
    fprintf fp "(W_UPDATE_FN %s %s)" (DBGwexpr lhs) (DBGwexpr rhs)
 /\ E_update_fn fp (W_PHASE_DELAY lhs rhs) =
    fprintf fp "(W_PHASE_DELAY %s %s)" (DBGwexpr lhs) (DBGwexpr rhs)
;


letrec E_print_pexlif depth ind fp pexlif =
    let safe v =
	let tr c = c = "\"" => "\\\"" | c in
	implode (map tr (explode v))
    in
    val (PINST name attrs leaf inps outs ints body) = pexlif then
    let sattrs = list2str T "[" "," "]"
            (\(a,v). sprintf "(\"%s\",\"%s\")" a (safe v)) attrs
    in
    let sleaf = leaf => "T" | "F" then
    (fprintf fp "\n%*s(PINST \"%s\" %s %s\n" ind "" name sattrs sleaf)
    fseq
    let sinp  = list2str T "[" "," "]"
		    (\(f,a). sprintf "(\"%s\",%S)" f (map (sprintf "\"%s\"") a))
		    inps
    in
    (fprintf fp "%*s  %s\n" ind "" sinp) fseq
    let sout  = list2str T "[" "," "]"
		    (\(f,a). sprintf "(\"%s\",%S)" f (map (sprintf "\"%s\"") a))
		    outs
    in
    (fprintf fp "%*s  %s\n" ind "" sout) fseq
    let sints = list2str T "[" "," "]" (sprintf "\"%s\"") ints then
    (fprintf fp "%*s  %s\n" ind "" sints) fseq
    let p_content ind fp (P_HIER children) =
	let p1 fp p = E_print_pexlif (depth-1) (ind+3) fp p in
	list2fp fp T "(P_HIER [" "," "])\n" p1 children
     /\ p_content ind fp (P_LEAF fns) =
	list2fp fp T "(P_LEAF [" ", " "])\n" E_update_fn fns
    in
    (depth <= 0 => fprintf fp "%*s...\n" ind "" | p_content (ind+1) fp body) fseq
    (fprintf fp "%*s)\n" ind "")
;

// Same as Emit_pexlif except that the text can be loaded into fl
// to create the saved pexlif.
let Emit_ASCII_pexlif file pexlif =
    let fp = fopen file "w" then
    (E_print_pexlif 100000000 0 fp pexlif) fseq
    (fclose fp) fseq
    (printf "Saved ASCI version of pexlif in %s\n" file)
;

// Emit a detailed version of pexlif to file but limited to
// max_depth deeply nested instance.
let limited_Emit_ASCII_pexlif file pexlif max_depth =
    let fp = fopen file "w" then
    (E_print_pexlif max_depth 0 fp pexlif) fseq
    (fclose fp) fseq
    (printf "Saved ASCI version of pexlif in %s\n" file)
;

let base_get_lhs_vars we =
    letrec gen_get_names (W_VAR sz b) = sz = 1 => [b] | [(mk_name sz b)]
     /\    gen_get_names (W_EXPLICIT_VAR sz b) = [b]
     /\	   gen_get_names (W_SLICE indices (W_VAR sz b)) =
	    merge_vectors [list2str T (b^"[") "," "]" int2str indices]
     /\	   gen_get_names (W_NAMED_SLICE name indices (W_VAR sz b)) =
	    merge_vectors [list2str T (b^"[") "," "]" int2str indices]
     /\	   gen_get_names (W_SLICE indices w) =
	let l = md_expand_vectors (gen_get_names w) then
	let sz = length l then
	md_merge_vectors (map (\idx. el (sz-idx) l) indices)
     /\	   gen_get_names (W_NAMED_SLICE name indices w) =
	let l = md_expand_vectors (gen_get_names w) then
	let sz = length l then
	md_merge_vectors (map (\idx. el (sz-idx) l) indices)
     /\    gen_get_names (W_CAT parts) =
	    flat (map gen_get_names parts)
     /\    gen_get_names other =
	eprintf "Illegal lhs expression\n(%s)" (Pwexpr other)
    in
    gen_get_names we
;

let get_lhs_vars we = (base_get_lhs_vars we);

let valid_lhs we =
    letrec rec_ok (W_VAR sz b) = T
     /\    rec_ok (W_EXPLICIT_VAR sz b) = T
     /\    rec_ok (W_SLICE indices w) = rec_ok w
     /\    rec_ok (W_NAMED_SLICE name indices w) = rec_ok w
     /\    rec_ok (W_CAT parts) = itlist (\w.\r. rec_ok w AND r) parts T
     /\    rec_ok other = F
    in
    rec_ok we
;

clet cexpand_vectors vl =
    let exp1 v =
	str_is_prefix "0b" v => tl (tl (explode v)) | md_expand_vector v
    in
    flatmap exp1 vl
;

clet cmerge_vectors nl =
    letrec merge_consts cur (v:vs) =
	v = "0" => merge_consts (cur^"0") vs |
	v = "1" => merge_consts (cur^"1") vs |
	v = "x" => merge_consts (cur^"x") vs |
	cur != "" => cur:v:(merge_consts "" vs) | v:(merge_consts "" vs)
     /\    merge_consts cur [] = cur = "" => [] | [cur]
    in
    merge_vectors (merge_consts "" nl)
;

let w_get_names we =
    let raw_res = ref [] then
    letrec dep (W_X sz) = ()
     /\    dep (W_NAMED_CONST name sz v) = ()
     /\    dep (W_CONST sz v) = ()
     /\    dep (W_VAR sz b) = (raw_res := ((mk_name sz b):(deref raw_res)))
     /\    dep (W_EXPLICIT_VAR sz n) = (raw_res := (n:(deref raw_res)))
     /\    dep (W_AND a b) = (dep a) fseq (dep b)
     /\    dep (W_LAT_LEQ a b) = (dep a) fseq (dep b)
     /\    dep (W_OR  a b) = (dep a) fseq (dep b)
     /\    dep (W_PRED name cond) = (dep cond)
     /\    dep (W_EQ  a b) = (dep a) fseq (dep b)
     /\    dep (W_GR  a b) = (dep a) fseq (dep b)
     /\    dep (W_ADD a b) = (dep a) fseq (dep b)
     /\    dep (W_SUB a b) = (dep a) fseq (dep b)
     /\    dep (W_MUL a b) = (dep a) fseq (dep b)
     /\    dep (W_DIV a b) = (dep a) fseq (dep b)
     /\    dep (W_MOD a b) = (dep a) fseq (dep b)
     /\    dep (W_SHL a b) = (dep a) fseq (dep b)
     /\    dep (W_SHR a b) = (dep a) fseq (dep b)
     /\    dep (W_ASHR a b) = (dep a) fseq (dep b)
     /\    dep (W_SX sz w) = (dep w)
     /\    dep (W_ZX sz w) = (dep w)
     /\    dep (W_NOT a)   = dep a
     /\    dep (W_ITE c t e) = (dep c) fseq (dep t) fseq (dep e)
     /\    dep (W_SLICE indices w) = dep w
     /\    dep (W_NAMED_SLICE name indices w) = dep w
     /\    dep (W_UPDATE_NAMED_SLICE b name indices w) = (dep b) fseq (dep w)
     /\    dep (W_CAT parts) = foreach dep parts
     /\    dep (W_IDELAY sz rise fall cur delayed_inps) =
		(dep cur) fseq (foreach dep delayed_inps)
     /\    dep (W_MEM_READ info mem addr) = (dep mem) fseq (dep addr)
     /\    dep (W_MEM_WRITE info mem addr data) =
            (dep mem) fseq (dep addr) fseq (dep data)
    in
    (dep we) fseq setify (rev (deref raw_res))
;

let w_depends we =
    let res1 = w_get_names we then
    let res2 = extract_vectors res1 then
    length res1 = length res2 => res1 | qsort node_name_cmp res2
;

cletrec wexpr_size wexpr =
    let get_size2 a b =
	let a_sz = wexpr_size a in
	let b_sz = wexpr_size b in
	a_sz != b_sz =>
	    eprintf "Size mismatch in wexpr expression\n%d=|%s|\n%d=|%s|)"
		    a_sz (Pwexpr a) b_sz (Pwexpr b)
	|
	a_sz
    in
    let wsz (W_X sz) = sz
     /\ wsz (W_CONST sz v) = sz
     /\ wsz (W_NAMED_CONST name sz v) = sz
     /\ wsz (W_VAR sz b) = sz
     /\ wsz (W_EXPLICIT_VAR sz b) = sz
     /\ wsz (W_AND a b) = get_size2 a b
     /\ wsz (W_LAT_LEQ a b) = get_size2 a b
     /\ wsz (W_OR a b) = get_size2 a b
     /\ wsz (W_NOT a) = wexpr_size a
     /\ wsz (W_PRED name cond) = 1
     /\ wsz (W_EQ a b) =
	let a_sz = wexpr_size a in
	let b_sz = wexpr_size b in
	a_sz != b_sz =>
	    eprintf "Size mismatch in W_EQ\n%d=|%s|\n%d=|%s|)"
		    a_sz (Pwexpr a) b_sz (Pwexpr b)
	| 1
     /\ wsz (W_GR a b) =
	let a_sz = wexpr_size a in
	let b_sz = wexpr_size b in
	a_sz != b_sz =>
	    eprintf "Size mismatch in W_GR\n%d=|%s|\n%d=|%s|)"
		    a_sz (Pwexpr a) b_sz (Pwexpr b)
	| 1
     /\ wsz (W_ADD a b)  = get_size2 a b
     /\ wsz (W_SUB a b)  = get_size2 a b
     /\ wsz (W_MUL a b)  = get_size2 a b
     /\ wsz (W_DIV a b)  = get_size2 a b
     /\ wsz (W_MOD a b)  = get_size2 a b
     /\ wsz (W_SHL a b)  = get_size2 a b
     /\ wsz (W_SHR a b)  = get_size2 a b
     /\ wsz (W_ASHR a b) = get_size2 a b
     /\ wsz (W_SX sz w)  = sz
     /\ wsz (W_ZX sz w)  = sz
     /\ wsz (W_ITE c a b) =
	wexpr_size c != 1 => eprintf "Condition in W_ITE not of size 1!" |
	get_size2 a b
     /\ wsz (W_SLICE indices w) = length indices
     /\ wsz (W_NAMED_SLICE name indices w) = length indices
     /\ wsz (W_UPDATE_NAMED_SLICE base name indices w) = wexpr_size base
     /\ wsz (W_CAT wl) = itlist (\w.\r. wexpr_size w + r) wl 0
     /\ wsz (W_IDELAY sz rise fall cur delayed_inps) = sz
     /\ wsz (W_MEM_READ info mem addr) =
	val (MEM a_sz lines d_sz) = info in
	d_sz
     /\ wsz (W_MEM_WRITE info mem addr d) = wexpr_size mem
    in
    wsz wexpr
;

let wexpr_sizes as = sitlist (defix +) (map wexpr_size as) 0;

let check_memory a_sz lines d_sz addr mem =
	let mem_sz = wexpr_size mem in
	let addr_sz = wexpr_size addr in
	addr_sz != a_sz =>
	    eprintf "Memory address of incorrect size (%d!=%d)" addr_sz a_sz
	|
	(mem_sz % d_sz != 0) =>
	    eprintf "Memory size (%d) not multiple of word size (%d)"
		    mem_sz d_sz
	|
	(mem_sz / d_sz) != lines =>
	    eprintf "Memory size %d not same as declaration %d"
		    (mem_sz/d_sz) lines
	|
	let n = ubits_needed (lines-1) in
	a_sz < n =>
	    eprintf "Write address too small for memory (%d<%d)" a_sz n
	|
	()
;


letrec wexpr_is_binary (W_X sz) = F
 /\     wexpr_is_binary (W_NAMED_CONST name sz v) = T
 /\     wexpr_is_binary (W_CONST sz v) = T
 /\     wexpr_is_binary (W_VAR sz b) = T
 /\     wexpr_is_binary (W_EXPLICIT_VAR sz n) = T
 /\     wexpr_is_binary (W_AND a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_LAT_LEQ a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_OR a b) = (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_NOT a) = (wexpr_is_binary a)
 /\     wexpr_is_binary (W_PRED name cond) = wexpr_is_binary cond
 /\     wexpr_is_binary (W_EQ a b) = (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_GR a b) = (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_ADD a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_SUB a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_MUL a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_DIV a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_MOD a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_SHL a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_SHR a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_ASHR a b) =
	    (wexpr_is_binary a) AND (wexpr_is_binary b)
 /\     wexpr_is_binary (W_SX sz w) = wexpr_is_binary w
 /\     wexpr_is_binary (W_ZX sz w) = wexpr_is_binary w
 /\     wexpr_is_binary (W_ITE c t e) =
	    wexpr_is_binary c AND wexpr_is_binary t AND wexpr_is_binary e
 /\     wexpr_is_binary (W_SLICE indices w) = wexpr_is_binary w
 /\     wexpr_is_binary (W_NAMED_SLICE name indices w) = wexpr_is_binary w
 /\     wexpr_is_binary (W_UPDATE_NAMED_SLICE base name indices w) =
	    wexpr_is_binary base AND wexpr_is_binary w
 /\     wexpr_is_binary (W_CAT wl) =
	    itlist (\w.\l. (wexpr_is_binary w) AND l) wl T
 /\     wexpr_is_binary (W_IDELAY sz rise fall cur dinps) =
	    itlist (\w.\l. wexpr_is_binary w AND l) dinps (wexpr_is_binary cur)
 /\     wexpr_is_binary (W_MEM_READ info mem addr) =
	    wexpr_is_binary mem AND wexpr_is_binary addr
 /\     wexpr_is_binary (W_MEM_WRITE info mem addr d) =
	    wexpr_is_binary mem AND wexpr_is_binary addr AND wexpr_is_binary d
;

let x_var_cnt = ref 0;

let mk_xvars sz =
    let idx = deref x_var_cnt then
    (x_var_cnt := (idx+1)) fseq
    let base = sprintf "#Xvar%d" idx then
    bv_variable (mk_name sz base)
;

letrec w2bv sub w =
    let bv_trim bits b = bv_mod b (int2bv (2**bits)) in
    let bin_op op a b =
	let sza = wexpr_size a in
	let szb = wexpr_size a in
	sza != szb => eprintf "Size mismatch (%d != %d)" sza szb |
	bv_trim sza (op (w2bv sub a) (w2bv sub b))
    in
    let w2bl w =
	let sz = wexpr_size w in
	let base = bv2list (w2bv sub w) in
	lastn sz ((replicate sz (hd base))@base)
    in
    let w2bv (W_NAMED_CONST name sz v) = int2bv v
     /\ w2bv (W_X sz) =
		// Generate new unique BDD variables for X's
		// A bit of a hack, but there is no clean solution to this
		// that I can think of. The rigth answer would probably have
		// a wexpr2dualrail but that's pretty cumbersome too
		mk_xvars sz
     /\ w2bv (W_CONST sz v) = int2bv v
     /\ w2bv (W_VAR sz b) = substitute sub (bv_variable (mk_name sz b))
     /\ w2bv (W_EXPLICIT_VAR sz n) = substitute sub (bv_variable n)
     /\ w2bv (W_AND a b) = bv_AND (w2bv sub a) (w2bv sub b)
     /\ w2bv (W_LAT_LEQ a b) = error "W_LAT_LEQ cannot be converted"
     /\ w2bv (W_IDELAY sz _ _ _ _) = error "W_IDELAY cannot be converted"
     /\ w2bv (W_OR a b) = bv_OR (w2bv sub a) (w2bv sub b)
     /\ w2bv (W_NOT a) = bv_NOT (w2bv sub a)
     /\ w2bv (W_PRED name cond) = w2bv sub cond
     /\ w2bv (W_EQ a b) =
	    (bv_eq (w2bv sub a) (w2bv sub b)) => (int2bv (-1)) | (int2bv 0)
     /\ w2bv (W_GR a b) =
	    (bv_greater (w2bv sub a) (w2bv sub b)) => (int2bv (-1)) | (int2bv 0)
     /\ w2bv (W_ADD a b) = bin_op bv_add a b
     /\ w2bv (W_SUB a b) = bin_op bv_sub a b
     /\ w2bv (W_MUL a b) = bin_op bv_mul a b
     /\ w2bv (W_DIV a b) = bin_op bv_div a b
     /\ w2bv (W_MOD a b) = bin_op bv_mod a b
     /\ w2bv (W_SHL a b) = bin_op bv_shl a b
     /\ w2bv (W_SHR a b) = bin_op bv_shr a b
     /\ w2bv (W_ASHR a b) = bin_op bv_ashr a b
     /\ w2bv (W_SX sz w) = w2bv sub w
     /\ w2bv (W_ZX sz w) = bv_ZX (w2bv sub w)
     /\ w2bv (W_ITE c t e) =
	    (w2bv sub c) = (int2bv (-1)) => (w2bv sub t) | (w2bv sub e)
     /\ w2bv (W_SLICE indices w) =
		let sz = wexpr_size w in
		(list2bv (F:(map (\idx. el (sz-idx) (w2bl w)) indices)))
     /\ w2bv (W_NAMED_SLICE name indices w) =
		let sz = wexpr_size w in
		(list2bv (F:(map (\idx. el (sz-idx) (w2bl w)) indices)))
     /\ w2bv (W_UPDATE_NAMED_SLICE old name indices new) =
		let old_bv = w2bl old in
		let new_bv = w2bl new in
		let sz = length old_bv in
		let new_map = zip indices ((length indices-1) downto 0) in
		let get_el idx l = el (length l - idx) l in
		let mk_part inside f t =
		    inside =>
			let sels = map (\i.assoc i new_map) (f downto t) in
			map (\i. get_el i new_bv) sels
		    |
			map (\i. get_el i old_bv) (f downto t)
		in
		letrec collect inside f cur (idx:idxs) =
		    let new_inside = mem idx indices then
		    (new_inside = inside) => collect inside f idx idxs |
		    // Switching from inside to outside or vice versa
		    let part = mk_part inside f cur in
		    part@(collect new_inside idx idx idxs)
		  /\   collect inside f cur [] =
		    let part = mk_part inside f cur in
		    part
		in
		let start = sz-1 in
		let r =
		    collect (mem start indices) start start ((start-1) downto 0)
		in
		(list2bv r)
     /\  w2bv (W_CAT wl) = 
		let sz = wexpr_size (W_CAT wl) in
		list2bv (F:(itlist (\w.\l. (w2bl w)@l) wl []))
     /\  w2bv (W_MEM_READ info mem addr) =
		val (MEM a_sz lines d_sz) = info in
		(check_memory a_sz lines d_sz addr mem) fseq
		letrec read i =
		    i >= lines => W_X d_sz |
		    let range = (d_sz*(i+1)-1) downto (d_sz*i) in
		    let cond = W_EQ (W_CONST a_sz i) addr in
		    W_ITE cond (W_SLICE range mem) (read (i+1))
		in
		w2bv sub (read 0)
     /\  w2bv (W_MEM_WRITE info mem addr d) =
		val (MEM a_sz lines d_sz) = info in
		(check_memory a_sz lines d_sz addr mem) fseq
		letrec write i =
		    i >= lines => [] |
		    let range = (d_sz*(i+1)-1) downto (d_sz*i) in
		    let cond = W_EQ (W_CONST a_sz i) addr in
		    let dr = W_ITE cond d (W_SLICE range mem) in
		    (w2bl dr):(write (i+1))
		in
		list2bv (flat (rev (write 0)))
     /\  w2bv other =
	    (draw_graph 10 other) fseq
	    error "No pattern matched in wexpr2bool sub"
    in
    w2bv w
;

letrec wexpr2bool sub w =
    let sz = wexpr_size w in
    let base = bv2list (w2bv sub w) in
    lastn sz ((replicate sz (hd base))@base)
;

let extract_pexlif_hierarchy pexlif hierarchy =
    let indices = map (sscanf "i%d") (str_split hierarchy "/") in
    letrec get (idx:idxs) p =
        let children = content_get_children (pexlif_get_content p) in
        get idxs (el idx children)
     /\    get [] p = p
    in
    get indices pexlif
;

let get_range v =
    letrec trim ((TXT s):rem) = trim rem
     /\    trim other = other
    in
    letrec no_range ((TXT l):rem) = no_range rem
     /\    no_range ((RANGES l):rem) = F
     /\    no_range [] = T
    in
    let get_one_range ((RANGES [(l,r)]):rem) = 
	    no_range rem => [(l,r)] | eprintf "Not a single range (%s)" v
     /\ get_one_range [] = []
     /\ get_one_range other = eprintf "Not a single range (%s)" v
    in
    get_one_range (trim (md_split_vector v))
;

let w_substitute sub we =
    let decls = map (\v. get_base_name v, special_md_size v)
		    (special_md_extract_vectors (map snd sub))
    then
    letrec do (W_VAR sz b) =
	(
	    let n = mk_name sz b in
	    let vs = vec_assoc n sub then
	    let mk1 v =
		let base = get_base_name v then
		let v_sz = special_md_size v then
		let decl_sz = (assoc base decls) catch v_sz then
		let w_base = W_VAR decl_sz base then
		v_sz = decl_sz => w_base |
		val [(l,r)] = get_range v then
		let indices = l--r then
		(W_SLICE indices w_base)
	    in
	    let w_vs = map mk1 vs then
	    length w_vs = 1 => hd w_vs | W_CAT w_vs
	) catch
	(W_VAR sz b)
     /\     do (W_EXPLICIT_VAR sz n) =
	(
	    let vs = vec_assoc n sub then
	    let mk1 v =
		let base = get_base_name v then
		let v_sz = special_md_size v then
		let decl_sz = assoc base decls then
		let w_base = W_VAR decl_sz base then
		v_sz = decl_sz => w_base |
		val [(l,r)] = get_range v then
		let indices = l--r then
		(W_SLICE indices w_base)
	    in
	    let w_vs = map mk1 vs then
	    length w_vs = 1 => hd w_vs | W_CAT w_vs
	) catch
	(W_EXPLICIT_VAR sz n)
     /\     do (W_AND a b) = W_AND (do a) (do b)
     /\     do (W_LAT_LEQ a b) = W_LAT_LEQ (do a) (do b)
     /\     do (W_OR a b)  = W_OR (do a) (do b)
     /\     do (W_NOT a)   = W_NOT (do a)
     /\     do (W_PRED name cond) = W_PRED name (do cond)
     /\     do (W_EQ a b)  = W_EQ (do a) (do b)
     /\     do (W_GR a b)  = W_GR (do a) (do b)
     /\     do (W_ADD a b)  = W_ADD (do a) (do b)
     /\     do (W_SUB a b)  = W_SUB (do a) (do b)
     /\     do (W_MUL a b)  = W_MUL (do a) (do b)
     /\     do (W_DIV a b)  = W_DIV (do a) (do b)
     /\     do (W_MOD a b)  = W_MOD (do a) (do b)
     /\     do (W_SHL a b)  = W_SHL (do a) (do b)
     /\     do (W_SHR a b)  = W_SHR (do a) (do b)
     /\     do (W_ASHR a b) = W_ASHR (do a) (do b)
     /\     do (W_SX sz a) = W_SX sz (do a)
     /\     do (W_ZX sz a) = W_ZX sz (do a)
     /\     do (W_ITE c t e) = W_ITE (do c) (do t) (do e)
     /\     do (W_SLICE indices w) = (W_SLICE indices (do w))
     /\     do (W_NAMED_SLICE name indices w) =
	    (W_NAMED_SLICE name indices (do w))
     /\     do (W_UPDATE_NAMED_SLICE base name indices w) =
	    (W_UPDATE_NAMED_SLICE (do base) name indices (do w))
     /\     do (W_CAT wl) = W_CAT (map do wl)
     /\     do (W_IDELAY sz rise fall cur d_inps) =
		(W_IDELAY sz rise fall (do cur) (map do d_inps))
     /\     do (W_MEM_READ info mem addr) =
		W_MEM_READ info (do mem) (do addr)
     /\     do (W_MEM_WRITE info mem addr d) =
		W_MEM_WRITE info (do mem) (do addr) (do d)
     /\     do other = other
    in
    do we
;

// Same as md_expand_vector except it handles constants (0b[0-9]*) correctly.
clet cmd_expand_vector v =
    str_is_prefix "0b" v => map (sprintf "0b%s") (tl (tl (explode v))) |
    md_expand_vector v
;

// Same as md_expand_vectors except it handles constants (0b[0-9]*) correctly.
clet cmd_expand_vectors vs = flatmap cmd_expand_vector vs;

// Same as md_merge_vectors except it handles constants (0b[0-9]*) correctly.
clet cmd_merge_vectors ns =
    let vs = md_merge_vectors ns then
    letrec merge_const cur (v:vs) =
        str_is_prefix "0b" v => merge_const (v:cur) vs |
        cur = [] => v:(merge_const [] vs) |
        let cv = list2str F "0b" "" "" (\s. substr s 3 (-1)) (rev cur) in
        cv:v:(merge_const [] vs)
     /\    merge_const cur [] =
        cur = [] => [] |
        [list2str F "0b" "" "" (\s. substr s 3 (-1)) (rev cur)]
    in
    merge_const [] vs
;


clet is_var (W_VAR _ _) = T
  /\ is_var (W_EXPLICIT_VAR _ _) = T
  /\ is_var _ = F;

clet is_simple_var (W_VAR _ _) = T
  /\ is_simple_var _ = F;

clet is_vars l = itlist (\v.\r. is_var v AND r) l T;

let is_binary_base (W_EQ  a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_NOT (W_EQ a b))  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_GR  a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_AND a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_LAT_LEQ a b) = (is_var a) AND (is_var b)
 /\ is_binary_base (W_NOT (W_AND a b))  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_OR  a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_NOT (W_OR a b))  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_ADD a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_SUB a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_MUL a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_DIV a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_MOD a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_SHL a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_SHR a b)  = (is_var a) AND (is_var b)
 /\ is_binary_base (W_ASHR a b) = (is_var a) AND (is_var b)
 /\ is_binary_base other = F
;

let is_binary (W_EQ  a b)  = T
  /\ is_binary (W_GR  a b)  = T
  /\ is_binary (W_AND a b) = T
  /\ is_binary (W_LAT_LEQ a b) = T
  /\ is_binary (W_OR  a b)  = T
  /\ is_binary (W_ADD a b)  = T
  /\ is_binary (W_SUB a b)  = T
  /\ is_binary (W_MUL a b)  = T
  /\ is_binary (W_DIV a b)  = T
  /\ is_binary (W_MOD a b)  = T
  /\ is_binary (W_SHL a b)  = T
  /\ is_binary (W_SHR a b)  = T
  /\ is_binary (W_ASHR a b) = T
  /\ is_binary other = F
;

let split_binary (W_EQ  a b)  = W_EQ, a, b
  /\ split_binary (W_GR  a b)  = W_GR, a, b
  /\ split_binary (W_AND  a b) = W_AND, a, b
  /\ split_binary (W_LAT_LEQ  a b) = W_LAT_LEQ, a, b
  /\ split_binary (W_OR  a b)  = W_OR, a, b
  /\ split_binary (W_ADD a b)  = W_ADD, a, b
  /\ split_binary (W_SUB a b)  = W_SUB, a, b
  /\ split_binary (W_MUL a b)  = W_MUL, a, b
  /\ split_binary (W_DIV a b)  = W_DIV, a, b
  /\ split_binary (W_MOD a b)  = W_MOD, a, b
  /\ split_binary (W_SHL a b)  = W_SHL, a, b
  /\ split_binary (W_SHR a b)  = W_SHR, a, b
  /\ split_binary (W_ASHR a b) = W_ASHR, a, b
  /\ split_binary other = error "Should not happen"
;

// Predicate for hierarchical pexlif
let pexlif_is_hier (PINST nm attrs lf fa_inps fa_outs ints (P_HIER cs)) = T
 /\ pexlif_is_hier oter = F
;

//
// Resize a pexlif constructed by instatiating an fl function using wexprs. 
// NOTE: All nodes that uses wexpr as datatype will be converted
// to a vector of size sz. All others will remian as is.
//
// For example:  resize_pexlif 12 (re_ff 'clk {'d::wexpr} 'o)
// returns a re_ff pexlif where data input (and output) will be of size 12(11:0)
//
let resize_pexlif sz {p::pexlif} =
    let tri i = i = 0 => sz | i in
    let tr1 n =
	NOT (str_is_substr "[-1:0]" n) => n |
	mk_name sz (hd (str_split n "[-1:0]"))
    in
    let trfa (f,as) = (tr1 f), (map tr1 as) in
    letrec trwexpr (W_VAR osz name) = W_VAR (tri osz) name
     /\    trwexpr (W_EXPLICIT_VAR osz nm) = W_EXPLICIT_VAR (tri osz) (tr1 nm)
     /\    trwexpr (W_X osz) = W_X (tri osz)
     /\    trwexpr (W_CONST osz v) = W_CONST (tri osz) v
     /\    trwexpr (W_NAMED_CONST name osz v) = W_NAMED_CONST name (tri osz) v
     /\    trwexpr (W_ITE c a b) = W_ITE (trwexpr c) (trwexpr a) (trwexpr b)
     /\    trwexpr (W_NOT e) = W_NOT (trwexpr e)
     /\    trwexpr (W_PRED name e) = W_PRED name (trwexpr e)
     /\    trwexpr (W_SX osz e) = W_SX (tri osz) (trwexpr e)
     /\    trwexpr (W_ZX osz e) = W_ZX (tri osz) (trwexpr e)
     /\    trwexpr (W_SLICE indices w) = W_SLICE indices (trwexpr w)
     /\    trwexpr (W_CAT ws) = W_CAT (map trwexpr ws)
     /\    trwexpr (W_IDELAY sz rise fall cur d_inps) =
		(W_IDELAY sz rise fall (trwexpr cur) (map trwexpr d_inps))
     /\    trwexpr e assuming (is_binary e) =
	val (op, l, r) = split_binary e in
	op (trwexpr l) (trwexpr r)
     /\    trwexpr other = eprintf "Cannot translate wexpr (%s)" (Pwexpr other)
    in
    let trfn (W_UPDATE_FN lhs rhs) =
	W_UPDATE_FN (trwexpr lhs) (trwexpr rhs)
     /\ trfn (W_PHASE_DELAY lhs rhs) =
	W_PHASE_DELAY (trwexpr lhs) (trwexpr rhs)
    in
    letrec trp (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) =
	let fa_inps' = map trfa fa_inps in
	let fa_outs' = map trfa fa_outs in
	let ints' = map tr1 ints in
	let cs' = map trp cs in
	PINST name attrs lf fa_inps' fa_outs' ints' (P_HIER cs')
     /\   trp (PINST name attrs lf fa_inps fa_outs ints (P_LEAF fns)) =
	let fa_inps' = map trfa fa_inps in
	let fa_outs' = map trfa fa_outs in
	let ints' = map tr1 ints in
	let fns' = map trfn fns in
	PINST name attrs lf fa_inps' fa_outs' ints' (P_LEAF fns')
    in
    trp p
;


let BASE_TMP = "_$";

let BASE_TMP_len = strlen BASE_TMP;
let o0 = ord "0";
let o9 = ord "9";

let strip_BASE_TMP s =
    NOT (str_is_prefix BASE_TMP s) => s |
    let rem = substr s (BASE_TMP_len+1) (-1) in
    letrec skip_dig (c:cs) =
        let oc = ord c in
        (o0 <= oc) AND (oc <= o9) => skip_dig cs | implode (c:cs)
     /\    skip_dig [] = ""
    in
    skip_dig (explode rem)
;


begin_abstype;
letrec dep (W_X sz) = []
 /\     dep (W_CONST sz v) = []
 /\     dep (W_NAMED_CONST name sz v) = []
 /\     dep (W_VAR sz b) = [b]
 /\     dep (W_EXPLICIT_VAR sz b) = [b]
 /\     dep (W_AND a b) = (dep a) union (dep b)
 /\     dep (W_LAT_LEQ a b) = (dep a) union (dep b)
 /\     dep (W_OR  a b) = (dep a) union (dep b)
 /\     dep (W_EQ  a b) = (dep a) union (dep b)
 /\     dep (W_PRED name cond) = dep cond
 /\     dep (W_GR  a b) = (dep a) union (dep b)
 /\     dep (W_ADD a b) = (dep a) union (dep b)
 /\     dep (W_SUB a b) = (dep a) union (dep b)
 /\     dep (W_MUL a b) = (dep a) union (dep b)
 /\     dep (W_DIV a b) = (dep a) union (dep b)
 /\     dep (W_MOD a b) = (dep a) union (dep b)
 /\     dep (W_SHL a b) = (dep a) union (dep b)
 /\     dep (W_SHR a b) = (dep a) union (dep b)
 /\     dep (W_ASHR a b) = (dep a) union (dep b)
 /\     dep (W_SX sz w) = dep w
 /\     dep (W_ZX sz w) = dep w
 /\     dep (W_NOT a)   = dep a
 /\     dep (W_ITE c t e) = (dep c) union (dep t) union (dep e)
 /\     dep (W_SLICE indices w) = dep w
 /\     dep (W_NAMED_SLICE name indices w) = dep w
 /\     dep (W_UPDATE_NAMED_SLICE base name indices w) = (dep base) union (dep w)
 /\     dep (W_CAT parts) = itlist (\e.\r. dep e union r) parts []
 /\     dep (W_IDELAY sz rise fall cur d_inps) =
	    itlist (\e.\r. dep e union r) d_inps (dep cur)
 /\     dep (W_MEM_READ info mem addr) = (dep mem) union (dep addr)
 /\     dep (W_MEM_WRITE info mem addr data) =
	    (dep mem) union (dep addr) union (dep data)
;

letrec get_wbase_names e = dep e;
end_abstype get_wbase_names;


let base_compact_wprint inps rhs =
    let i_map = zip inps (1 upto (length inps)) in
    letrec P pri (W_X sz) = sprintf "X[%d:0]" (sz-1)
     /\    P pri (W_CONST sz v) =
	    v < 16 => int2str v |
	    sz < 5 OR ((sz % 4) != 0) => sprintf "0b%0*b" sz v
				       | sprintf "0x%x" v
     /\    P pri (W_NAMED_CONST name sz v) = name
     /\    P pri (W_VAR sz base) =
		let inp = assoc base i_map in
		sprintf "i%d" inp
     /\    P pri (W_EXPLICIT_VAR sz base) =
		let inp = assoc base i_map in
		sprintf "i%d" inp
     /\    P pri (W_AND a b) =
		pri > 5 => sprintf "(%s&%s)" (P 5 a) (P 5 b)
			 | sprintf "%s&%s" (P 5 a) (P 5 b)
     /\    P pri (W_LAT_LEQ a b) =
		pri > 2 => sprintf "(%s [<=] %s)" (P 2 a) (P 2 b)
			 | sprintf "%s [<=] %s" (P 2 a) (P 2 b)
     /\    P pri (W_OR  a b) =
		pri > 4 => sprintf "(%s|%s)" (P 4 a) (P 4 b)
			 | sprintf "%s|%s" (P 4 a) (P 4 b)
     /\    P pri (W_NOT a) =
		pri > 8 => sprintf "(~%s)" (P 8 a) | sprintf "~%s" (P 8 a)
     /\    P pri (W_EQ  (W_CONST sz v) b) =
		pri > 3 => sprintf "(%s=%s)" (P 3 b) (P 3 (W_CONST sz v))
			 | sprintf "%s=%s" (P 3 b) (P 3 (W_CONST sz v))
     /\    P pri (W_EQ  a b) =
		pri > 3 => sprintf "(%s=%s)" (P 3 a) (P 3 b)
			 | sprintf "%s=%s" (P 3 a) (P 3 b)
     /\    P pri (W_PRED name cond) =
	    let inps = get_wbase_names cond in
	    let sassoc i al = (assoc i al) catch 999 in
	    let vinps = map (\i. sprintf "i%d" (sassoc i i_map)) inps in
	    let args = list2str T "(" "," ")" id (qsort node_name_cmp vinps) in
	    sprintf "%s%s" name args
     /\    P pri (W_SHL a (W_CONST sz v)) =
		pri > 4 => sprintf "(%s<<%d)" (P 4 a) v
			 | sprintf "%s<<%d" (P 4 a) v
     /\    P pri (W_SHR a (W_CONST sz v)) =
		pri > 4 => sprintf "(%s>>%d)" (P 4 a) v
			 | sprintf "%s>>%d" (P 4 a) v
     /\    P pri (W_ASHR a (W_CONST sz v)) =
		pri > 4 => sprintf "(%s|>>%d)" (P 4 a) v
			 | sprintf "%s|>>%d" (P 4 a) v
     /\    P pri (W_GR  (W_CONST sz v) b) =
		pri > 3 => sprintf "(%s<%s)" (P 3 b) (P 3 (W_CONST sz v))
			 | sprintf "%s<%s" (P 3 b) (P 3 (W_CONST sz v))
     /\    P pri (W_GR  a b) =
		pri > 3 => sprintf "(%s>%s)" (P 3 a) (P 3 b)
			 | sprintf "%s>%s" (P 3 a) (P 3 b)
     /\    P pri (W_ADD a b) =
		pri > 2 => sprintf "(%s+%s)" (P 2 a) (P 2 b)
			 | sprintf "%s+%s" (P 2 a) (P 2 b)
     /\    P pri (W_SUB a b) =
		pri > 2 => sprintf "(%s-%s)" (P 2 a) (P 2 b)
			 | sprintf "%s-%s" (P 2 a) (P 2 b)
     /\    P pri (W_MUL a b) =
		pri > 3 => sprintf "(%s*%s)" (P 3 a) (P 3 b)
			 | sprintf "%s*%s" (P 3 a) (P 3 b)
     /\    P pri (W_DIV a b) =
		pri > 4 => sprintf "(%s/%s)" (P 4 a) (P 4 b)
			 | sprintf "%s/%s" (P 4 a) (P 4 b)
     /\    P pri (W_MOD a b) =
		pri > 4 => sprintf "(%s%%%s)" (P 4 a) (P 4 b)
			 | sprintf "%s%%%s" (P 4 a) (P 4 b)
     /\    P pri (W_SHL a b) =
		pri > 4 => sprintf "(%s<<%s)" (P 4 a) (P 4 b)
			 | sprintf "%s<<%s" (P 4 a) (P 4 b)
     /\    P pri (W_SHR a b) =
		pri > 4 => sprintf "(%s>>%s)" (P 4 a) (P 4 b)
			 | sprintf "%s>>%s" (P 4 a) (P 4 b)
     /\    P pri (W_ASHR a b) =
		pri > 4 => sprintf "(%s|>>%s)" (P 4 a) (P 4 b)
			 | sprintf "%s|>>%s" (P 4 a) (P 4 b)
     /\    P pri (W_SX sz w) =
		pri > 0 => sprintf "(SX %s)" (P pri w)
			 | sprintf "SX %s" (P pri w)
     /\    P pri (W_ZX sz w) =
		pri > 0 => sprintf "(ZX %s)" (P pri w)
			 | sprintf "ZX %s" (P pri w)
     /\    P pri (W_ITE c t e) =
		pri > 1 => sprintf "(%s?%s:%s)" (P 1 c) (P 1 t) (P 1 e)
			 | sprintf "%s?%s:%s" (P 1 c) (P 1 t) (P 1 e)
     /\    P pri (W_SLICE indices w) =
		let vec = pr_indices indices then
		pri > 9 => sprintf "(%s%s)" (P 9 w) vec
			 | sprintf "%s%s" (P 9 w) vec
     /\    P pri (W_NAMED_SLICE name indices w) =
		pri > 9 => sprintf "(%s-->%s)" (P 9 w) name
			 | sprintf "%s-->%s" (P 9 w) name
     /\    P pri (W_UPDATE_NAMED_SLICE base name ids w) =
		letrec get_exprs (W_UPDATE_NAMED_SLICE base name ids w) =
		    (sprintf "%s ? %s" name (P 10 w)):(get_exprs base)
		 /\    get_exprs other = [(P 10 other)]
		in
		let lines = get_exprs (W_UPDATE_NAMED_SLICE base name ids w) in
		val (s_base:rem) = rev lines in
		let max_rem_len = itlist (\s.\m. max m (strlen s)) rem 0 in
		let rem' = map (sprintf "%-*s\n" (max_rem_len+1)) rem in
		let pre = sprintf "%s<--" s_base in
		let sep = sprintf "%*s<--" (strlen s_base) "" in
		let post = "" in
		list2str T pre sep post id rem'
     /\    P pri (W_CAT parts) =
		let inps = map (P 1) parts then
		let ivs = md_merge_vectors inps then
		length ivs = 1 => hd ivs |
		let in_one = list2str T "{" "," "}" id ivs then
		strlen in_one <= 10 => in_one |
		list2str T "{" ",\n" "}" id ivs
     /\    P pri (W_IDELAY sz rise fall cur d_inps) =
		let pre = sprintf "IDEL^[%d,%d)v[%d,%d) %s ["
				  (fst rise) (snd rise) (fst fall) (snd fall)
				  (P 1 cur)
		in
		list2str T pre ", " "]" (P 1) d_inps
     /\    P pri (W_MEM_READ info mem addr) =
	    sprintf "%s[%s]" (P pri mem) (P pri addr)
     /\    P pri (W_MEM_WRITE info mem addr d) =
	    sprintf "(%s[%s]<-%s)" (P pri mem) (P pri addr) (P pri d)
    in
    P 0 rhs
;

let inp2tcl inps rhs =
    let i_map = zip inps (1 upto (length inps)) in
    letrec P ic pri (W_X sz) = sprintf "X[%d:0]" (sz-1)
     /\    P ic pri (W_CONST sz v) =
	    v < 16 => int2str v |
	    sz < 5 OR ((sz % 4) != 0) => sprintf "0b%0*b" sz v
				       | sprintf "0x%x" v
     /\    P ic pri (W_NAMED_CONST name sz v) = name
     /\    P ic pri (W_VAR sz base) =
		let inp = assoc base i_map in
		sprintf "i%d" inp
     /\    P ic pri (W_EXPLICIT_VAR sz base) =
		let inp = assoc base i_map in
		sprintf "i%d" inp
     /\    P ic pri (W_NOT (W_CONST sz v)) =
		let v' = intNOT v in
		sz <= 8 => sprintf "%*b" sz v' |
		v' < 0 => sprintf "~0x%*x" ((sz+3)/4) v |
		sprintf "0x%*x" ((sz+3)/4) v'
     /\    P ic pri (W_SLICE indices w) =
		let vec = pr_indices indices then
		pri > 9 => sprintf "(%s%s)" (P ic 9 w) vec
			 | sprintf "%s%s" (P ic 9 w) vec
     /\    P ic pri (W_NAMED_SLICE name indices w) =
		pri > 9 => sprintf "(%s-->%s)" (P ic 9 w) name
			 | sprintf "%s-->%s" (P ic 9 w) name
     /\    P ic pri (W_CAT parts) =
		let ss = map (P T 1) parts then
		ic OR length parts < 2 =>
		    list2str T "{" "," "}" id ss
		|
		    list2str T "{" ",\n" "}" id ss
     /\   P ic pri other = base_compact_wprint inps rhs
    in
    P F 0 rhs
;


let is_XOR (W_OR (W_AND (W_NOT a) b) (W_AND c (W_NOT d))) = (a==c) AND (b==d)
 /\ is_XOR (W_OR (W_AND a (W_NOT b)) (W_AND (W_NOT c) d)) = (a==c) AND (b==d)
 /\ is_XOR _ = F
;

let is_LEQ (W_NOT (W_GR a b)) = T
 /\ is_LEQ _ = F;

let get_binary_draw_cmd (W_EQ  a b)  = "draw_binary_arithm {=}"
 /\ get_binary_draw_cmd (W_NOT (W_EQ a b))  = "draw_binary_arithm {!=}"
 /\ get_binary_draw_cmd (W_GR  a b)  = "draw_binary_arithm {>}"
 /\ get_binary_draw_cmd (W_AND  a b) = "draw_and2"
 /\ get_binary_draw_cmd (W_LAT_LEQ  a b) = "draw_lat_leq"
 /\ get_binary_draw_cmd (W_NOT (W_AND  a b)) = "draw_nand2"
 /\ get_binary_draw_cmd (W_OR  a b)  = "draw_or2"
 /\ get_binary_draw_cmd (W_NOT (W_OR  a b))  = "draw_nor2"
 /\ get_binary_draw_cmd (W_ADD a b)  = "draw_binary_arithm {+}"
 /\ get_binary_draw_cmd (W_SUB a b)  = "draw_binary_arithm {-}"
 /\ get_binary_draw_cmd (W_MUL a b)  = "draw_binary_arithm {*}"
 /\ get_binary_draw_cmd (W_DIV a b)  = "draw_binary_arithm {/}"
 /\ get_binary_draw_cmd (W_MOD a b)  = "draw_binary_arithm {%}"
 /\ get_binary_draw_cmd (W_SHL a b)  = "draw_binary_arithm {<<}"
 /\ get_binary_draw_cmd (W_SHR a b)  = "draw_binary_arithm {>>}"
 /\ get_binary_draw_cmd (W_ASHR a b) = "draw_binary_arithm {|>>}"
 /\ get_binary_draw_cmd other = error "Should not happen"
;

letrec is_tuple (W_CAT [e1, e2]) =
    let is_slice (W_SLICE l e) = T
     /\ is_slice other = F
    in
    (is_slice e1 OR is_tuple e1) AND
    (is_slice e2 OR is_tuple e2)
 /\    is_tuple other = F
;

let tuple2tcl inps e =
    letrec match (W_CAT [e,f]) = match e @ match f
     /\    match (W_SLICE l e) = match e
     /\    match other = [other]
    in
    let es = setify (match e) in
    length es != 1 => error "Not a pair operator" |
    let expr = hd es in
    letrec cat2tuple top (W_CAT [e1, e2]) =
        let s1 = cat2tuple T e1 in
        let s2 = cat2tuple F e2 in
        top => sprintf "(%s, %s)" s1 s2 | sprintf "%s, %s" s1 s2
    /\     cat2tuple top other = inp2tcl inps other
    in
    let clean (W_ITE c t e) =
        let sc = sprintf "IF %s THEN" (inp2tcl inps c) in
        let st = cat2tuple T t in
        let se = cat2tuple T e in
	let lc = strlen sc in
	let lt = strlen st in
	let le = strlen se in
	let l = max (max lc lt) le in
	sprintf "%-*s\n%-*s\n%-*s\n%-*s" (l+3) sc l st (l+3) "ELSE" l se
     /\ clean other = cat2tuple T other
    in
    clean expr
;

let opt_base_compact_wprint inps rhs =
    let special (W_ADD var (W_CONST sz v)) assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {+%d}" v
     /\ special (W_SUB var (W_CONST sz v)) assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {-%d}" v
     /\ special (W_EQ var (W_CONST sz v)) assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {=%d}" v
     /\ special (W_EQ (W_CONST sz v) var) assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {=%d}" v
     /\ special (W_NOT (W_EQ var (W_CONST sz v)))
		assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {!=%d}" v
     /\ special (W_NOT (W_EQ (W_CONST sz v) var))
		assuming (is_var var AND v < 10) =
	sprintf "draw_unary_arithm {!=%d}" v
     /\ special (W_EQ var (W_CONST sz v)) assuming (is_var var) =
	sprintf "draw_hfl {=0x%x}" v
     /\ special (W_PRED name cond) =
	sprintf "draw_predicate %s %d" name (length inps)
     /\ special (W_ITE var1 var2 var3) assuming (is_vars [var1,var1,var3]) =
	"draw_ite"
     /\ special (W_NOT var) assuming (is_var var) =
	"draw_inverter"
     /\ special var assuming (is_var var) =
	"draw_buffer"
     /\ special (W_NAMED_SLICE name indices var) assuming (is_var var) =
	sprintf "draw_field %s" name
     /\ special (W_SX sz (W_VAR ssz name)) = "draw_unary_arithm {SX}"
     /\ special (W_ZX sz (W_VAR ssz name)) = "draw_unary_arithm {ZX}"
     /\ special (W_SX sz (W_EXPLICIT_VAR ssz name)) = "draw_unary_arithm {SX}"
     /\ special (W_ZX sz (W_EXPLICIT_VAR ssz name)) = "draw_unary_arithm {ZX}"
     /\ special op assuming (is_XOR op) = "draw_xor2"
     /\ special op assuming (is_LEQ op) = "draw_binary_arithm {<=}"
     /\ special op assuming (is_binary_base op) = get_binary_draw_cmd op
     /\ special op assuming (is_tuple op) =
	(sprintf "draw_hfl {%s}" (tuple2tcl inps op)) catch
	let body = base_compact_wprint inps rhs then
	sprintf "draw_hfl {%s}" body
     /\ special other =
	let body = base_compact_wprint inps rhs then
	sprintf "draw_hfl {%s}" body
    in
    special rhs
;


let mk_draw_cmd phase_delay rhs =
    let inps = get_wbase_names rhs then
    inps = [] =>
	let special (W_NAMED_CONST name sz v) =
		sprintf "draw_constant {%s}" name
	 /\ special (W_X sz) =
		sprintf "draw_constant {X[%d:0]}" (sz-1)
	 /\ special (W_CONST sz v) =
	    v < 16 => sprintf "draw_constant %d" v |
	    (
	    sz < 5 OR ((sz % 4) != 0) => sprintf "draw_constant 0b%0*b" sz v
				       | sprintf "draw_constant 0x%x" v
	    ) catch
	    (sprintf "draw_constant 0x%x" v)
	 /\ special rhs =
		let body = inp2tcl inps rhs then
		sprintf "draw_hfl {%s}" body
	in
	special rhs
    |
    let base = opt_base_compact_wprint inps rhs then
    NOT phase_delay => base | sprintf "draw_phase_delay_on_output {%s}" base
;

// Create a summary of cell usage in a synthesized pexlif.
let get_mapped_cell_info p =
    val (PINST nm attrs lf fai fao ints (P_HIER cells)) = p in
    let nm_size_r = ref 2 in
    let update_size s =
	let l = strlen s in
	(l > (deref nm_size_r) => (nm_size_r := l) | ()) fseq s
    in
    let get_cell pp =
	let state = has_state pp in
        val (PINST cnm _ _ _ _ _ _) = pp in
        str_is_prefix "draw_stdcell " cnm =>
	    let cell_name = update_size (el 2 (str_split cnm " ")) then
	    T, state, cell_name
	|
	    (F, state, update_size cnm)
    in
    val (raw_mapped, raw_unmapped) = split fst (map get_cell cells) then
    let TOT = length raw_mapped + length raw_unmapped in
    let name_size = deref nm_size_r then
    let sep = implode (replicate (name_size+16) "-") in
    let mapped = map snd raw_mapped in
    let unmapped = map snd raw_unmapped in
    //
    let Plist type l =
        let total = itlist (\(nm,cnt).\r. cnt+r) l 0 in
        let pr (nm,cnt) = sprintf "%*s %6d" name_size nm cnt in
        let pre = sprintf "%s:\n" type in
        let post = sprintf "\n%s\n%*s %6d\n\n" sep name_size "Total:" total in
	let cmp (nm1,c1) (nm2,c2) = strcmp nm1 nm2 in
        total, (list2str T pre "\n" post pr (qsort cmp l))
    in
    let mk_info state_name_list =
	let classes = partition id state_name_list in
	let mk1 l =
	    val (st, nm) = hd l in
	    (st, nm, length l)
	in
	let raw_res = map mk1 classes in
	val (state,comb) = split fst raw_res in
	let state_list = map snd state in
	let comb_list  = map snd comb in
	val (st_cnt, st_txt) = Plist "state holding:" state_list in
	val (cb_cnt, cb_txt) = Plist "combinational:" comb_list in
	let sum = st_cnt + cb_cnt in
        let post = sprintf "\n%s\n%*s %6d\n\n" sep name_size "Total:" sum in
	(cb_txt^st_txt^post)
    in
    let summary = sprintf "%*s %6d\n" name_size "TOTAL:" TOT in
    (mapped = [] => "" | (sprintf "Mapped std cells:\n")^(mk_info mapped))^
    (unmapped = [] => "" | (sprintf "Unmapped cells:\n")^(mk_info unmapped))^
    summary
;

