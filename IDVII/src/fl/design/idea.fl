cload "ste.fl";


ENUM "foo" ["OP1", "OP2", "OP3"];

"a[1:0]" is OP1 in_cycle 1 followed_by OP2 in_cycle 2;

{'a::foo} is OP1 in_cycle 1 followed_by OP2 in_cycle 2;


let wexpr_hw_destr {e::wexpr} = e;
add_open_overload hw_destr wexpr_hw_destr;
let wexpr_hw_constr {e::wexpr} = e;
add_open_overload hw_constr wexpr_hw_constr;
let wexpr_is_arithmetic {e::wexpr} = T;
add_open_overload hw_is_arithmetic wexpr_is_arithmetic;
let wexpr_type_name {bv::wexpr} = "wexpr";
add_open_overload hw_type_name wexpr_type_name;
let wexpr_mk_var {we::wexpr} base = W_VAR 0 base;
add_open_overload hw_mk_var wexpr_mk_var;
//let wexpr_dsize {we::wexpr} = -1;
//add_open_overload hw_size wexpr_dsize;


let at_phase vec ph =
    let sz = md_size vec in
    W_EXPLICIT_VAR sz (sprintf "@%d_%s" ph vec)
;
infix 9 at_phase;

let at_cycle vec cyc =
    let sz = md_size vec in
    W_EXPLICIT_VAR sz (sprintf "@%d_%s" (2*cyc) vec)
;
infix 9 at_cycle;

let ASSERT {name::string} {b::bit} =
    let we = hw_destr b in
    (name, we)
;

let csa_prop x y z c s t =
    let sum1 = x at_cycle t '+' y at_cycle t '+' z at_cycle t in
    let sum2 = '2 '*' c at_cycle t '+' s at_cycle t in
    ASSERT "csa_sum" (sum1 '=' sum2)
;

let csa_prop x y z c s t =
    let sz = md_size x in
    let V n = W_ZX (sz+1) (n at_cycle t) in
    let sum1 = V x '+' V y '+' V z in
    let sum2 = (W_CONST (sz+1) 2) '*' V c '+' V s in
    ASSERT "csa_sum" (sum1 '=' sum2)
;

let tst = csa_prop "xx" "yy" "zz" "cc" "ss" 4;
tst;

let prop t =
    let sum1 = "a[7:0]" at_cycle t '+' "i1/i3/b[7:0]" at_cycle (t+1) in
    let sum2 = "sum[7:0]" at_cycle (t+2) in
    ASSERT "range_cond" (sum1 '>=' sum2)
;

let tst2 = prop 3;
tst2;


new_type_abbrev ftl = (bool # string # bool # int # int) list;
new_type_abbrev nwe = (string#wexpr);
new_type_abbrev wl = (string#wexpr) list;

let and1 {ftl1::ftl} {ftl2::ftl} = (ftl1@ftl2,[]);
let and2 {ftl1::ftl} {e::nwe}  = (ftl1,[e]);
let and3 {e::nwe}  {ftl1::ftl} = (ftl1,[e]);
let and4 {e1::nwe} {e2::nwe} = ([],[e1,e2]);
let and5 {ftl1::ftl} ({ftlr::ftl},{es::wl}) = (ftl1@ftlr),es;
let and6 {e::nwe}  ({ftlr::ftl},{es::wl}) = ftlr,(e:es);
let and7 ({ftlr::ftl},{es::wl}) {ftl1::ftl} = (ftl1@ftlr),es;
let and8 ({ftlr::ftl},{es::wl}) {e::nwe} = ftlr,(e:es);
let and9 ({ftlr1::ftl},{es1::wl}) ({ftlr2::ftl},{es2::wl}) =
		(ftlr1@ftlr2),(es1@es2);
overload and and1 and2 and3 and4 and5 and6 and7 and8 and9;
infix 1 and;


"a" is 1 in_cycle 1 otherwise 0 until 10 cycles
and
tst
and
tst2
and
"b" is 1 in_cycle 1 otherwise 0 until 10 cycles
;


let mk_phase_delays n i o =
    let sz = md_size i in
    md_size o != sz =>
	eprintf "Size mismatch in mk_phase_delays |%s| != |%s|" i o
    |
    let fi = mk_name sz "i" in
    let fo = mk_name sz "o" in
    let mids = map (\i. mk_name sz (sprintf "m%d" i)) (1 upto n) in
    let fns =
	map2 (\i.\o. W_PHASE_DELAY (W_EXPLICIT_VAR sz o) (W_EXPLICIT_VAR sz i))
	     (o:mids) (mids@[i])
    in
    PINST (sprintf "draw_hfl phase_delay(%d)" n) [] T
	    [(fi,[i])] [(fo,[o])] mids (P_LEAF fns)
;


let prop2pexlif nwe =
    val (name, we) = nwe in
    let timed_inps = setify (map (sscanf "@%d_%s") (w_depends we)) in
    let min_time = itlist (\(t,_).\m. min t m) timed_inps 100000 in
    let max_time = itlist (\(t,_).\m. max t m) timed_inps (-1000) in
    let vecs = setify (map snd timed_inps) then
    let pfn = sprintf "draw_hier %s" name in
    let mk_fa pin idx =
	    let sz = md_size pin in
	    let f = mk_name sz (sprintf "i%d" idx) in
	    (f, [pin])
    in
    let fa_inps = map2 mk_fa vecs (1 upto (length vecs)) in
    let aout = sprintf "%s_ok" name in
    let fa_outs = [("ok", [aout])] in
    let io_map = map (\(f,[an]). an, f) fa_inps in
    let shifted_tinps = setify (map (\(t,n). t-min_time, n) timed_inps) in
    let need_delays = filter (\(t,n). t != 0) shifted_tinps in
    let mk_delay (t,pin) =
	let f = assoc pin io_map in
	let df = sprintf "d%d_%s" t f in
	df, mk_phase_delays t f df
    in
    val (internals, delays) = unzip (map mk_delay need_delays) in
    let mk_sub (t,pin) = 
	let sz = md_size pin in
	let nm = sprintf "@%d_%s" t pin in
	let f = assoc pin io_map in
	let t' = t - min_time in
	t' = 0 => (nm, W_EXPLICIT_VAR sz f) |
	let df = W_EXPLICIT_VAR sz (sprintf "d%d_%s" t' f) in
	(nm, df)
    in
    let wsub = map mk_sub timed_inps in
    let we' = w_substitute wsub we in
    let comb = base_assignment T (W_VAR 1 "ok") we' in
    let monitor = PINST (sprintf "draw_hier %s" name) [] F
			fa_inps fa_outs internals (P_HIER (comb:delays))
    in
    let mk_ant (t,v) =
	let mkvar n = variable (sprintf "@%d_%s" t n) in
	map (\nd. T, nd, mkvar nd, t, t+1) (md_expand_vector v)
    in
    let ant = flatmap mk_ant timed_inps in
    let cond = hd (wexpr2bool we) in
    let cons = [(T, aout, T, max_time, max_time+1)] in
    cond, ant, cons, monitor
;



val (cond, ant, cons, p) = prop2pexlif tst;
STE_debug (pexlif2fsm p);
cond;
ant;
cons;

val (cond, ant, cons, p) = prop2pexlif tst2;
STE_debug (pexlif2fsm p);
cond;
ant;
cons;



