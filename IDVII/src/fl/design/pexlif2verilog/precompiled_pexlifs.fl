// This file contains function to recognize certain precompiled pexlifs
// and replace them with the given code
// This is mostly usefull to remove phase delay, which don't really
// exist in verilog, so we have precompiled D flip flop, D latches...
// See the precompiled_pexlif type for an exhaustive list
//
// File sections:
//  - precompiled code
//  - pexlif recognition


cload (DIR^"ast.fl");
cload (DIR^"utils.fl");


// A list is easier to iterate
let PRECOMPILED_LIST = [
	RE_FF, RE_FF_RESET, RE_FF_EN, RE_FF_EN_RESET, FE_FF,
	AL_LATCH, AH_LATCH
];

// the parameter name
let WIDTH_PARAM = "WIDTH";

// =====================================================
// ยง Precompiled code
// =====================================================

// module name (matches the one in precompiled code)
let precompiled_module_name (RE_FF)          = "re_ff"
 /\ precompiled_module_name (RE_FF_RESET)    = "re_ff_reset"
 /\ precompiled_module_name (RE_FF_EN)       = "re_ff_en"
 /\ precompiled_module_name (RE_FF_EN_RESET) = "re_ff_en_reset"
 /\ precompiled_module_name (FE_FF)          = "fe_ff"
 /\ precompiled_module_name (AH_LATCH)       = "draw_ah_latch"
 /\ precompiled_module_name (AL_LATCH)       = "draw_al_latch";


// Returns the verilog code for precompile sections
let precompiled_code type =
let match (RE_FF) =
		"// precompiled rising edge D flip flop{NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(posedge clk){NEWLINE}" ^
		"{INDENT}{INDENT}q <= d;{NEWLINE}" ^
		"endmodule"
	/\ match (RE_FF_RESET) =
		"// precompiled rising edge D flip flop with asynchronous reset (active high){NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input reset, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(posedge clk, posedge reset){NEWLINE}" ^
		"{INDENT}{INDENT}if (reset) q <= 0;{NEWLINE}" ^
		"{INDENT}{INDENT}else       q <= d;{NEWLINE}" ^
		"endmodule"
	/\ match (RE_FF_EN) =
		"// precompiled rising edge D flip flop with enable{NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input en, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(posedge clk){NEWLINE}" ^
		"{INDENT}{INDENT}if (en){NEWLINE}" ^
		"{INDENT}{INDENT}{INDENT}q <= d;{NEWLINE}" ^
		"endmodule"
	/\ match (RE_FF_EN_RESET) =
		"// precompiled rising edge D flip flop with enable and asynchronous reset (active high){NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input reset, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(posedge clk, posedge reset){NEWLINE}" ^
		"{INDENT}{INDENT}if (reset)   q <= 0;{NEWLINE}" ^
		"{INDENT}{INDENT}else if (en) q <= d;{NEWLINE}" ^
		"endmodule"
	/\ match (FE_FF) =
		"// precompiled falling edge D flip flop{NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(negedge clk){NEWLINE}" ^
		"{INDENT}{INDENT}q <= d;{NEWLINE}" ^
		"endmodule"
/\ match (AH_LATCH) =
		"// precompiled D latch (active high){NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(clk, d){NEWLINE}" ^
		"{INDENT}{INDENT}if (clk) q <= d;{NEWLINE}" ^
		"endmodule"
	/\ match (AL_LATCH) =
		"// precompiled D latch (active low){NEWLINE}" ^
		"module {module_name} #(parameter {WIDTH} = 1) ({NEWLINE}" ^
		"{INDENT}input clk, input[{WIDTH}-1:0] d, output reg[{WIDTH}-1:0] q{NEWLINE}" ^
		");{NEWLINE}" ^
		"{INDENT}always @(clk, d){NEWLINE}" ^
		"{INDENT}{INDENT}if (~clk) q <= d;{NEWLINE}" ^
		"endmodule"
	in format (match type) [
		"{module_name}" --- (precompiled_module_name type),
		"{WIDTH}"       --- WIDTH_PARAM,
		"{NEWLINE}"     --- NEWLINE,
		"{INDENT}"      --- INDENT
	];
;

// used for recognition
let precompiled_name (RE_FF)          = "draw_ff_re"
 /\ precompiled_name (RE_FF_RESET)    = "draw_ff_re_reset"
 /\ precompiled_name (RE_FF_EN)       = "draw_ff_re_with_en"
 /\ precompiled_name (RE_FF_EN_RESET) = "draw_ff_re_with_en_reset"
 /\ precompiled_name (FE_FF)          = "fe_ff"
 /\ precompiled_name (AH_LATCH)       = "draw_ah_latch"
 /\ precompiled_name (AL_LATCH)       = "draw_al_latch";

// used for recognition and variable linking
// matches both the pexlif name and the var name
// in precompiled code
let precompiled_inputs (RE_FF)          = ["d", "clk"]
 /\ precompiled_inputs (RE_FF_RESET)    = ["d", "reset", "clk"]
 /\ precompiled_inputs (RE_FF_EN)       = ["d", "en", "clk"]
 /\ precompiled_inputs (RE_FF_EN_RESET) = ["d", "en", "reset", "clk"]
 /\ precompiled_inputs (FE_FF)          = ["clk", "d"]
 /\ precompiled_inputs (AH_LATCH)       = ["d", "clk"]
 /\ precompiled_inputs (AL_LATCH)       = ["d", "clk"];

// used for recognition and variable linking
// matches both the pexlif name and the var name
// in precompiled code
let precompiled_outputs (RE_FF)          = ["q"]
 /\ precompiled_outputs (RE_FF_RESET)    = ["q"]
 /\ precompiled_outputs (RE_FF_EN)       = ["q"]
 /\ precompiled_outputs (RE_FF_EN_RESET) = ["q"]
 /\ precompiled_outputs (FE_FF)          = ["q"]
 /\ precompiled_outputs (AH_LATCH)       = ["q"]
 /\ precompiled_outputs (AL_LATCH)       = ["q"];


// =====================================================
// ยง Pexlif recognition
// =====================================================



// Check if a list of pexlif port (inputs or outputs)
// matches an expected list
letrec matches_ports ([]) ([]) = T
	/\ matches_ports a ([])    = F
	/\ matches_ports ([]) a    = F
	/\ matches_ports (name:r) ((local, glob):r2) =
			((vector_name local) == name) AND (matches_ports r r2);

// Check if a pexlif matches names and i/o ports
let matches_name_and_ports name in_names out_names (PINST n a l i o t c) =
	//printf "%B %B %B\n" (name == n) (matches_ports in_names i)  (matches_ports out_names i) fseq
	(name == n) AND (matches_ports in_names i) AND (matches_ports out_names o);

// Check if a pexlif is the given structure
let matches_precompiled pre_comp pex =
	matches_name_and_ports
		(precompiled_name pre_comp)
		(precompiled_inputs pre_comp)
		(precompiled_outputs pre_comp) pex;

// Check if a pexlif matches any of the precomiled structures
// Returns (SOME matched structure) or NONE
let find_precompiled_match pex =
	letrec runner ([]) = NONE
		/\ runner (t:q) = matches_precompiled t pex => SOME t | runner q
	in runner PRECOMPILED_LIST;

// Returns all parameters for precompiled module
// Currently the only one is the size of the output q
let precompiled_params _ _ [(_, vlhs)] = [WIDTH_PARAM --- vlhs_size vlhs];
