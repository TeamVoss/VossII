// Compile a pexlif into a verilog module
//
// File sections:
//  - Compile update_fn list to VerilogStatement list
//  - Variable handling - utility function to go from pexlif fa_inps, fa_outs to
//     more convenient types
//  - Compile pexlif to VerilogModule


cload (DIR^"ast.fl");
cload (DIR^"utils.fl");
cload (DIR^"wexpr2swexpr.fl");
cload (DIR^"swexpr2vexpr.fl");
cload (DIR^"precompiled_pexlifs.fl");
cload (DIR^"variables.fl");


// ================================================
// Compile update_fn list to VerilogStatement list
// ================================================


// Returns true if update_fn is W_PHASE_DELAY
let update_fn_is_phase_delay (W_PHASE_DELAY _ _) = T
 /\ update_fn_is_phase_delay _ = F;

// Transfrom an update_fn list into a VerilogStatement list
// Arguments:
//   <path: int list> path to the current pexlif, used when inlining to avoid name collisions
//   <update_fn list> the list to compile
//   <VerilogStatement list> previous statements
//     (used to count adder variables)
// Returns
//   <VerilogStatement list> the list of statements
let update_fn2vstmt path update_fn_list statements =
	letrec runner ([]) stmts = stmts
		/\ runner (fn:rest) stmts =
			let lhs_swexpr = wexpr2swexpr (update_fn_get_lhs fn) in
			let rhs_swexpr = wexpr2swexpr (update_fn_get_rhs fn) in
			let lhs = swexpr2vlhs path lhs_swexpr in
			val (rhs, new_stmts) = swexpr2vexpr path stmts rhs_swexpr in
			(update_fn_is_phase_delay fn)
				=> eprintf "Encountered W_PHASE_DELAY outside of recognized flip-flops and latches."
				|  runner rest ((VS_Assign lhs rhs):new_stmts)
	in runner update_fn_list statements;


// ================================================
// Variable handling
// ================================================


// Returns T if the given string is the name of the given VerilogVariable
let var_has_name name (VV_Named _ _ n) = name == n
 /\ var_has_name name _ = F;

// converts a individual var string (given by md_expand_vector)
// into a W_SLICE (W_SLICE ... W_VAR sz name)
// where sz is the size of the variable with matching name in the context list
let var_slice context v =
	val (name, slices) = split_vector v in
	val (VV_Named _ sz n) = get_first (var_has_name name) context catch
		eprintf "Variable %s used but not defined in pexlif's fa_inps, fa_outs or ints..." name
	in
	// printf "splitting %s (%s %d)\n" v n sz fseq
	sitlist (\(a, b).\expr. W_SLICE (a--b) expr) slices (W_VAR sz n);



// Used to translate pexlif's fa_inps and fa_outs
// Into a actual assignement (var = LHS). We use VerilogLHS on the right
// because it should really only be concats of slices.
// Arguments:
//   <path: int list> path to the current pexlif, used when inlining to avoid name collisions
//      THIS IS THE PATH OF THE PARENT (caller), NOT THE CHILD (CALLEE)
//   <context (VerilogVariable list)> variables known by the parent pexlif
//     (used to set size)
//   <(local, global) (string#(string list))> element of fa_inps or fa_outs
// Returns:
//   <VerilogVariable # VerilogLHS> (assignement var = LHS)
let var_assignement path context (var, right) =
	// printf "assignement (%s) =  %S\n" var right fseq
	let vecs = md_expand_vectors right in
	// We make a wexpr to reuse the simplifications in wexpr2swexpr
	let w_expr = W_CAT (map (var_slice context) vecs) in
	vector2var path var, swexpr2vlhs path (wexpr2swexpr w_expr);

// Calls var_assignement and formats it results for module output
let module_out_assignement path context assignement =
	val (var, vlhs) = var_assignement path context assignement in
	VP_Internal var, vlhs;

// Calls var_assignement and formats it results for module input
let module_in_assignement path context assignement =
	val (var, vlhs) = var_assignement path context assignement in
	VP_Internal var, vlhs2vexpr vlhs;

// Calls var_assignement and formats it results for module output
// Used for calls to precompiled modules
let precomp_out_assignement path context assignement =
	val (VV_Named _ _ name, vlhs) = var_assignement path context assignement in
	VP_External name, vlhs;

// Calls var_assignement and formats it results for module input
// Used for calls to precompiled modules
let precomp_in_assignement path context assignement =
	val (VV_Named _ _ name, vlhs) = var_assignement path context assignement in
	VP_External name, vlhs2vexpr vlhs;

// Adds a node on top of the variable path
let deepen_var node (VV_Named path size name) = VV_Named (node:path) size name
 /\ deepen_var node (VV_Ram path size number) = VV_Ram (node:path) size number
 /\ deepen_var node (VV_Slice path size number) = VV_Slice (node:path) size number;

// Calls var_assignement and formats it results for inlined module output
let inline_out_assignement child_nb path context assignement =
	val (var, vlhs) = var_assignement path context assignement in
	let var_2 = deepen_var child_nb var in
	VS_Assign vlhs (VE_Var var_2);

// Calls var_assignement and formats it results for inlined module input
let inline_in_assignement child_nb path context assignement =
	val (var, vlhs) = var_assignement path context assignement in
	let var_2 = deepen_var child_nb var in
	VS_Assign (V_LHS [VL_Var var_2]) (vlhs2vexpr vlhs);



// Renders a name unique (not present in names)
// By adding _<number> at the end (incrementing number as necessary)
letrec mk_unique names name (NONE) =
		mem name names => mk_unique names name (SOME 0) | name
	/\ mk_unique names name (SOME i) =
		let candidate = name^"_"^(int2str i) in
		mem candidate names => mk_unique names name (SOME (i+1)) | candidate;

// Tries to get a valid module name from a pexlif's name
// Checks names for conflicts
let mk_module_name names pexlif_name =
	let unnamed = mk_unique names DEFAULT_MODULE_NAME FIRST_UNNAMED_NB in
	pexlif_name == ""
		=> unnamed |
	let parts = str_split pexlif_name " " in
	let name = (str_is_prefix "draw_" (hd parts)) => tl parts | parts in
	let str = list2str T "" "_" "" id name in
	(str == "")
		=> unnamed
		|  mk_unique names (MODULE_PREFIX^str) FIRST_MODULE_NB;

// Create a unique module instance name by counting previous occurences
let unique_module_instance path name v_stmts =
	let path_prefix = list2str T "i" "_i" "_" int2str (rev path) in
	let true_name = path_prefix^name in
	letrec runner i ([]) = sprintf "%s_%d" true_name i
		/\ runner i ((VS_ModuleInstanciation name2 _ _ _ _):rest) assuming (name2 == true_name) =
			runner (i+1) rest
		/\ runner i (t:q) = runner i q
	in runner 0 v_stmts;

// Checks if a module aldready exists, if not adds it to modules
// Returns the name given to the new module
let new_module pexlif_name modules m_inputs m_outputs m_internals m_stmts =
	letrec runner names ([]) =
			let m_name = mk_module_name names pexlif_name in
			(m_name, ((VM m_name m_inputs m_outputs m_internals m_stmts):modules))
		/\ runner names ((VM name ins outs ints stmts):rest) =
			((ins == m_inputs) AND (outs == m_outputs) AND (ints == m_internals) AND (m_stmts == stmts))
				=> (name, modules)
				|  runner (name:names) rest
	in runner [] modules;


// ================================================
// Compile pexlif to VerilogModule
// ================================================


forward_declare {pexlif2vmodule:: (pexlif -> bool) ->
	int list ->
	VerilogModule list ->
	precompiled_pexlifs list -> pexlif ->
	((VerilogModule list) # (precompiled_pexlifs list) # VerilogModule)
};


// Iterates through the children of a pexlif
// Arguments
//   <inline_pexlif (pexlif -> bool)> determines whether the pexlif will be inlined
//   <path: int list> path to the current pexlif, used when inlining to avoid name collisions
//     (this is the path of the parent)
//   <context (VerilogVariable list)> list of parent variables (ins, outs, internals)
//   <child_number (int)> the number of the child (0 for list first element)
//   <modules (VerilogModule list)> list of previously compiled modules
//     to avoid duplicates (use [] for root pexlif)
//   <includes (precompiled_pexlifs list)> list of precompiled pexlifs
//     previously encountered to avoid duplicates (use [] for root pexlif)
//   <VerilogStatement list> the previous list of statements (start with [])
//   <pexlif list> the children to compile
// Returns
//   <VerilogModule list> new version of "modules" (adds submodules but NOT current module)
//   <precompiled_pexlifs list> new version of "includes" (adds encountered structures)
//   <VerilogStatement list> the inner list of statements
letrec iter_children inline_pexlif path context child_nb mods incls stmts ([]) =
		mods, incls, stmts
	/\ iter_children inline_pexlif path context child_nb mods incls stmts (t:q) =
		// 1 - Check if the child is one of the known pexlifs
		let rec a b c = iter_children inline_pexlif path context (child_nb+1) a b c q in
		let in_assign func = map (func path context) (pexlif_get_fa_inps t) in
		let out_assign func = map (func path context) (pexlif_get_fa_outs t) in
		// Duplicating because monomorphic...
		let in_assign_2 func = map (func path context) (pexlif_get_fa_inps t) in
		let out_assign_2 func = map (func path context) (pexlif_get_fa_outs t) in
		let precompiled = find_precompiled_match t in
		(has_value precompiled)
			=>
				let p = get_value precompiled in
				let m_name = precompiled_module_name p in
				let ins = in_assign precomp_in_assignement in
				let outs = out_assign precomp_out_assignement in
				let stmt = VS_ModuleInstanciation
					m_name (precompiled_params p ins outs)
					(unique_module_instance path m_name stmts)
					ins outs
				in rec mods (add_unique p incls) (stmt:stmts)
			|
		let inline = inline_pexlif t in
		let rel_path = inline => child_nb:path | [] in
		val (new_mods, new_incls, module) = pexlif2vmodule inline_pexlif rel_path mods incls t in
		val (VM _ m_inputs m_outputs m_internals m_stmts) = module in
		inline
			=>
				rec new_mods new_incls (
					(out_assign_2 (inline_out_assignement child_nb)) @ m_stmts @
					(in_assign_2 (inline_in_assignement child_nb)) @ stmts
				)
			|
		// Make a module call
		val (m_name, new_mods_2) = new_module (pexlif_get_name t)
			new_mods m_inputs m_outputs m_internals m_stmts in
		let stmt = VS_ModuleInstanciation
			m_name [] // no parameters in this module
			(unique_module_instance path m_name stmts)
			(in_assign module_in_assignement)
			(out_assign module_out_assignement)
		in rec new_mods_2 new_incls (stmt:stmts);


// Transform a pexlif into a VerilogModule
// Arguments
//   <inline_pexlif (pexlif -> bool)> determines whether the pexlif will be inlined
//   <modules (VerilogModule list)> list of previously compiled modules
//     to avoid duplicates (use [] for root pexlif)
//   <includes (precompiled_pexlifs list)> list of precompiled pexlifs
//     previously encountered to avoid duplicates (use [] for root pexlif)
//   <pexlif> the pexlif to compile
// Returns
//   <VerilogModule list> new version of "modules" (adds submodules but NOT current module)
//   <precompiled_pexlifs list> new version of "includes" (adds encountered structures)
//   <VerilogModule> the compiled pexlif
letrec pexlif2vmodule inline_pexlif path modules includes pex =
	val (PINST name attrs leaf fa_inps fa_outs ints contents) = pex in
	let vec2var = vector2var path in
	let input_vars = map (vec2var # fst) fa_inps in
	let output_vars = map (vec2var # fst) fa_outs in
	let internal_vars = map vec2var ints in
	let io_vars = input_vars @ output_vars in
	let context = internal_vars @ io_vars in
	val (new_modules, new_includes, statements) =
		leaf =>
			// Compile leaf
			let upd_fns = content_get_leaf contents in
			let stmts = update_fn2vstmt path upd_fns [] in
			(modules, includes, stmts)
		|
			// Recursive call on all children
			iter_children inline_pexlif path context FIRST_CHILD_NB
				modules includes [] (content_get_children contents)
	in
	let clean_statements = remove_redundant io_vars statements in
	let new_ints = (setify (vs_list_find_vars clean_statements)) subtract (io_vars) in
	(
		new_modules,
		new_includes,
		VM MAIN_MODULE_NAME input_vars output_vars new_ints clean_statements
	);

// Transform a pexlif into a VerilogFile
// Arguments
//   <inline_pexlif (pexlif -> bool)> determines whether the pexlif will be inlined
//   <phase_delay_handler> decides how phases delays are handled
//   <pexlif> the pexlif to compile
// Returns a VerilogFile object
let pexlif2vfile inline_pexlif pex =
	val (modules, includes, main) = pexlif2vmodule inline_pexlif [] [] [] pex in
	VF main modules includes;
