// This file contains the verilog abstract syntax tree (ast)
// used by pexlif2verilog
// This is a small subset of the verilog 2005 ast,
// it only contains the constructs we use when compiling

cload "ste.fl";

// All the precompiled pexlifs
// the twin edge flip-flop is used to substitute phase delays
// it is not actually recognized
lettype precompiled_pexlifs =
	RE_FF | RE_FF_RESET | RE_FF_EN | RE_FF_EN_RESET | FE_FF |
	AL_LATCH | AH_LATCH;

// ============================
// ยง Verilog AST
// ============================

// Verilog binary operators used
lettype VerilogBinop =
	V_Add | V_Sub | V_Mul | V_Div | V_Mod |
	V_And | V_Or | // These are bitwise, not logical
	V_Eq | V_Gt |
	V_ShiftLeft | V_ShiftRight | V_ArithShiftRight;

// We only need a subset of verilog constants:
// - unknown (all X's)
// - integers
lettype VerilogConstant =
		VC_X {size::int}
	|	VC_Int {size::int} {value::int};

// We have two variable type to distinguish :
// - those found in the pexlif (Named)
// - the intermediaries added by the compiler
//    - some for slices
//    - some for ram writes
// The path attribute is used when inlining pexlifs
// to avoid name collisions. It is [] for the toplevel
// and [child_number] for the children, [grandchild, child] for grandchildren...
lettype VerilogVariable =
		VV_Named {path::int list} {size::int} {name::string}
	|	VV_Slice {path::int list} {size::int} {number::int}
	| VV_Ram {path::int list} {size::int} {number::int};

lettype VerilogExpression =
		VE_Var VerilogVariable
	| VE_Constant VerilogConstant
	|	VE_Binop VerilogExpression VerilogBinop VerilogExpression
	|	VE_Not VerilogExpression
	| VE_IfThenElse VerilogExpression VerilogExpression VerilogExpression
	| VE_Concat (VerilogExpression list) // {expr1, expr2, ...}
	| VE_Replicate int VerilogExpression // number{expr}
	| VE_Slice bit_range VerilogVariable // identifier[range]
	| VE_OffsetSlice {msb::VerilogExpression} {width::int}
			{var::VerilogVariable} // identifier[msb -: width]
;

// Simple left hand side expression
lettype VerilogSimpleLHS =
		VL_Var VerilogVariable
	| VL_Slice bit_range VerilogVariable;

// Left hand side expression
// A concatenation of variable and/or slices
lettype VerilogLHS = V_LHS (VerilogSimpleLHS list);

// Module port are either internal (for our module)
// or external (for other modules, namely precompiled ones)
lettype VerilogPort = VP_Internal VerilogVariable | VP_External string;

// The write ram construct isn't really verilog AST... It stands for:
// 	always begin
// 		lhs = ram
// 		lhs[DATA_SZ*(addr+1)-1 -: DATA_SZ] = data
// 	end
lettype VerilogStatement =
		VS_Assign {lhs::VerilogLHS} {rhs::VerilogExpression}
	| VS_Write_RAM {lhs::VerilogVariable} {ram::VerilogExpression}
			{msb::VerilogExpression} {offset::int}
			{data::VerilogExpression}
	| VS_ModuleInstanciation {module_name::string}
			{parameters::(string # int) list}
			{instance::string} // a unique string
			{module_inputs::(VerilogPort # VerilogExpression) list}
			{module_outputs::(VerilogPort # VerilogLHS) list}
	;

lettype VerilogModule = VM
	{name::string}
	{module_inputs::VerilogVariable list}
	{module_outputs::VerilogVariable list}
	{module_internals::VerilogVariable list}
	{statements::VerilogStatement list};

lettype VerilogFile = VF
	{main::VerilogModule}
	{modules::VerilogModule list}
	{includes::precompiled_pexlifs list};

// ============================
// ยง simple_wexpr
// ============================

// This is a restricted (simpler) version of simple_wexpr
// Additional constraints for a well formed-type:
//  - No nested slices (SW_SLICE _ (SW_SLICE ...))
//  - No slices of SW_CONST or SW_X
//  - No slices of concats (SW_SLICE _ (SW_CAT ...))
//  - No nested concats (SW_CAT [..., SW_CAT, ...])
//  - SW_CONST value is signed (in range 2**(sz-1)-1 -- -2**(sz-1))
//  - all SW_SLICE indexes must be in the correct range
//    (between 0 and (arg_size-1) inclusive)
//  - slices may contain the smame index multiple times
lettype simple_wexpr =
		SW_X {sz::int}
	|	SW_CONST {sz::int} {value::int}
	|	SW_VAR {sz::int} {name::string}
	|	SW_BINOP {a::simple_wexpr} {op::VerilogBinop} {b::simple_wexpr}
	|	SW_NOT {a::simple_wexpr}
	|	SW_ITE {cond::simple_wexpr} {if_true::simple_wexpr} {if_false::simple_wexpr}
	|	SW_SLICE {indices::int list} {a::simple_wexpr}
	|	SW_CAT {parts::simple_wexpr list}
	|	SW_MEM_READ {info::mem} {mem::simple_wexpr} {addr::simple_wexpr}
	|	SW_MEM_WRITE {info::mem} {mem::simple_wexpr} {addr::simple_wexpr} {data::simple_wexpr};
