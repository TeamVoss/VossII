// This file contains various utility functions
// such those fetching size of the different types
//
// File sections:
//  - Constants
//  - Integer arithmetic
//  - Type size functions
//  - Printers
//  - Misc functions

cload (DIR^"ast.fl");


// ======================================
// § Constants
// ======================================

let NEWLINE = "\n";
let INDENT  = "\t";
let NEWLINE_INDENT = NEWLINE^INDENT;

// Prefix added to vars to avoid name conflicts
// All prefixes ends must start with "_" (unless also changing var_format_prefix)
// All prefixes must be non empty...
let VAR_PREFIX = "v";
let VAR_PREFIX_END = "_";
let SLICE_VAR_PREFIX = "l";
let SLICE_VAR_PREFIX_END = "_slice_";
let RAM_VAR_PREFIX = "l";
let RAM_VAR_PREFIX_END = "_ram_";

// Format a prefix from a variable path
// There must be no possible collision between prefix from different paths !
// Here we have
//   path = []       -> "v_"
//   path = [1,2,3]  -> "vi1_i2_i3__"
let var_format_prefix prefix_deb prefix_end path =
	prefix_deb^(list2str F "i" "_i" "_" int2str path)^prefix_end;

// All three should not conflict
let MODULE_PREFIX = "m_";
let MAIN_MODULE_NAME = "main";
let DEFAULT_MODULE_NAME = "unnamed"; // Followed by the module number

let FILE_PREFIX = "// File generated from an fl pexlif by pexlif2verilog"^NEWLINE;

// Should children numbering start at 0 or 1 ?
let FIRST_CHILD_NB = 1;
// How named modules are numbered
//  - NONE -> start with no number ("name"), then name_0, then name_1...
//  - SOME i -> start with _i
let FIRST_MODULE_NB = NONE;
// How unnamed modules are numbered
let FIRST_UNNAMED_NB = SOME 1;

// If true, remove simple variables (one two one mappings : a = b)
let SIMPLE_VAR_INLINING = T;

// ======================================
// § Integer Arithmetic
// ======================================

// Return the bit at pos bit_pos of integer
let get_bit bit_pos integer =
	(integer intAND (2**bit_pos)) != 0;

// Reduces a value to fit in a signed or unsigned
// int of size sz
let modulo_reduce sz value =
	(value >= 0) => value % 2**sz | value % (-(2**(sz-1) + 1));

// Returns an unsigned reprensentation of value for sz bits
// value should be between (2**sz) - 1 and -(2**(sz-1))
let get_unsigned sz value =
	let rvalue = modulo_reduce sz value in
	(rvalue >= 0)
		=> rvalue
		|  2**sz + rvalue;

// Returns an unsigned reprensentation of value for sz bits
// value should be between (2**sz) - 1 and -(2**(sz-1))
let get_signed sz value =
	let rvalue = modulo_reduce sz value in
	(rvalue >= 2**(sz-1))
		=> rvalue - (2**sz)
		|  rvalue;


// left >>> right, assuming they have size sz bits
// Returns signed values
let arithmetic_right_shift sz left right =
	let l = get_unsigned sz left in
	let r = get_unsigned sz right in
	let shifted = (l / 2**r) in
	get_signed sz (
		(get_bit (sz - 1) l)
			=> shifted intOR ((2**sz - 1) intXOR (2**(sz-r) - 1))
			|  shifted
	);

// left >> right, assuming they have size sz bits
// Returns signed values
let right_shift sz left right =
	let l = get_unsigned sz left in
	let r = get_unsigned sz right in
	get_signed sz (l / 2**r);

// left << right, assuming they have size sz bits
// Returns signed values
let left_shift sz left right =
	let l = get_unsigned sz left in
	let r = get_unsigned sz right in
	get_signed sz (l * 2**r);


// ======================================
// § Vector manipulation
// ======================================

let pexlif_get_children (PINST _ _ leaf _ _ _ (P_HIER c)) = c
 /\ pexlif_get_children _ = [];

// returns the name of a vector (everything before "[")
let vector_name vec =
	val (TXT candidate) = hd (md_split_vector vec) in
	str_is_suffix "[" candidate => string_butlast candidate | candidate;

// Transform a vector into a verilog variable with the given path
let vector2var path vec =
	VV_Named path (md_size vec) (vector_name vec);

// Returns the first element of the list which satisfies predicate pred
letrec get_first pred ([]) = eprintf "No element matching the given predicate"
    /\ get_first pred (t:q) assuming (pred t) = t
		/\ get_first pred (t:q) = get_first pred q;

// ======================================
// § Type sizes
// ======================================


// The size (in bits) of a VerilogVariable
let vvar_size (VV_Named _ sz _) = sz
 /\ vvar_size (VV_Slice _ sz _) = sz
 /\ vvar_size (VV_Ram _ sz _)   = sz;

// The size (in bits) of a VerilogConstant
let vconst_size (VC_X sz) = sz
 /\ vconst_size (VC_Int sz _) = sz;

// Returns T if a binary operator is a comparator
// (i.e. does it change the size of the result to 1)
let is_comparator V_Eq = T
 /\ is_comparator V_Gt = T
 /\ is_comparator _    = F;

// Returns T if a binary operator is bitwise (commmutes with slice)
// (i.e. does it change the size of the result to 1)
let is_bitwise V_And = T
 /\ is_bitwise V_Or  = T
 /\ is_bitwise _     = F;

// Sums the values of the list
letrec sum_list f ([]) = 0
    /\ sum_list f (t:q) = (f t) + (sum_list f q);

// The size (in bits) of a VerilogExpression
letrec vexpr_size (VE_Var var) = vvar_size var
	/\ vexpr_size (VE_Constant const) = vconst_size const
	/\ vexpr_size (VE_Binop left op _) =
		is_comparator op => 1 | vexpr_size left
	/\ vexpr_size (VE_IfThenElse _ if_true _) =
		vexpr_size if_true
	/\ vexpr_size (VE_Not operand) = vexpr_size operand
	/\ vexpr_size (VE_Concat vexprs) =
		sum_list vexpr_size vexprs
	/\ vexpr_size (VE_Replicate nb expr) = nb*(vexpr_size expr)
	/\ vexpr_size (VE_Slice br _) = bit_range_size br;

// The size (in bits) of a VerilogSimpleLHS
let vslhs_size (VL_Var var) = vvar_size var
 /\ vslhs_size (VL_Slice br _) = bit_range_size br;

// The size (in bits) of a VerilogLHS
let vlhs_size (V_LHS parts) = sum_list vslhs_size parts;

// The size (in bits) of a simple_wexpr
letrec swexpr_size (SW_X sz) = sz
	/\ swexpr_size (SW_CONST sz _) = sz
	/\ swexpr_size (SW_VAR sz _) = sz
	/\ swexpr_size (SW_BINOP left op _) =
		is_comparator op => 1 | swexpr_size left
	/\ swexpr_size (SW_NOT a) = swexpr_size a
	/\ swexpr_size (SW_ITE _ if_true _) =
		swexpr_size if_true
	/\ swexpr_size (SW_CAT swexprs) =
		sum_list swexpr_size swexprs
	/\ swexpr_size (SW_SLICE indices a) = length indices;

// The number of slice in a swexpr
// excluding direct slices of a variable
letrec count_slices (SW_X _) = 0
	/\ count_slices (SW_CONST _ _) = 0
	/\ count_slices (SW_VAR _ _) = 0
	/\ count_slices (SW_BINOP left _ right) =
		(count_slices left) + (count_slices right)
	/\ count_slices (SW_NOT a) = count_slices a
	/\ count_slices (SW_ITE c t e) =
		(count_slices c) + (count_slices t) + (count_slices e)
	/\ count_slices (SW_CAT swexprs) =
		sum_list count_slices swexprs
	/\ count_slices (SW_SLICE _ (SW_VAR _ _)) = 0
	/\ count_slices (SW_SLICE _ a) = 1 + (count_slices a);


// ======================================
// § Printers
// ======================================

letrec sprint_binop  (V_Add) = "V_Add"
	/\ sprint_binop (V_Sub) = "V_Sub"
	/\ sprint_binop (V_Mul) = "V_Mul"
	/\ sprint_binop (V_Div) = "V_Div"
	/\ sprint_binop (V_Mod) = "V_Mod"
	/\ sprint_binop (V_And) = "V_And"
	/\ sprint_binop (V_Or) = "V_Or"
	/\ sprint_binop (V_Eq) = "V_Eq"
	/\ sprint_binop (V_Gt) = "V_Gt"
	/\ sprint_binop (V_ShiftLeft) = "V_ShiftLeft"
	/\ sprint_binop (V_ShiftRight) = "V_ShiftRight"
	/\ sprint_binop (V_ArithShiftRight) = "V_ArithShiftRight";

install_print_function sprint_binop;

letrec sprint_swexpr (SW_X sz) = sprintf "SW_X %d" sz
	/\ sprint_swexpr (SW_CONST sz value) = sprintf "SW_CONST %d %d" sz value
	/\ sprint_swexpr (SW_VAR sz name) = sprintf "SW_VAR %d %s" sz name
	/\ sprint_swexpr (SW_BINOP left op right) =
		sprintf "SW_BINOP %s (%s) (%s)" (sprint_binop op) (sprint_swexpr left) (sprint_swexpr right)
	/\ sprint_swexpr (SW_NOT a) = sprintf "SW_NOT (%s)" (sprint_swexpr a)
	/\ sprint_swexpr (SW_ITE c t e) =
		sprintf "SW_ITE (%s) (%s) (%s)" (sprint_swexpr c) (sprint_swexpr t) (sprint_swexpr e)
	/\ sprint_swexpr (SW_CAT swexprs) =
		list2str T "[" ", " "]" sprint_swexpr swexprs
	/\ sprint_swexpr (SW_SLICE indices a) =
		sprintf "SW_SLICE %s (%s)" (list2str T  "[" ", " "]" int2str indices) (sprint_swexpr a);

install_print_function sprint_swexpr;


// ======================================
// § Misc functions
// ======================================


// Raises an error with message msg if value is false
let ASSERT msg value = (value) => () | eprintf "ASSERTION FAILURE - %s" msg;

// Replaces all (non-overlapping) occurences of pattens with substitut
let replace string pattern substitut =
	let l = str_split string pattern in
	list2str T "" substitut "" id l;

// Formats a string
//   <string> the string to format
//   <string#string list> a pattern/substitution list used to make replacements
letrec format str ([]) = str
    /\ format str ((pattern, substitut):q) = format (replace str pattern substitut) q;

// Adds an item to a list if it is not aldready present
letrec add_unique item ([]) = [item]
    /\ add_unique item (t:q) assuming (item == t) = t:q
    /\ add_unique item (t:q) = t:(add_unique item q);
