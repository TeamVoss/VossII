// This file contains the functions
// printing verilog to strings

cload (DIR^"ast.fl");
cload (DIR^"utils.fl");
cload (DIR^"precompiled_pexlifs.fl");

// Operator precedence
let operator_precedence (V_Mul) = 8
 /\ operator_precedence (V_Div) = 8
 /\ operator_precedence (V_Mod) = 8
 /\ operator_precedence (V_Add) = 7
 /\ operator_precedence (V_Sub) = 7
 /\ operator_precedence (V_ShiftLeft) = 6
 /\ operator_precedence (V_ShiftRight) = 6
 /\ operator_precedence (V_ArithShiftRight) = 6
 /\ operator_precedence (V_Gt)  = 5
 /\ operator_precedence (V_Eq)  = 4
 /\ operator_precedence (V_And) = 3
 /\ operator_precedence (V_Or)  = 3;

// Is an operator associative (a op b) op c = a op (b op c) ?
let is_associative (V_Mul) = T
 /\ is_associative (V_Add) = T
 /\ is_associative (V_Sub) = T
 /\ is_associative (V_And) = T
 /\ is_associative (V_Or)  = T
 /\ is_associative op = F;

// Operator precedence
let vexpr_precedence (VE_Var _)           = 14
 /\ vexpr_precedence (VE_Constant _)      = 14
 /\ vexpr_precedence (VE_Slice _ _)       = 14
 /\ vexpr_precedence (VE_OffsetSlice _ _ _) = 14
 /\ vexpr_precedence (VE_Concat _)        = 14 // Not it's true precedence, but non ambiguous
 /\ vexpr_precedence (VE_Replicate _ _)   = 14
 /\ vexpr_precedence (VE_Not _)           = 12
 /\ vexpr_precedence (VE_Binop _ op _) = operator_precedence op
 /\ vexpr_precedence (VE_IfThenElse _ _ _) = 1;


// Verilog representation of the operator
let operator2string (V_Mul) = "*"
 /\ operator2string (V_Div) = "/"
 /\ operator2string (V_Mod) = "%"
 /\ operator2string (V_Add) = "+"
 /\ operator2string (V_Sub) = "-"
 /\ operator2string (V_ShiftLeft) = "<<"
 /\ operator2string (V_ShiftRight) = ">>"
 /\ operator2string (V_ArithShiftRight) = ">>>"
 /\ operator2string (V_Gt)  = ">"
 /\ operator2string (V_Eq)  = "=="
 /\ operator2string (V_And) = "&"
 /\ operator2string (V_Or)  = "|";

clet IDENTIFIER_START_LEGAL_CHARACTERS = explode "_azertyuiopqsdfghjklmwxcvbnAZERTYUIOPQSDFGHJKLMWXCVBN";
clet IDENTIFIER_LEGAL_CHARACTERS = (explode "_0123456789$") @ IDENTIFIER_START_LEGAL_CHARACTERS;

// Does a variable name need escaping ?
let needs_escaping s =
	let exploded = explode s in
	(NOT (mem (hd exploded) (IDENTIFIER_START_LEGAL_CHARACTERS))) OR (
		(find_first0 (\c. NOT (mem c IDENTIFIER_LEGAL_CHARACTERS)) (tl exploded)) != 0
	);

// Only escape a var if essential
// assumes
let manage_escape pre name =
	let true_name = str_is_prefix "\\" name
		=> pre ^ (string_butfirst name)
		|  pre ^ name
	in (needs_escaping true_name)
		=> "\\"^true_name^" "
		|  true_name;


// Converts var to a string
let vvar2string (VV_Named path sz name) =
	manage_escape (var_format_prefix VAR_PREFIX VAR_PREFIX_END (rev path)) name
 /\ vvar2string (VV_Slice path sz nb) =
	manage_escape (var_format_prefix SLICE_VAR_PREFIX SLICE_VAR_PREFIX_END (rev path))
	(int2str nb)
 /\ vvar2string (VV_Ram path sz nb) =
	manage_escape (var_format_prefix RAM_VAR_PREFIX RAM_VAR_PREFIX_END (rev path))
	(int2str nb);


// Converts a constant to a verilog formatted one
// ex 1'sb0, 4'sbxxxx...
let vconst2string (VC_X sz) =
	ASSERT "Negative VC_X constant size" (sz > 0) fseq
	letrec make_str 0 = ""
	    /\ make_str i = "x"^(make_str (i-1)) in
	sprintf "%d'sb%s" sz (make_str sz)
 /\ vconst2string (VC_Int sz value) =
	ASSERT "Negative VC_Int constant size" (sz > 0) fseq
	letrec make_str 0 = ""
		/\ make_str i =
			let j = i-1 in
			(get_bit j value => "1" | "0")^(make_str j) in
	sprintf "%d'sb%s" sz (make_str sz);


// Partial application to save common arguments
let concat2string = list2str T "{" ", " "}";

// Converts a slice to a verilog string
let slice2string range var =
	sprintf "%s[%s]" (vvar2string var) (sprint_bit_range range);

// Converts a VerilogExpression to a verilog string
letrec vexpr2string expr =
	let precedence = vexpr_precedence expr in
	let rec_call new_expr =
		// Check for parentheses and adds them if needed
		let inner_string = vexpr2string new_expr in
		(precedence < vexpr_precedence new_expr)
			=> inner_string
			|  "("^inner_string^")" in
	let binop_rec_call op (VE_Binop l op2 r) assuming (op == op2 AND is_associative op) =
		// Avoid parentheses around associative operators
		vexpr2string (VE_Binop l op2 r)
	 /\ binop_rec_call _ new_expr = rec_call new_expr in
	let match (VE_Var var) = vvar2string var
		/\ match (VE_Constant const) = vconst2string const
		/\ match (VE_Not a) = sprintf "~%s" (rec_call a)
		/\ match (VE_Binop a op b) =
			sprintf "%s %s %s"
			(binop_rec_call op a) (operator2string op) (binop_rec_call op b)
		/\ match (VE_IfThenElse c t e) =
			sprintf "%s ? %s : %s" (rec_call c) (rec_call t) (rec_call e)
		/\ match (VE_Concat parts) =
			concat2string vexpr2string parts
		/\ match (VE_Replicate nb a) = sprintf "{%d{%s}}" nb (vexpr2string a)
		/\ match (VE_Slice range var) = slice2string range var
		/\ match (VE_OffsetSlice expr offset var) =
			sprintf "%s[%s -: %d]" (vvar2string var) (vexpr2string expr) offset
	in match expr;

// Converts a VerilogSimpleLHS to a verilog string
let vslhs2string (VL_Var var) = vvar2string var
 /\ vslhs2string (VL_Slice range var) = slice2string range var;

// Converts a VerilogLHS to a verilog string
let vlhs2string (V_LHS [single]) = vslhs2string single
 /\ vlhs2string (V_LHS slhs) = concat2string vslhs2string slhs;

// Converts a verilog port to a string
let vport2string (VP_Internal var) = vvar2string var
 /\ vport2string (VP_External str) = str;

// Used to print a parameter list or IO list
let port2string func_l func_r (name, value) =
	sprintf ".%s(%s)" (func_l name) (func_r value);

let parenthese_list begin "" join "" end = ""
 /\ parenthese_list begin left join "" end = begin^left^end
 /\ parenthese_list begin "" join right end = begin^right^end
 /\ parenthese_list begin left join right end = begin^left^join^right^end;


// Converts a VerilogStatement to a verilog string
let vstmt2string (VS_Assign lhs rhs) =
	sprintf "assign %s = %s;" (vlhs2string lhs) (vexpr2string rhs)
 /\ vstmt2string (VS_Write_RAM var memory addr offset data) =
	let var_str = vvar2string var in
	sprintf "always begin%s%s = %s;%s%s[%s :- %d] = %s;%send"
		NEWLINE_INDENT
		var_str (vexpr2string memory) NEWLINE_INDENT
		var_str (vexpr2string addr) offset (vexpr2string data) NEWLINE
 /\ vstmt2string (VS_ModuleInstanciation name parameters instance ins outs) =
	let params = list2str F " #(" ", " ")" (port2string id int2str) parameters in
	let ins_str = list2str F INDENT ", " "" (port2string vport2string vexpr2string) ins in
	let outs_str = list2str F INDENT ", " "" (port2string vport2string vlhs2string) outs in
	sprintf "%s%s %s(%s);" (manage_escape "" name) params (manage_escape "" instance)
		(parenthese_list NEWLINE ins_str (","^NEWLINE) outs_str NEWLINE);

// Adds indent to the given string
let add_indent str = INDENT^(replace str NEWLINE NEWLINE_INDENT);

// Converts a VerilogStatement list to a verilog string
let vstmt_list2string s = list2str F "" NEWLINE NEWLINE (add_indent # vstmt2string) (rev s);

// print an input/output definition to string
// type should be input, output or wire
let decl2string type var =
	let sz = vvar_size var in
	sz == 1
		=> sprintf "%s %s" type (vvar2string var)
	  | sprintf "%s signed[%d:0] %s" type (sz-1) (vvar2string var);

// Converts a VerilogModule to a verilog string
let vmodule2string (VM name ins outs internals statements) =
	let ins_str = (
		list2str F (INDENT^"// Inputs :"^NEWLINE_INDENT) (","^NEWLINE_INDENT) ""
		(decl2string "input") ins) in
	let outs_str =
		(list2str F (INDENT^"// Outputs :"^NEWLINE_INDENT)  (","^NEWLINE_INDENT) ""
		(decl2string "output") outs) in
	let ints_str =
		(list2str F (INDENT^"// Internal wires :"^NEWLINE_INDENT)  (";"^NEWLINE_INDENT)
		(";"^NEWLINE) (decl2string "wire") (rev internals)) in
	sprintf "module %s (%s);%s%s%s// Module code :%s%sendmodule"
		(manage_escape "" name)
		(parenthese_list NEWLINE ins_str (","^NEWLINE) outs_str NEWLINE) NEWLINE
		ints_str
		INDENT NEWLINE
		(vstmt_list2string statements);

// Visual delimiter
let delimiter s =
	sprintf "%s// ====================================%s// ยง %s%s// ====================================%s%s"
	NEWLINE NEWLINE s NEWLINE NEWLINE NEWLINE;

// Converts a VerilogFile to a printable string
let vfile2string (VF main modules includes) =
	let str_modules = (length modules == 0)
		=> ""
		|  (delimiter "Sub modules")^(
			list2str T "" (NEWLINE^NEWLINE) NEWLINE vmodule2string (rev modules)
		) in
	let str_includes = (length includes == 0)
		=> ""
		|  (delimiter "Precompiled modules")^(
			list2str T "" (NEWLINE^NEWLINE) NEWLINE precompiled_code includes
		) in
	sprintf "%s%s%s%s%s%s%s"
		FILE_PREFIX NEWLINE
		(delimiter "Main module")
		(vmodule2string main) NEWLINE
		str_modules
		str_includes;
