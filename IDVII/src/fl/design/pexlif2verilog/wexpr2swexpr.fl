// This file contains the function
// transforming a wexpr into a simple format swexpr
// which is then transformed into a verilog_expression
//
// File sections:
// - replace W_UPDATE_NAMED_SLICE with W_CAT [W_SLICE ...]
// - Simple constructs cleaning (computes result for know operations)
// - Cleaning SW_SLICE and SW_CAT. This insure the following
//    - No nested SW_SLICE _ (SW_SLICE) ...
//    - No nested (SW_CAT [..., SW_CAT [...], ...])
//    - No SW_SLICE _ (SW_CAT ...)
// - Main wexpr2swexpr function

cload (DIR^"ast.fl");
cload (DIR^"utils.fl");


// ============================================================
// ยง replace W_UPDATE_NAMED_SLICE with W_CAT [W_SLICE ...]
// ============================================================
0;


// Returns the list complementary indices
//   <max_index (int)> the maximum index
//   <indices (int list)> list of indices smaller than max_index
// Returns a list of size max_index containing
// - i in position indices[i]
// - -1 in position that don't appear in indices
// Ex bit_position 4 [3,1] -> [-1,0,-1,1,-1]
letrec bit_position index _ assuming (index < 0) = []
    /\ bit_position index indices =
		((find_first0 (\x. x = index) indices)-1)
		:(bit_position (index-1) indices);

// Regroups slice in a concatenation list by common expressions
// i.e. regroup_slice [SW_SLICE [0] a, SW_SLICE [1] a, SW_SLICE [0] b]
//  -> [SW_SLICE [0,1] a, SW_SLICE [0] b]
letrec regroup_slices (t:[]) = [t]
    /\ regroup_slices ((W_SLICE i expr1):q1) =
			val ((W_SLICE j expr2):q2) = regroup_slices q1 in
			expr1 = expr2 => (W_SLICE (i@j) expr1):q2
			              |  (W_SLICE i expr1):(W_SLICE j expr2):q2;

// transforms W_UPDATE_NAMED_SLICE into
// a concatenation of slices (W_CAT [W_SLICE, ... W_SLICE])
let transform_update_named_slice
	base name indices replacement =
	let size_base = wexpr_size base in
	let position = bit_position (size_base-1) (rev indices) in
	let runner pos i assuming (pos = -1) = W_SLICE [size_base-i] base
	 /\ runner pos i = W_SLICE [pos] replacement in
	let cat_list = ixmap runner position in
	W_CAT (regroup_slices cat_list);


// ============================================================
// ยง Simple constructs cleaning
// ============================================================
0;

// SW_CONST should be signed
let clean_const sz integer = SW_CONST sz (get_signed sz integer);

// Check if a value is the constant 1
let is_const_1 (SW_CONST sz v) = v == 1 OR ((v == -1) AND (sz == 1))
 /\ is_const_1 _ = F;

// Check if a value is the constant -1
let is_const_n1 (SW_CONST _ v) = v == -1
 /\ is_const_n1 _ = F;

// Utility function to simplify a swexpr binary operation
// arguments:
//   func - the operation: it takes three arguments
//     the size and both operands.
//   op - the binop constructor (V_Add, V_Eq...)
//   left, right - the two operands (aldready cleaned)
// This is purely an optimization, can be safely removed
let clean_binop func op (SW_CONST sz a) (SW_CONST _ b) =
		SW_CONST (is_comparator op => 1 | sz) (func sz a b)
	// Neutral/Absorbant element simplification
	/\ clean_binop _ V_Add (SW_CONST _ 0) b = b
	/\ clean_binop _ V_Add a (SW_CONST _ 0) = a
	/\ clean_binop _ V_Mul (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_Mul _ (SW_CONST s 0) = SW_CONST s 0
	/\ clean_binop _ V_Mul a b assuming (is_const_1 a) = b
	/\ clean_binop _ V_Mul a b assuming (is_const_1 b) = a
	/\ clean_binop _ V_Div (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_Div a b assuming (is_const_1 b) = a
	/\ clean_binop _ V_Mod (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_Mod a b assuming (is_const_1 b) = SW_CONST (swexpr_size b) 0
	/\ clean_binop _ V_And (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_And _ (SW_CONST s 0) = SW_CONST s 0
	/\ clean_binop _ V_And a b assuming (is_const_n1 a) = b
	/\ clean_binop _ V_And a b assuming (is_const_n1 b) = a
	/\ clean_binop _ V_Or  (SW_CONST s 0) b = b
	/\ clean_binop _ V_Or  a (SW_CONST s 0) = a
	/\ clean_binop _ V_Or  a b assuming (is_const_n1 a) = a
	/\ clean_binop _ V_Or  a b assuming (is_const_n1 b) = b
	/\ clean_binop _ V_ShiftLeft (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_ShiftLeft a (SW_CONST s 0) = a
	/\ clean_binop _ V_ShiftRight (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_ShiftRight a (SW_CONST s 0) = a
	/\ clean_binop _ V_ArithShiftRight (SW_CONST s 0) _ = SW_CONST s 0
	/\ clean_binop _ V_ArithShiftRight a _ assuming (is_const_n1 a) = a
	/\ clean_binop _ V_ArithShiftRight a (SW_CONST s 0) = a
	/\ clean_binop _ op (SW_X _) _ assuming (is_comparator op) = SW_X 1
	/\ clean_binop _ op _ (SW_X _) assuming (is_comparator op) = SW_X 1
	/\ clean_binop _ op left right = SW_BINOP left op right;

// Utility function to simplify a swexpr SW_NOT
// argument: the argument of SW_NOT
// This is purely an optimization, can be safely removed
let clean_not (SW_X sz) = SW_X sz
 /\ clean_not (SW_CONST sz value) = clean_const sz (intNOT value)
 /\ clean_not w_expr = SW_NOT w_expr;

// Small simplification for a SW_ITE
// The arguments are the aldready cleaned operants
// This is purely an optimization, can be safely removed
let clean_ite (SW_CONST _ 0) _ if_false = if_false
 /\ clean_ite (SW_CONST _ _) if_true _ = if_true
 /\ clean_ite cond if_true if_false =
	(if_true == if_false)
		=> if_true
		|  SW_ITE cond if_true if_false;


// ============================================================
// ยง Cleaning SW_CAT and SW_SLICE
// ============================================================
// Some optimization to limit number of slices
// but mostly this insures these important properties
//  - No nested SW_SLICE _ (SW_SLICE) ...
//  - No nested (SW_CAT [..., SW_CAT [...], ...])
//  - No SW_SLICE _ (SW_CAT ...)
0;


// Returns a sliced int.
// I.E. selects the relevant bits and concatenated them
// Arguments:
//   <indexes (int list)> list of bit positions to select
//   <integer (int)> the integer to slice
// returns 0b[integer[indexes[0]], [integer[indexes[1]]...]
let slice_int indexes integer =
	letrec slice_int_rec value ([]) = value
		/\ slice_int_rec value (t:q) =
			let new_value = (get_bit t integer) => value*2+1 | value*2 in
			slice_int_rec new_value q
	in slice_int_rec 0 indexes;

// Returns the pos ranges of concatenation of swexpr
// get_part_ranges [<swexpr of width 5>, <swexpr of width 3>]
//  -> [SLICE 7 3, SLICE 2 0]
let get_part_ranges parts =
	letrec runner ([]) = (0, [])
		/\ runner (t:q) =
			val (maxi, ranges) = runner q in
			let sz = swexpr_size t in
			let new_maxi = maxi + sz in
			sz == 1 => (new_maxi, (BR_SINGLE maxi):ranges)
			        |  (new_maxi, (BR_SLICE (maxi+sz-1) maxi):ranges)
	in snd (runner parts);

// Returns the index_range and part that contain the index number
// Inputs:
//   <number (int)> the index we are searching for
//   <indexes (bit_range list)> the list of indexes
//     genrated by get_part_ranges parts
//   <parts (simple_wexpr list)> the list of parts
// This is basically a rewrite of find_first that returns
// more useful information for clean_slice
letrec find_matching_range number ([]) _ =
		eprintf "Invalid slice: selecting indexes out of range"
	/\ find_matching_range number (r:r_rest) (p:p_rest) assuming
		(bit_range_contains r number) = (r,p)
	/\ find_matching_range number (r:r_rest) (p:p_rest) =
		find_matching_range number r_rest p_rest;

forward_declare {clean_cat :: (simple_wexpr list) -> simple_wexpr};

// Simpification of slices
// slices are annoying as verilog only allows slice of identifiers
// so we try to get them as low level as possible
//
// Cleaning of nested slices and cat is a strong assumption and
// must remain true
// Cleaning of other constructs is an optionnal optimisation
letrec clean_slice indices swexpr =
	// printf "clean_slice %s %s\n" (list2str T "[" ", " "]" int2str indices) (sprint_swexpr swexpr) fseq
	let l = swexpr_size swexpr in
	// Tests f slicing is taking the whole int
	(indices == (l-1) -- 0)
		=> swexpr
		|
	letrec clean_slice_inner (SW_X _) = SW_X (length indices)
		/\ clean_slice_inner (SW_CONST sz a) =
			clean_const (length indices) (slice_int indices a)
		/\ clean_slice_inner (SW_NOT a) = SW_NOT (clean_slice_inner a)
		/\ clean_slice_inner (SW_SLICE indices_bis a) =
			let offset = (length indices_bis) in
			// (a[indices_bis])[indices] if the same as
			// a[new_i] where new_i[j] = indices_bis[indices[j]]
			let reposition x = el (offset-x) indices_bis in
			clean_slice (map reposition indices) a
		/\ clean_slice_inner (SW_BINOP left op right) assuming (is_bitwise op) =
			// Only simplify bitwise binop if reducing number of slices
			let new_left = clean_slice_inner left in
			let new_right = clean_slice_inner right in
			let old = SW_SLICE indices (SW_BINOP left op right) in
			let new = SW_BINOP new_left op new_right in
			(count_slices old > count_slices new) => new | old
		/\ clean_slice_inner (SW_CAT parts) =
			// Swap the CAT and the SLICE
			let part_ranges = get_part_ranges parts in
			let make_slice index =
				// Create a new slice for each individual index with the relevant part
				val (offset, part) = find_matching_range index part_ranges parts in
				clean_slice [index - (bit_range_lsb offset)] part
			in
			// clean_cat will merge slices of the same part back together
			clean_cat (map make_slice indices)
		/\ clean_slice_inner expr = SW_SLICE indices expr
	in clean_slice_inner swexpr;

// Simplification for a SW_CAT
// Assumes the parts are aldready simplified
//
// Cleaning of nested slices and cat is a strong assumption and
// must remain true
// Cleaning of other constructs is an optionnal optimisation
let clean_cat parts =
	letrec clean_cat_rec ([]) = []
		/\ clean_cat_rec ((SW_CAT inner):rest) = inner @ (clean_cat_rec rest)
		/\ clean_cat_rec ((SW_CONST sz_a a):(SW_CONST sz_b b):rest) =
			// merge two constant being concatenated
			let new_sz = sz_a + sz_b in
			let new_val = get_signed new_sz ((get_unsigned sz_a a)*2**sz_b+(get_unsigned sz_b b)) in
			clean_cat_rec ((clean_const new_sz new_val):rest)
		/\ clean_cat_rec ((SW_SLICE i a):(SW_SLICE j b):rest) assuming (a = b) =
			clean_cat_rec ((clean_slice (i@j) a):rest) // merge similar slices
		/\ clean_cat_rec (t:q) = t:(clean_cat_rec q)
	in
	let new_parts = clean_cat_rec parts in
		(length new_parts == 1) => hd new_parts | SW_CAT new_parts;


// ============================================================
// ยง main function - wexpr2swexpr
// ============================================================
0;


// Transform a bool into 1 or 0
let bool2int op _ a b = (op a b) => 1 | 0;

// transforms a n-argument function
// into a n+1 argument function that throws away it's first argument
let ignore_first f _ = f;

// Transfroms wexpr into an equivalent simpler one:
// - replaces W_NAMED_CONST by SW_CONST
// - replaces W_EXPLICIT_VAR by SW_VAR
// - replaces W_PRED by it's argument
// - computes operations on W_X and constants
// - removes W_ZX and W_SX where the size doesn't strictly grow
// - replaces (W_ZX _ a) with SW_CAT [SW_CONST sz 0, a]
// - replaces (W_SZ _ a) with SW_CAT [SW_SLICE [msb, msb, ...] a, a]
// - replaces W_NAMED_SLICE with SW_SLICE
// - replaces W_UPDATE_NAMED_SLICE with SW_CAT [SW_SLICE ...]
// - flattens nested SW_CAT and SW_SLICE
// - Swaps SW_SLICE (SW_CAT ...) into SW_CAT [SW_SLICE ...]
// - removes single element concats
letrec wexpr2swexpr (W_X sz) = SW_X sz
	/\ wexpr2swexpr (W_NAMED_CONST _ sz v) = clean_const sz v
	/\ wexpr2swexpr (W_CONST sz v) = clean_const sz v
	/\ wexpr2swexpr (W_VAR sz base) = SW_VAR sz (vector_name base)
	/\ wexpr2swexpr (W_EXPLICIT_VAR sz name) = SW_VAR sz (vector_name name)
	/\ wexpr2swexpr (W_NOT a) = clean_not (wexpr2swexpr a)
	/\ wexpr2swexpr (W_PRED name cond) = wexpr2swexpr cond
	/\ wexpr2swexpr (W_AND a b) =
		clean_binop (ignore_first (defix intAND))
		V_And (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_OR  a b) =
		clean_binop (ignore_first (defix intOR))
		V_Or (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_EQ  a b) =
		clean_binop (bool2int (defix ==))
		V_Eq (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_GR  a b) =
		clean_binop (bool2int (defix >))
		V_Gt (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_ADD a b) =
		clean_binop (ignore_first (defix +))
		V_Add (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_SUB a b) =
		clean_binop (ignore_first (defix -))
		V_Sub (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_MUL a b) =
		clean_binop (ignore_first (defix *))
		V_Mul (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_DIV a b) =
		clean_binop (ignore_first (defix /))
		V_Div (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_MOD a b) =
		clean_binop (ignore_first (defix %))
		V_Mod (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_SHL a b) =
		clean_binop left_shift
		V_ShiftLeft (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_SHR a b) =
		clean_binop right_shift
		V_ShiftRight (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_ASHR a b) =
		clean_binop arithmetic_right_shift
		V_ArithShiftRight (wexpr2swexpr a) (wexpr2swexpr b)
	/\ wexpr2swexpr (W_SX sz w) =
		let w_sz = wexpr_size w in
		let clean_w = wexpr2swexpr w in
		(w_sz = sz)
			=> clean_w
			| clean_cat [clean_slice (replicate (sz-w_sz) (w_sz-1)) clean_w, clean_w]
	/\ wexpr2swexpr (W_ZX sz w) =
		let w_sz = wexpr_size w in
		let clean_w = wexpr2swexpr w in
		(w_sz = sz)
			=> clean_w
			| clean_cat [clean_const (sz-w_sz) 0, clean_w]
	/\ wexpr2swexpr (W_ITE c t e) =
		clean_ite (wexpr2swexpr c) (wexpr2swexpr t) (wexpr2swexpr e)
	/\ wexpr2swexpr (W_SLICE indices w) =
		clean_slice indices (wexpr2swexpr w)
	/\ wexpr2swexpr (W_NAMED_SLICE name indices w) =
		wexpr2swexpr (W_SLICE indices w)
	/\ wexpr2swexpr (W_UPDATE_NAMED_SLICE base name indices w) =
		wexpr2swexpr (transform_update_named_slice base name indices w)
	/\ wexpr2swexpr (W_CAT parts) =
		clean_cat (map wexpr2swexpr parts)
	/\ wexpr2swexpr (W_MEM_READ info mem addr) =
		SW_MEM_READ info (wexpr2swexpr mem) (wexpr2swexpr addr)
	/\ wexpr2swexpr (W_MEM_WRITE info mem addr d) =
		SW_MEM_WRITE info (wexpr2swexpr mem) (wexpr2swexpr addr) (wexpr2swexpr d)
;
