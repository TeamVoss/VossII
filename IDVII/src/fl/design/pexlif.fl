//-------------------------------------------------------------------
// Copyright 2020 ...
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

//  shorten_sha::string->string
let shorten_sha sha = "\"" ^ substr sha 1 4 ^ "..\"";

// Fetch attribute 's'. If none exists, returns 'a'.
//  find_attr::string->string->(string#string list)->string
let find_attr s a = snd # find_maybe (defix == s # fst) ("", a);

// Fetch the "fingerprint" attribute, if any.
//  find_fingerprint::(string#string list)->int
let find_fingerprint = s2int # find_attr "FP" "0";

// Fetch the "signature" attribute, if any.
//  find_signature::(string#string list)->string
let find_signature = find_attr "SHA" "";

// Predicate for hierarchical pexlif
let pexlif_is_hier (PINST nm attrs lf fa_inps fa_outs ints (P_HIER cs)) = T
 /\ pexlif_is_hier oter = F
;

let pexlif_get_FP  = find_fingerprint # pexlif_get_attrs;
let pexlif_get_SHA = find_signature   # pexlif_get_attrs;
let pexlif_get_size (PINST _ _ _ _ _ _ (P_HIER cs)) = 1 + length cs
/\  pexlif_get_size _ = 1
;
let pexlif_get_actuals (PINST _ _ _ fa_inps fa_outs _ _) =
        flatmap snd (fa_inps @ fa_outs)
;
let pexlif_get_formals (PINST _ _ _ fa_inps fa_outs _ _) =
        map fst (fa_inps @ fa_outs)
;
let pexlif_get_children (PINST _ _ _ _ _ _ (P_HIER cs)) = cs
/\  pexlif_get_children _ = []
;
let pexlif_get_inps_actuals (PINST _ _ _ fa_inps fa_outs _ _) =
        md_extract_vectors (flatmap snd fa_inps)
;
let pexlif_get_outs_actuals (PINST _ _ _ fa_inps fa_outs _ _) =
        md_extract_vectors (flatmap snd fa_outs)
;
let pexlif_get_name (PINST nm _ _ _ _ _ _) = nm;
let is__WrApPeR_ (PINST nm _ _ _ _ _ (P_HIER _)) = (nm = "_WrApPeR_")
 /\ is__WrApPeR_ _ = F
;

//------------------------------------------------------------------------------
// ...
//------------------------------------------------------------------------------

// Re-define PINST so that we always compute a signature (FP) and
// a SHA256 (SHA) signatures and store them in the attribute list.
// Also, every (non-toplevel) wrapper PINST is unfolded.
let PINST n a l i o t c =
    let mk_pinst n a l i o t c =
	let is_signature s = (s == "FP") OR (s == "SHA") in
	let a' = filter (NOT # is_signature # fst) a in
	let f  = ("FP",  fp_pinst    i o t c) in
	let s  = ("SHA", sha_pinst n i o t c) in
	let process_assertions (P_HIER ps) =
            let get_assert_nd (PINST _ _ _ _ outs _ _) =
                length outs != 1 => [] |
                val (f,as) = hd outs then
                md_size f != 1 => [] |
                let a = hd as in
                str_is_substr "assert__" a => as | []
	    in
            flatmap get_assert_nd ps
	 /\ process_assertions _ =  []
	in
	let assert_nds = process_assertions c then
	(length (setify assert_nds) != length assert_nds) =>
	    let ap = partition id assert_nds in
	    let idx = find_first0 (\l.length l > 1) ap in
	    eprintf "Duplicatated assertion (%s)" (hd (el idx ap))
	|
	let t' = setify (assert_nds @ t) in
	PINST n (f : s : a') l i o t' c
    in
    let get_wrappers (P_HIER chs) = find_all is__WrApPeR_ chs
     /\ get_wrappers _ = []
    in
    let wrappers = get_wrappers c in
    wrappers = [] =>
	mk_pinst n a l i o t c
    |
	// Lift all wrapper pexlifs by unfolding them
	// Process the unfolds in reverse order
	// Relies on unfold1 i does not change children 1--(i-1).
	let wrappers = qsort (\i1.\i2. i1-i2) (setify wrappers) then
	let p = PINST n a l i o t c then
	let p' = itlist (\i.\p. unfold_pexlif p i) wrappers p then
	val (PINST n a l i o t c) = p' then
	mk_pinst n a l i o t c
;


//------------------------------------------------------------------------------
let not_const n = NOT (str_is_prefix "0b" n);
let exp_trim vs = filter not_const vs;
let exp_trim1 v = exp_trim [v];

let vec_intersect vl1 vl2 =
    let mk l =
	let b = fst (hd l) then
	let v = md_extract_vectors (map snd l) then
	(b,v)
    in
    let direct = vl1 intersect vl2 then
    let bl1 = map (\v. get_vector_signature v, v) (vl1 subtract direct) then
    let p1 = map mk (partition fst bl1) then
    let bl2 = map (\v. get_vector_signature v, v) (vl2 subtract direct) then
    let p2 = map mk (partition fst bl2) then
    let base_intersection = (map fst p1) intersect (map fst p2) then
    let find_intersection b =
	let nds1 = md_expand_vectors (assoc b p1) then
	let nds2 = md_expand_vectors (assoc b p2) then
	let nds = nds1 intersect nds2 then
	md_extract_vectors nds
    in
    let rem = flatmap find_intersection base_intersection then
    md_extract_vectors (direct @ rem)
;
infix 7 vec_intersect;

let vec_subtract vl1 vl2 =
    let mk l =
	let b = fst (hd l) then
	let v = md_extract_vectors (map snd l) then
	(b,v)
    in
    let bl1 = map (\v. get_vector_signature v, v) vl1 then
    let p1 = map mk (partition fst bl1) then
    let bl2 = map (\v. get_vector_signature v, v) vl2 then
    let p2 = map mk (partition fst bl2) then
    let do_subtract b =
	let v1s = assoc b p1 then
	let v2s = (assoc b p2) catch [] then
	let in_both = v1s intersect v2s then
	let nds1 = md_expand_vectors (v1s subtract in_both) in
	let nds2 = md_expand_vectors (v2s subtract in_both) in
	md_extract_vectors (nds1 subtract nds2)
    in
    let rem = flatmap do_subtract (map fst p1) then
    md_extract_vectors rem
;
infix 7 vec_subtract;


// Create a new pexlif in which instances in ids have been collected to
// a new hiearchy named 'name'.
let fold_pexlif p il new_name =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p then
    let sel (i,sp) = mem i (setify il) in
    val (sels,rems) = split sel (zip (1 upto (length chs)) chs) in
    let selected = map snd sels in
    let remain = map snd rems in
    let out_producers =
        let get_aouts (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_outs in
        exp_trim ((map fst fa_inps)@(flatmap get_aouts remain))
    in
    let out_consumers =
        let get_ainps (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_inps in
        exp_trim ((map fst fa_outs)@(flatmap get_ainps remain))
    in
    let in_producers =
        let get_aouts (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_outs in
        exp_trim (flatmap get_aouts selected)
    in
    let in_consumers =
        let get_ainps (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_inps in
        exp_trim (flatmap get_ainps selected)
    in
    let sort l = qsort node_name_cmp l in
    let new_outs = in_producers vec_intersect out_consumers in
    let new_inps = in_consumers vec_intersect out_producers in
    let new_ints =
	sort ((in_producers@in_consumers) vec_subtract (new_outs @ new_inps))
    in
    let mk_fa l = map (\v. (v,[v])) (sort l) in
    let cp = PINST new_name [] F (mk_fa new_inps) (mk_fa new_outs) new_ints
                (P_HIER selected)
    in
    let ints' = sort
                    ((out_consumers@out_producers) vec_subtract
                     (exp_trim (map fst (fa_inps@fa_outs))))
    in
    (PINST name attrs leaf fa_inps fa_outs ints' (P_HIER (cp:remain)))
;

// 
// Create new instances for each group in the grouping list.
// An entry in the grouping list consists of a name of the new group
// and a list of indices for the instances to group into this new group.
let foldn_pexlif p grl =
    let all_sel = flatmap snd grl in
    letrec select used ((lbl,sel):sels) =
	let overlap = sel intersect used then
	overlap == [] => (lbl,sel):(select (sel@used) sels) |
	(fprintf stdinfo "Overlapping selection in foldn_pexlif (%S)\n"
		(map int2str overlap)) fseq
	select used sels
     /\    select used [] = []
    in
    let grl' = select [] grl then
    let ill = map snd grl' then
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p then
    let get_sel il = map (\i. el i chs) il in
    let selected_l = map get_sel ill then
    let remain = get_sel ((1 upto (length chs)) subtract all_sel) then
    let get_ifcs pl =
	let producers =
	    let get_aouts (PINST _ _ _ fa_inps fa_outs _ _) =
		flatmap snd fa_outs
	    in
	    exp_trim (flatmap get_aouts pl)
	in
	let consumers =
	    let get_ainps (PINST _ _ _ fa_inps fa_outs _ _) =
		flatmap snd fa_inps
	    in
	    exp_trim (flatmap get_ainps pl)
	in
	(producers, consumers)
    in
    let ifcs = map get_ifcs selected_l then
    let rem_producers =
        let get_aouts (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_outs in
        exp_trim ((map fst fa_inps)@(flatmap get_aouts remain))
    in
    let rem_consumers =
        let get_ainps (PINST _ _ _ fa_inps fa_outs _ _) = flatmap snd fa_inps in
        exp_trim ((map fst fa_outs)@(flatmap get_ainps remain))
    in
    let mk_group i =
	let sel = el i selected_l in
	val (in_producers,in_consumers) = el i ifcs in
	val (l_prodl,l_consuml) =
	    unzip (gather ifcs ((1 upto length ifcs) subtract [i]))
	in
	let l_prod = flat l_prodl in
	let l_consum = flat l_consuml in
	let out_producers = rem_producers@l_prod in
	let out_consumers = rem_consumers@l_consum in
	let nouts = in_producers vec_intersect out_consumers in
	let ninps = in_consumers vec_intersect out_producers in
	let new_ints = md_extract_vectors
		    ((in_producers@in_consumers) vec_subtract (nouts @ ninps))
	in
	let mk_fa l = map (\v. (v,[v])) (md_extract_vectors l) in
	let new_name = fst (el i grl') then
	PINST new_name [] F (mk_fa ninps) (mk_fa nouts) new_ints (P_HIER sel)
    in
    let folded_children = map mk_group (1 upto (length ill)) then
    let all_wires = exp_trim (
			rem_consumers @ rem_producers @
			(flatmap pexlif_get_actuals folded_children))
    then
    let ints' =  md_extract_vectors
	    (all_wires vec_subtract (exp_trim (map fst (fa_inps@fa_outs))))
    then
    let chs' = folded_children@remain then
    (PINST name attrs leaf fa_inps fa_outs ints' (P_HIER chs'))
;

let foldn_pexlif_anon p ill new_base_name =
    letrec mk_grl idx (il:ils) =
	    ((sprintf "%s<%d>" new_base_name idx),il):(mk_grl (idx+1) ils)
     /\    mk_grl idx [] = []
    in
    let grl = (length ill = 1) => [(new_base_name, hd ill)] | mk_grl 1 ill then
    foldn_pexlif p grl
;

// Gather all child pints that has an attribute satisfying the predicate
// and fold them into a group named 'new_name';
let fold_by_label p attribute_predicate new_name =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p then
    let select (idx,(PINST _ lattrs _ _ _ _ _)) =
	(find_first0 attribute_predicate lattrs) != 0
    in
    let il = map fst (filter select (zip (1 upto (length chs)) chs)) in
    il = [] => p |
    fold_pexlif p il new_name
;

// Use the "Label" attributes to group the instances inside the pexlif.
// Basically an easy way to create an extra level of hierarchy without
// having to manually create all the interfaces.
let pexlif_group_by_label p =
    val (PINST nm attrs lf fa_inps fa_outs ints (P_HIER ps)) = p in
    letrec get_lbl idx ((PINST nm attrs lf fa_inps fa_outs ints body):rem) =
        ((find_attr "Label" "" attrs),idx):(get_lbl (idx+1) rem)
     /\    get_lbl idx [] = []
    in
    let lbl_part = partition fst (get_lbl 1 ps) then
    let mk l =
        val (lbl,_) = hd l in
        let indices = map snd l in
        (lbl,indices)
    in
    let grl = filter (\(lbl,il). lbl != "") (map mk lbl_part) then
    foldn_pexlif p grl
;


// Crate a new pexlif in which all the instances inside the instance id
// are lifted up one level in the hierarchy. All the internal wires
// inside instance id is given new names (prefix #<number>-).
//  unfold_pexlif::PINST->int->PINST
let
    unfold_pexlif pex id =
        val (PINST n a l i o t (P_HIER cs)) = unfold_pexlif pex id in
        let lbl (PINST n a l i o t c) = PINST n a l i o t c in
        PINST n a l i o t (P_HIER (map lbl cs))
;

// -----------------------------------------------------------------------------

begin_abstype;

let str_is_signature s = s == "FP" OR s == "SHA";
let filter_signatures  = filter (NOT # str_is_signature # fst);

let collect_names wexpr =
        letrec 
            collect (W_X _) = []
        /\  collect (W_CONST _ _) = []
        /\  collect (W_NAMED_CONST n sz _) = [(n, sz)]
        /\  collect (W_VAR sz s) = [(s, sz)]
        /\  collect (W_EXPLICIT_VAR sz s) = [(s, sz)]
        /\  collect (W_AND a b) = collect a @ collect b
        /\  collect (W_LAT_LEQ a b) = collect a @ collect b
        /\  collect (W_OR a b) = collect a @ collect b
        /\  collect (W_NOT a) = collect a
        /\  collect (W_EQ a b) = collect a @ collect b
        /\  collect (W_PRED _ c) = collect c
        /\  collect (W_GR a b) = collect a @ collect b
        /\  collect (W_ADD a b) = collect a @ collect b
        /\  collect (W_SUB a b) = collect a @ collect b
        /\  collect (W_MUL a b) = collect a @ collect b
        /\  collect (W_DIV a b) = collect a @ collect b
        /\  collect (W_MOD a b) = collect a @ collect b
        /\  collect (W_SHL a b) = collect a @ collect b
        /\  collect (W_SHR a b) = collect a @ collect b
        /\  collect (W_ASHR a b) = collect a @ collect b
        /\  collect (W_SX _ w) = collect w
        /\  collect (W_ZX _ w) = collect w
        /\  collect (W_ITE c a b) = collect c @ collect a @ collect b
        /\  collect (W_SLICE _ w) = collect w
        /\  collect (W_NAMED_SLICE _ _ w) = collect w
        /\  collect (W_UPDATE_NAMED_SLICE a _ _ b) = collect a @ collect b
        /\  collect (W_CAT as) = concat (map collect as)
        /\  collect (W_MEM_READ _ m a) = collect m @ collect a
        /\  collect (W_MEM_WRITE _ m a d) = collect m @ collect a @ collect d
        in
        setify $ collect wexpr
;
// todo: not sure about size on 'W_UPDATE_NAMED_SLICE'.

let name_to_formal_actuals n sz =
        let f = sz == 1 => n | sprintf "%s[%d:0]" n (sz-1) in (f, [f])
;

let draw_hier_leaf fs =
        let collect = map (curry name_to_formal_actuals) # collect_names in
        let draw_hier (W_UPDATE_FN lhs rhs) =
                PINST ("draw_hier " ^ (Pwexpr lhs) ^ " <- " ^ (Pwexpr rhs))
                      [] T (collect rhs) (collect lhs) []
                      (P_LEAF [W_UPDATE_FN lhs rhs])
        /\  draw_hier (W_PHASE_DELAY lhs rhs) =
                PINST ("draw_hier " ^ (Pwexpr lhs) ^ " := " ^ (Pwexpr rhs))
                      [] T (collect rhs) (collect lhs) []
                      (P_LEAF [W_PHASE_DELAY lhs rhs])
        in
        P_HIER (map draw_hier fs)
;

letrec
    draw_hier_pinst (PINST n as T is os ts (P_LEAF fs)) =
        let as' = filter_signatures as in
        PINST n as' F is os ts (draw_hier_leaf fs)
/\  draw_hier_pinst (PINST n as F is os ts (P_HIER cs)) =
        let as' = filter_signatures as in
        PINST n as' F is os ts (P_HIER (map draw_hier_pinst cs))
;

let decorate_pexlif_hiers = draw_hier_pinst;

end_abstype decorate_pexlif_hiers;

//------------------------------------------------------------------------------
// Fin.

let BASE_TMP = "_$";

let BASE_TMP_len = strlen BASE_TMP;
let o0 = ord "0";
let o9 = ord "9";

let strip_BASE_TMP s =
    NOT (str_is_prefix BASE_TMP s) => s |
    let rem = substr s (BASE_TMP_len+1) (-1) in
    letrec skip_dig (c:cs) =
        let oc = ord c in
        (o0 <= oc) AND (oc <= o9) => skip_dig cs | implode (c:cs)
     /\    skip_dig [] = ""
    in
    skip_dig (explode rem)
;



let wrap_pexlif p =
    val (PINST _ _ _ l_fa_inps l_fa_outs _ _) = p in
    let mk_io fa = map (\v. v, [v]) (md_extract_vectors (flatmap snd fa)) in
    let fa_inps = mk_io l_fa_inps in
    let fa_outs = mk_io l_fa_outs in
    (PINST "wrapper" [] F fa_inps fa_outs [] (P_HIER [p]))
;

let pexlif_rename p new_name =
    val (PINST _ attrs lf fa_inps fa_outs ints content) = p in
    PINST new_name attrs lf fa_inps fa_outs ints content
;

let try_assoc key l =
    (
	let res = assoc key l then
	SOME res
    ) catch
    NONE
;

let try_rev_assoc key l =
    (
	let res = rev_assoc key l then
	SOME res
    ) catch
    NONE
;

let rename_internals p =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER subfubs)) = p in
    let get_base s = hd (str_split (get_vector_signature s) "[") in
    let init_map = map (\(f,_).f,f) (fa_inps @ fa_outs) then
    let mapping = ref init_map in
    let bases_used = ref (map (\(m,n). get_base m) init_map) then
    let insert name =
	let cname = strip_BASE_TMP (last (str_split name "/")) in
	let base  = get_base cname in
	letrec try i =
	    let new_name = sprintf "%s%d%s" BASE_TMP i cname in
	    let new_base = sprintf "%s%d%s" BASE_TMP i base in
	    mem new_base (deref bases_used) => try (i+1) |
	    (mapping := ((name, new_name):(deref mapping))) fseq
	    (bases_used := (new_base:(deref bases_used))) fseq
	    new_name
	in
	try 1
    in
    let ints' = map insert ints then
    let bit_mapping =
	let exp_map (f,t) = zip (md_expand_vector f) (md_expand_vector t) in
	flatmap exp_map (deref mapping)
    then
    let map_name old_name =
	str_is_prefix "0b" old_name => [old_name] |
	let ores = try_assoc old_name (deref mapping) then
	has_value ores => [get_value ores] |
	let old_names = md_expand_vector old_name then
	let map1 onm =
	    let ores1 = try_assoc onm bit_mapping then
	    has_value ores1 => get_value ores1 | onm
	in
	let new_names = map map1 old_names then
	md_merge_vectors new_names
    in
    let trans (PINST sname sattrs sleaf sfa_inps sfa_outs sints sch) =
	let tr_fa (f,as) = (f, flatmap map_name as) in
	let sfa_inps' = map tr_fa sfa_inps then
	let sfa_outs' = map tr_fa sfa_outs then
	(PINST sname sattrs sleaf sfa_inps' sfa_outs' sints sch)
    in
    let subfubs' = map trans subfubs then
    (PINST name attrs leaf fa_inps fa_outs ints' (P_HIER subfubs'))
;

// Flatten the pexlif until the stop_pred is satisfied.
// Intermediate wire names are created on demand and are named
// i<number>/i<number>/.../<name> where the i<number>s refere to
// the cardinality of a subfub.
//
let gen_flatten_pexlif stop_pred p =
    let mk_pref pref i = sprintf "%si%d/" pref i in
    letrec do_flat sub pref p =
        let tr n = (assoc n sub) catch n in
        val (PINST name attrs leaf fa_inps fa_outs ints content) = p in
        leaf OR stop_pred p =>
            let tr_io (f,as) =
                let as' = cmd_merge_vectors (map tr (cmd_expand_vectors as)) in
                (f,as')
            in
            let fa_inps' = map tr_io fa_inps in
            let fa_outs' = map tr_io fa_outs in
            [(PINST name attrs leaf fa_inps' fa_outs' ints content)]
        |
            val (P_HIER children) = content in
            let mk_io_sub (f,as) =
                zip (md_expand_vector f) (map tr (cmd_expand_vectors as))
            in
            let io_sub = flatmap mk_io_sub (fa_inps @ fa_outs) in
            let mk_int_sub f =
                map (\n. n, sprintf "%s%s" pref n) (md_expand_vector f)
            in
            let int_sub = flatmap mk_int_sub ints in
            let sub' = io_sub @ int_sub in
            let prefs = map (mk_pref pref) (1 upto length children) in
            flat (map2 (do_flat sub') prefs children)
    in
    val (PINST name attrs leaf fa_inps fa_outs ints content) = p in
    leaf => p |
    val (P_HIER chs) = content in
    let prefs = map (mk_pref "") (1 upto length chs) in
    let children = flat (map2 (do_flat []) prefs chs) in
    let wires_used (PINST _ _ _ fa_inps fa_outs _ _) =
        cmd_expand_vectors (flatmap snd (fa_inps @ fa_outs))
    in
    let all = filter not_const (setify (flatmap wires_used children)) in
    let declared =
            (md_expand_vectors (map fst (fa_inps @ fa_outs))) @
            (md_expand_vectors ints)
    in
    let ints' = ints@(md_extract_vectors (all subtract declared)) in
    let res =
	(PINST name attrs leaf fa_inps fa_outs ints' (P_HIER children))
    then
    rename_internals res
;

// A simple stop-predicate for flatten_pexlif that can be used to
// flatten hierarchical pexlifs down to basic drawing components.
let is_draw_leaf p =
    val (PINST name _ _ _ _ _ _) = p in
    (str_is_prefix "draw_" name) AND NOT (str_is_prefix "draw_hier" name)
;

// A function to flatten a pexlif to basic drawing components.
let flatten_pexlif p = gen_flatten_pexlif is_draw_leaf p;

// A function to flatten recursively defined pexlifs
let flatten_recursive_pexlif recursion_name p =
    let stop_pred p =
	val (PINST name _ _ _ _ _ _) = p in
	NOT (name = recursion_name)
    in
    gen_flatten_pexlif stop_pred p
;

