//-------------------------------------------------------------------
// Copyright 2020 ...
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

load (DIR^"misc.fl");
load (DIR^"primes.fl");

// Find first element accepted by 'f' in 'xs'. If none is found, returns 'x'.
//  find_maybe::(a->bool)->a->(a list)->a
let find_maybe f x xs = let i = find_first0 f xs in i == 0 => x | (el i xs);

// Fetch attribute 's'. If none exists, returns 'a'.
//  find_attr::string->string->(string#string list)->string
let find_attr s a = snd # find_maybe (defix == s # fst) ("", a);

// Fetch the "fingerprint" attribute, if any.
//  find_fingerprint::(string#string list)->int
let find_fingerprint = s2int # find_attr "fingerprint" "0";

// Fetch the "signature" attribute, if any.
//  find_signature::(string#string list)->string
let find_signature = find_attr "signature" "";

//------------------------------------------------------------------------------

// Expand and pair up each formal/actual vector.
//  lineup::(formal#(actual list) list)->(formal#actual list)
let fa_lineup = flatmap (curry zip # both md_expand_vector md_expand_vectors);

// Subst. each formal by its matched actual.
//  raise::(formal#actual list)->(formal list)->(actual list)
let fa_raise = map # subst;

// Subst. each actual by its matched formal.
//  lower::(formal#actual list)->(actual list)->(formal list)
let fa_lower = map # rev_subst;

// Subst. each formal/actual pairing by 
//  promote::(formal/actual->b)->(formal#actual list)->(formal#actual list)->(a#a list)->(b#b list)
let fa_promote f ns hs = curry zip # both (f ns) (f hs) # unzip;

// Turns a subst. of formals into one over actuals.
//  fa_actualize::...
let fa_actualize fa_n fa_h = fa_promote fa_raise (fa_lineup fa_n) (fa_lineup fa_h);

// Turns a subst. of actuals into one over formals.
//  fa_formalize::...
let fa_formalize fa_n fa_h = fa_promote fa_lower (fa_lineup fa_n) (fa_lineup fa_h);

//------------------------------------------------------------------------------
// Fingerprint generation for a PEXLIF.
//------------------------------------------------------------------------------

// Multiply a value by a prime.
//  pm_val::...
let pm_val = prime_mult;

// Multiply each value by a prime, starting at some 'n', and sum the results.
//  pm_list::(a->int)->int->(a list)->int
let pm_list f n vs = ixlist (\a. \i. \s. pm_val i (f a) + s) vs n;

//------------------------------------------------------------------------------

// Gen. a fingerprint for 'MEM'.
//  fp_mem::MEM->int
let
    fp_mem (MEM as l ds) = pm_val 0 as + pm_val 1 l + pm_val 2 ds
;

// Gen. a fingerprint for 'WEXPR'.
//  fp_w::WEXPR->int
letrec
    fp_w (W_X s)                = pm_val 1 s
/\  fp_w (W_CONST s i)          = pm_val 2 s + pm_val 3 i
/\  fp_w (W_NAMED_CONST _ s i)	= pm_val 4 s + pm_val 5 i
/\  fp_w (W_VAR s _)            = pm_val 6 s
/\  fp_w (W_EXPLICIT_VAR s _)	= pm_val 7 s
/\  fp_w (W_AND a b)            = pm_val 8 (fp_w a + fp_w b)
/\  fp_w (W_OR a b)             = pm_val 9 (fp_w a + fp_w b)
/\  fp_w (W_NOT a)              = pm_val 10 (fp_w a)
/\  fp_w (W_EQ a b)             = pm_val 11 (fp_w a + fp_w b)
/\  fp_w (W_PRED _ a)           = pm_val 12 (fp_w a)
/\  fp_w (W_GR a b)             = pm_val 13 (fp_w a) + pm_val 14 (fp_w b)
/\  fp_w (W_ADD a b)            = pm_val 15 (fp_w a + fp_w b)
/\  fp_w (W_SUB a b)            = pm_val 16 (fp_w a) + pm_val 17 (fp_w b)
/\  fp_w (W_MUL a b)            = pm_val 18 (fp_w a) + pm_val 19 (fp_w b)
/\  fp_w (W_DIV a b)            = pm_val 20 (fp_w a) + pm_val 21 (fp_w b)
/\  fp_w (W_MOD a b)            = pm_val 22 (fp_w a) + pm_val 23 (fp_w b)
/\  fp_w (W_SHL a b)            = pm_val 24 (fp_w a) + pm_val 25 (fp_w b)
/\  fp_w (W_SHR a b)            = pm_val 26 (fp_w a) + pm_val 27 (fp_w b)
/\  fp_w (W_ASHR a b)           = pm_val 28 (fp_w a) + pm_val 29 (fp_w b)
/\  fp_w (W_SX s a)             = pm_val 30 s + pm_val 31 (fp_w a)
/\  fp_w (W_ZX s a)             = pm_val 32 s + pm_val 33 (fp_w a)
/\  fp_w (W_ITE a b c)          = pm_val 34 (fp_w a) + pm_val 35 (fp_w b)
                                + pm_val 36 (fp_w c)
/\  fp_w (W_SLICE ix a)	        = pm_val 37 (fp_w a) + pm_list id 1 ix
/\  fp_w (W_NAMED_SLICE _ ix a) = pm_val 38 (fp_w a) + pm_list id 1 ix
/\  fp_w (W_UPDATE_NAMED_SLICE a _ ix b)
                                = pm_val 39 (fp_w a) + pm_val 40 (fp_w b)
                                + pm_list id 1 ix
/\  fp_w (W_CAT as)             = pm_list fp_w 41 as
/\  fp_w (W_MEM_READ m a b)     = pm_val 42 (fp_mem m) + pm_val 43 (fp_w a)
                                + pm_val 44 (fp_w b)
/\  fp_w (W_MEM_WRITE m a b d)  = pm_val 45 (fp_mem m) + pm_val 46 (fp_w a)
                                + pm_val 47 (fp_w b) + pm_val 48 (fp_w d)
;

// Gen. a fingerprint for 'UPDATE_FN'.
//  fp_fn::UPDATE_FN->int
let
    fp_fn (W_UPDATE_FN l r)   = pm_val 49 (fp_w l) + pm_val 50 (fp_w r)
/\  fp_fn (W_PHASE_DELAY l r) = pm_val 51 (fp_w l) + pm_val 52 (fp_w r)
;

// Gen. a fingerprint for the "formals" of an input/output declaration.
//  fp_formal::[str]->int
let
    fp_formal ps = pm_val 53 (sum (map md_size ps))
;

// Gen. a fingerprint for the internals of a 'PINST'.
//  fp_internal::[str]->int
let
    fp_internal ps = pm_val 54 (sum (map md_size ps))
;

// Gen. a fingerprint for 'CONTENT'.
//  fp_content::CONTENT->int
let
    fp_content (P_LEAF fs) = pm_val 59 (sum (map fp_fn fs))
/\  fp_content (P_HIER cs) =
        let
            go (PINST _ a _ i o t _) =
                ( find_fingerprint a
                + fp_formal (map fst i)
                + fp_formal (map fst o)
                + fp_internal t
                )
        in
        pm_val 65 (sum (map go cs))
;

// Gen. a fingerprint for the components of a 'PINST'.
//  fp_pinst::'pinst contents'->string
let
    fp_pinst i o t c = int2str
        ( fp_formal (map fst i)
        + fp_formal (map fst o)
        + fp_internal t
        + fp_content c
        )
;

//------------------------------------------------------------------------------
// SHA256 signature generation for a PEXLIF.
//------------------------------------------------------------------------------

// Compute the SHA256 signature of a 'set' of components.
//  sha_set::(a list)->string
let sha_set = sha256_signature # qsort strcmp # map sha256_signature;

// Compute the SHA256 signature of a 'CONTENT'.
//  sha_content::content->string
let
    sha_content (P_LEAF fs) = sha_set fs
/\  sha_content (P_HIER cs) =
        let
            go (PINST n a _ i o t _) =
                ( n
                , find_signature a
                , sha256_signature (map fst i)
                , sha256_signature (map fst o)
                , sha_set t
                )
        in
        sha_set (map go cs)
;

// Compute the SHA256 signature of a 'PINST'.
//  sha_pinst::'pinst contents'->string
let
    sha_pinst n i o t c = sha256_signature
        ( n
        , sha256_signature (map fst i)
        , sha256_signature (map fst o)
        , sha_set t
        , sha_content c
        )
;

//------------------------------------------------------------------------------
// Extension of the PINST constructor with fingerprints and SHA256 signatures.
//------------------------------------------------------------------------------

let
    PINST n a l i o t c =
        find_fingerprint a != 0 => PINST n a l i o t c | 
        let f = ("fingerprint", fp_pinst    i o t c) then
        let s = ("signature",   sha_pinst n i o t c) then
        PINST n (f : s : a) l i o t c
;

//------------------------------------------------------------------------------
// Folding/Unfolding of a PEXLIF.
//------------------------------------------------------------------------------

// ...
//  fold_pexlif::PINST->[int]->string->PINST
let
    fold_pexlif pex ids name =
        val (PINST n a l i o t (P_HIER ((PINST n' a' l' i' o' t' c'):cs))) =
                fold_pexlif pex ids name
        in
        PINST n a l i o t (P_HIER ((PINST n' a' l' i' o' t' c'):cs))
;

// ...
//  unfold_pexlif::PINST->int->string->PINST
let
    unfold_pexlif pex id name =
        val (PINST n a l i o t (P_HIER cs)) =
                unfold_pexlif pex id name
        in
        let lbl (PINST n a l i o t c) = PINST n a l i o t c in
        PINST n a l i o t (P_HIER (map lbl cs))
;

//------------------------------------------------------------------------------
// Generation of a PEXLIF.
//------------------------------------------------------------------------------

let ?! = undefined;

// ...
//  one_of::(a list)->a
let one_of [] = eprintf "one_of called on empty list"
/\  one_of xs = el (random 1 (length xs)) xs
;

// ...
//  one_of_weighted::((int#a) list)->a
let one_of_weighted [] = eprintf "one_of_weighted called on empty list"
/\  one_of_weighted xs =
        letrec
            pick n ((k,a):as) = (n <= k) => a | pick (n-k) as
        in
        pick (random 1 (sum (map fst xs))) xs
;

//------------------------------------------------------------------------------

// ...
//  gen_DAG_with_threshold::int->int->[[bool]]
let
    gen_DAG_with_threshold n p =
        letrec
            map_from _ []     _ = []
        /\  map_from f (x:xs) 0 = f x : map_from f xs 0
        /\  map_from f (x:xs) i = x   : map_from f xs (i-1)
        in
        let flip F = randomf 32 > p in
        let empty  = replicate n (replicate n F) in
        let marked = ixmap (map_from flip) empty in
        marked
;

// ...
//  gen_DAG::int->(bool mat)
let gen_DAG n =
        gen_DAG_with_threshold n
            (fdiv (fmul 2.0 (log (int2float n))) (int2float n))
;

// List nodes connected to node 'i' via incoming edges.
let inputs_of i dag =
    letrec
            go rs [] = rs
        /\  go rs ((xs, j):ys) = el i xs => go (j:rs) ys | go rs ys
        in
        go [] (ixlabel dag)
;

// List nodes driving outputs, i.e. those with no outgoing edges.
let outputs_of = map (any id);

//------------------------------------------------------------------------------

// ...
//  gen_DAG_internals::(bool mat)->(int list)->((int#{(string#int) opt}) list)
let gen_DAG_internals dag szs =
        // When selecting sizes, go for common sizes with a chance for random.
        let ms = 2 * (itlist1 max szs) in
        let hs = map swap (hist szs) in
        let random_size x =
                1 == random 1 5 => random 1 ms | one_of_weighted hs
        in
        // Build new vector with random size for internal node 'ix'.
        let new_internal T i = (i, NONE)
        /\  new_internal F i =
                let sz  = random_size i in
                let vec =
                        let name  = "i" ^ (int2str i) in
                        let range = "[" ^ (int2str (sz-1)) ^ ":0]" in
                        sz == 1 => name | name ^ range
                in
                (i, SOME (vec, sz))
        in
        map (curry new_internal)
          $ zip_uneven (outputs_of dag) (1 upto (length dag))
;

//------------------------------------------------------------------------------

let random_slice lz hz =
        let expand_range l h = firstn (h-l) (iterate (defix + 1) l) in
        let random_remove xs = remove (random 1 (length xs)) xs in
        repeat (hz-lz) random_remove (expand_range 0 hz)
;

let random_split sz =
        let r = random 1 sz in
        (r+(sz%r)) : (firstn ((sz/r)-1) (iterate id r))
;

let resize_input sz =
          map (\j. W_VAR (md_size j) j)
        # md_merge_vectors
        # firstn sz
        # md_expand_vector
;

// ...
//  gen_WEXPR::(int#(string#int))->int->int->...
let gen_WEXPR env size depth =
        letrec
            select_inputs sz =
                val (inp, s) = one_of_weighted env in
                let variable = W_VAR s inp in
                // If smaller, extend or pad.
                s < sz =>
                    let more = select_inputs (sz-s) in
                    one_of_weighted
                        [ (2, [W_SX sz variable])
                        , (2, [W_ZX sz variable])
                        , (1, (variable : more))
                        ] |
                // If larger, slice to fit req.
                s > sz =>
                    one_of_weighted
                        [ (3, [W_SLICE (sz downto 1) variable])
                        , (1, [W_SLICE (random_slice sz s) variable])
                        ] |
                // Otherwise, use as is.
                [variable]
        in
        letrec
            gen sz 0 =
                let variable =
                        let vs = select_inputs sz in
                        length vs == 1 => hd vs | W_CAT vs
                in
                // Lean towards variables as leaves.
                one_of_weighted
                       [ (4, variable)
                       , (1, W_X sz)
                       , (1, W_CONST sz (random2 sz))
                    // , (x, W_NAMED_CONST ?! ?! ?!)
                    // , (x, W_EXPLICIT_VAR ?! ?!)
                    // , (x, W_MEM_READ ?! ?! ?!)
                       ]
        /\  gen 1 n =
                let n2  = n / 2 in
                let n3  = n / 3 in
                // misc. for W_SLICE
                let sz = snd $ one_of_weighted env in
                let si = (random 1 sz) - 1 in
                // ...
                one_of [ W_NOT (gen 1 (n-1))
                       , W_AND (gen 1 n2) (gen 1 n2)
                       , W_OR  (gen 1 n2) (gen 1 n2)
                       , W_EQ  (gen 1 n2) (gen 1 n2)
                       , W_ITE (gen 1 n3) (gen 1 n3) (gen 1 n3)
                       , W_SLICE [si] (gen sz (n-1))
                       ]
        /\  gen sz n =
                let n2  = n / 2 in
                let n3  = n / 3 in
                // misc. for W_SLIZE
                let hz  = random sz (sz*2) in
                // misc. for W_SX/W_ZX
                let ez  = random 1 sz in
                // misc. for W_CAT
                let czs = random_split sz in
                let cn  = n / (length czs) in
                // ...
                one_of [ W_NOT  (gen sz (n-1))
                       , W_AND  (gen sz n2) (gen sz n2)
                       , W_OR   (gen sz n2) (gen sz n2)
                       , W_EQ   (gen sz n2) (gen sz n2)
                       , W_GR   (gen sz n2) (gen sz n2)
                       , W_ADD  (gen sz n2) (gen sz n2)
                       , W_SUB  (gen sz n2) (gen sz n2)
                       , W_MUL  (gen sz n2) (gen sz n2)
                       , W_DIV  (gen sz n2) (gen sz n2)
                       , W_MOD  (gen sz n2) (gen sz n2)
                       , W_SHL  (gen sz n2) (gen sz n2)
                       , W_SHR  (gen sz n2) (gen sz n2)
                       , W_ASHR (gen sz n2) (gen sz n2)
                    // , W_PRED ?! ?!
                       , W_SX sz (gen ez (n-1))
                       , W_ZX sz (gen ez (n-1))
                       , W_ITE (gen 1 n3) (gen sz n3) (gen sz n3)
                       , W_SLICE (random_slice sz hz) (gen hz n2)
                    // , W_NAMED_SLICE ?! ?! ?!
                    // , W_UPDATE_NAMED_SLICE ?! ?! ?! ?!
                       , W_CAT (map (flip gen cn) czs)
                    // , W_MEM_WRITE ?! ?! ?! ?!
                       ]
        in
        gen size depth
;
// todo: ensure we respect the DAG edges when selecting from 'env'?

// ...
//  gen_DAG_content::...
let gen_DAG_content dag wires is os size =
        let outputs =
                let xs = map snd $ filter fst $ ixlabel $ outputs_of dag in
                map (\a. (snd (hd a), map fst a))
                  $ group ((defix ==) on snd)
                  $ qsort (cmp_fun on snd)
                  $ map (\o. (o, one_of xs)) os
        in
        // Prefer internal wires over inputs whenever they are available.
        let build_env i =
                let xs = inputs_of i dag in
                let ys = filter (\(j,o). has_value o AND elem j xs) wires in
                (map (pair 10 # get_value # snd) ys) @ (map (pair 1) is)
        in
        // ...
        let build_variable (i, NONE) =
                let vs  = map (curry (flip W_VAR)) (assoc i outputs) in
                let s   = sum $ map (\(W_VAR s _). s) vs in
                length vs == 1 =>
                    (s, hd    vs)
                  | (s, W_CAT vs)
        /\  build_variable (_, SOME (n, s)) = (s, W_VAR s n)
        in
        // ...
        let build_driver (s, v) =
                W_UPDATE_FN v (gen_WEXPR (build_env s) s (random 1 size))
        in
        P_LEAF (map (build_driver # build_variable) wires)
;
// todo: fails if 'build_variable.vs' ends up being empty.

//------------------------------------------------------------------------------

// ...
//  gen_combinatorial::...
let gen_combinatorial size depth inputs outputs =
        let build n = (n, md_size n) in
        let is  = map (build # fst) inputs  in
        let os  = map (build # fst) outputs in
        let szs = map snd (is @ os) in
        // ...
        let layout    = gen_DAG size in
        let internals = gen_DAG_internals layout szs in
        let content   = gen_DAG_content layout internals is os depth in
        // ...
        PINST
            "leaf"
            []
            T
            inputs
            outputs
            (map fst $ filter_some $ map snd internals)
            content
;

//------------------------------------------------------------------------------
// Fin.