(cload (DIR^"grammar.fl")) fseq
(cload (DIR^"pretty.fl")) fseq
(cload (DIR^"pretty-verilog.fl")) fseq
(cload (DIR^"../design/misc.fl")) fseq
(cload (DIR^"../design/util.fl")) fseq
();

// =============================================================================
// "Pretty-printing" of pexlif's via a translation into Verilog.
// =============================================================================

// According to the verilog standard, a simple identifier shall be any sequence
// of letters, digits, dollar signs ($), and underscore characters (_).
let valid_ident s =
      let c = ord s in
      ((c >= 65) AND (c <= 90)) OR // A-Z
      ((c >= 97) AND (c <= 122)) OR // a-z
      ((c >= 48) AND (c <= 57)) OR // 0-9
      (c == 36) OR // $
      (c == 95) // _
;

// Positive index.
let valid_index i = i >= 0;

// Contig. MSB to LSB slice.
letrec
    valid_slice [] = T
/\  valid_slice (i:[]) = valid_index i
/\  valid_slice (i:j:is) = (valid_index i) AND (i-j==1) AND (valid_slice (j:is))
;

// Valid LHS for both 'net_lvalue' and 'variable_lvalue'.
let vvalid_lhs {we::wexpr} =
      let is_var (W_VAR _ _) = T
      /\  is_var (W_EXPLICIT_VAR _ _) = T
      /\  is_var other = F
      in
      letrec
          rec_ix (W_SLICE [i] w) = (valid_index i) AND (rec_ix w)
      /\  rec_ix (W_SLICE is w) = (valid_slice is) AND (is_var w)
      /\  rec_ix (W_NAMED_SLICE _ [i] w) = (valid_index i) AND (rec_ix w)
      /\  rec_ix (W_NAMED_SLICE _ is w) = (valid_slice is) AND (is_var w)
      in
      letrec
          rec_top (W_VAR _ _) = T
      /\  rec_top (W_EXPLICIT_VAR _ _) = T
      /\  rec_top (W_SLICE [i] w) = (valid_index i) AND (rec_ix w)
      /\  rec_top (W_SLICE is w) = (valid_slice is) AND (is_var w)
      /\  rec_top (W_NAMED_SLICE _ [i] w) = (valid_index i) AND (rec_ix w)
      /\  rec_top (W_NAMED_SLICE _ is w) = (valid_slice is) AND (is_var w)
      /\  rec_top (W_CAT parts) = all rec_top parts
      /\  rec_top other = F
      in
      rec_top we
;

// -----------------------------------------------------------------------------
// ...

begin_abstype;

let warn msg v = print msg fseq v;

let prim_str  {s::string} = Exp_primary (Prim_str s);
let prim_cstr {s::string} = CExp_primary (CPrim_str s);

let as_bin {sz::int} {i::int} = sprintf "%0*b" sz i;
let as_oct {sz::int} {i::int} = sprintf "%d'o%0*o" sz (sz/3) i;
let as_hex {sz::int} {i::int} = sprintf "%d'x%0*x" sz (sz/4) i;

// let prim_num {i::int} = Exp_primary $ Prim_num $ Num i;
let prim_num n = Exp_primary (Prim_num n);
let bin sz s v = prim_num $ NUM_bin $
        BIN (SOME (SIZE sz)) (NOT s) (VAL $ as_bin sz v);
let oct sz s v = prim_num $ NUM_oct $
        OCT (SOME (SIZE sz)) (NOT s) (VAL $ as_oct sz v);
let hex sz s v = prim_num $ NUM_hex $
        HEX (SOME (SIZE sz)) (NOT s) (VAL $ as_hex sz v);
let undef sz   = prim_num $ NUM_bin $ BIN (SOME (SIZE sz)) T (VAL "x");
let dec v      = prim_num $ NUM_dec $ DEC $ UNUM v;

// let prim_cnum {i::int} = CExp_primary $ CPrim_num $ Num i;
let prim_const_num (Exp_primary (Prim_num n)) = CExp_primary (CPrim_num n);
let cbin sz s v = prim_const_num (bin sz s v);
let coct sz s v = prim_const_num (oct sz s v);
let chex sz s v = prim_const_num (hex sz s v);
let cundef sz   = prim_const_num (undef sz);
let cdec v      = prim_const_num (dec v);

let range (a,b)     = Range (cdec a) (cdec b);
let dimension (a,b) = Dimension (cdec a) (cdec b);
let index_exp (a,b) = a == b => dec a | error "internal: index not dot.";
let range_exp (a,b) = a == b => Range_exp (dec a) | Range_m2l (cdec a) (cdec b);

// Wrapped ID in a flat hierarchy.
let hier i = HID NONE (ID i);
// note: Pexlif hierarchies are blackboxes and IDs are unique, hence there's no
// need to make a distinction between IDs and hierarchical IDs in.

// Hierarchical ID with an optional range.
let prim_hier i []     = Prim_hier (hier i) (NONE)
/\  prim_hier i (r:rs) =
      Prim_hier (hier i) (SOME (map index_exp rs, range_exp r))
;
// note: Assumes the size of 'i' is not included in its name.
// note: We assume ranges are on the form [msb:0].

// Split a "simple" vector into its name and size.
let split_name_gen {vec::string} =
      let parse_name (TXT v) = hd (str_split v "[")
      /\  parse_name _ = error "split_name: Expected a name."
      in
      letrec
          parse_dim [] = []
      /\  parse_dim ((RANGES [r]):(TXT "]") :[]) = [r]
      /\  parse_dim ((RANGES [r]):(TXT "]["):ds) = r : parse_dim ds
      /\  parse_dim _ = error "split_name: Expected a contig. range."
      in
      let is = md_split_vector vec in
      empty is => error "split_name: Empty vector." |
      (parse_name (hd is), parse_dim (tl is))
;
// todo: I currenply assume the given vector is on a simple form, or at least
// similar to the following examples:
//   > md_split_vector "a" = ["a"];
//   > md_split_vector "a[0]" = ["a[",{0:0},"]"];
//   > md_split_vector "a[31:0]" = ["a[",{31:0},"]"];
//   > md_split_vector "a[7:0][7:0]" = ["a[",{7:0},"][",{7:0},"]"];
// where the first range gives the vector size, and the latter give the array
// dimensions.

let split_name_rng {vec::string} = split_name_gen vec;

let split_name_dim {vec::string} =
      val (n,rs) = split_name_gen vec in
      empty rs => (n,[]) | (n, (hd rs) : (map swap (tl rs)))
;
// todo: My simple Google-fu skills tell me that Verilog-people tend to swap the
// msb & lsb when declaring an array's range. Not sure why though..

// Generic construction of a 'X_lvalue'.
let gen_lvalue {we::wexpr} hier_f index_f slice_f cat_f =
      let to_hier v _  (NONE)   = hier_f v (NONE)
      /\  to_hier v is (SOME r) = hier_f v (SOME (rev is, r))
      in
      letrec
          go (W_VAR _ v) js r' = to_hier v js r'
      /\  go (W_EXPLICIT_VAR _ v) js r' = to_hier v js r'
      /\  go (W_SLICE [i] w) js r' = go w (index_f i : js) r'
      /\  go (W_SLICE is w) js _ = go w js (SOME (slice_f is))
      /\  go (W_NAMED_SLICE _ [i] w) js r' = go w (index_f i : js) r'
      /\  go (W_NAMED_SLICE _ is w) js _ = go w js (SOME (slice_f is))
      /\  go (W_CAT ws) js r' = cat_f (map (\w. go w js r') ws)
      in
      vvalid_lhs we => go we [] NONE | error "gen_lvalue: Invalid LHS."
;

// note: 'net_lvalue' is used as the LHS of a 'assign' statement.
let net_lvalue {we::wexpr} =
      let to_hier v d = NLV_hier (hier v) d in
      let to_slice is = CRange_m2l (cdec (hd is)) (cdec (last is)) in
      gen_lvalue we to_hier cdec to_slice NLV_list
;

// note: 'var_lvalue' is used as the LHS of non-blocking assignments in a
// 'always' statement.
let var_lvalue {we::wexpr} =
      let to_hier v d = VLV_hier (hier v) d in
      let to_slice is = Range_m2l (cdec (hd is)) (cdec (last is)) in
      gen_lvalue we to_hier dec to_slice VLV_list
;

// -----------------------------------------------------------------------------

let precedence_unary (U_pos) = 1
/\  precedence_unary (U_neg) = 1
/\  precedence_unary (U_log_neg) = 1
/\  precedence_unary (U_bit_neg) = 1
/\  precedence_unary (U_red_and) = 1
/\  precedence_unary (U_red_nand) = 1
/\  precedence_unary (U_red_or) = 1
/\  precedence_unary (U_red_nor) = 1
/\  precedence_unary (U_red_xor) = 1
/\  precedence_unary (U_red_xnor_l) = 1
/\  precedence_unary (U_red_xnor_r) = 1
;

let precedence_binary (B_add) = 4
/\  precedence_binary (B_sub) = 4
/\  precedence_binary (B_mult) = 3
/\  precedence_binary (B_div) = 3
/\  precedence_binary (B_mod) = 3
/\  precedence_binary (B_log_eq) = 7
/\  precedence_binary (B_log_neq) = 7
/\  precedence_binary (B_case_eq) = 7
/\  precedence_binary (B_case_neq) = 7
/\  precedence_binary (B_log_and) = 11
/\  precedence_binary (B_log_or) = 12
/\  precedence_binary (B_exp) = 2
/\  precedence_binary (B_lt) = 6
/\  precedence_binary (B_lte) = 6
/\  precedence_binary (B_gt) = 6
/\  precedence_binary (B_gte) = 6
/\  precedence_binary (B_bit_and) = 8
/\  precedence_binary (B_bit_or) = 10
/\  precedence_binary (B_bit_xor) = 9
/\  precedence_binary (B_bit_eq_l) = 9
/\  precedence_binary (B_bit_eq_r) = 9
/\  precedence_binary (B_log_shr) = 5
/\  precedence_binary (B_log_shl) = 5
/\  precedence_binary (B_shr) = 5
/\  precedence_binary (B_shl) = 5
;

forward_declare{pretty_expression::wexpr->(expression#int)};

let const_exp sz c = (prim_str (as_bin sz c), 1);

let variable_exp 1  v = (Exp_primary (prim_hier v []), 1)
/\  variable_exp sz v = (Exp_primary (prim_hier v [(sz-1,0)]), 1)
;

let paren_exp a = Prim_mintypmax (MTM_expression a);

let wrap_exp a ap p = ap >= p => Exp_primary (paren_exp a) | a;

let wrap_prim (Exp_primary a) ap p = ap >= p => paren_exp (Exp_primary a) | a
/\  wrap_prim a _ _ = paren_exp a
;

let unary_exp op a =
      let p = precedence_unary op in
      val (a', n) = pretty_expression a in
      (Exp_unary op (wrap_prim a' n p), p)
;

let binary_exp op a b =
      let p = precedence_binary op in
      val (a', n) = pretty_expression a in
      val (b', m) = pretty_expression b in
      (Exp_binary (wrap_exp a' n p) op (wrap_exp b' m p), p)
;

let zero_extend_exp sz a =
      let a'   = fst $ pretty_expression a in
      let sz'  = wexpr_size a in
      let zero =
            Exp_primary (Prim_mcat (MCAT (cdec (sz-sz'))
              (CAT [prim_str (as_bin 1 0)])))
      in
      (Exp_primary (Prim_cat (CAT [zero, a'])), 14)
;

let unwrap_prim (Exp_primary (Prim_hier (HID NONE (ID i)) rng)) = (i, rng)
/\  unwrap_prim _ = error "SX/SLICE is only supported for variables."
;

let sign_extend_exp sz a =
      let a'  = fst (pretty_expression a) in
      let sz' = wexpr_size a in
      let id  = fst (unwrap_prim a') in
      let rng = sz' > 1 => let x = sz' - 1 in [(x,x)] | [] in
      let ext =
            Exp_primary (Prim_mcat (MCAT (cdec (sz-sz'))
              (CAT [Exp_primary (prim_hier id rng)])))
      in
      (Exp_primary (Prim_cat (CAT [ext, a'])), 14)
;

let slice_exp is a =
      let contig_slice is =
            empty is => error "Empty slice." |
            NOT (valid_slice is) => error "Non-contig. slice." |
            (hd is, last is)
      in
      let a'  = fst (pretty_expression a) in
      let id  = fst (unwrap_prim a') in
      let rng = [contig_slice is] in
      (Exp_primary (prim_hier id rng), 100)
;
// todo: precedence correct?

let syscall_signed e = Prim_syscall (SYSCALL (SYSID "signed") (SOME [e]));

let syscall_unsigned e = Prim_syscall (SYSCALL (SYSID "unsigned") (SOME [e]));

// See 5.5.1 Rules for expression types
// > Based_numbers are unsigned, except where the s notation is used in the base
// specifier
// > Decimal numbers are signed.
let is_num_signed (NUM_bin (BIN _ s _)) = s
/\  is_num_signed (NUM_oct (OCT _ s _)) = s
/\  is_num_signed (NUM_dec _) = T
/\  is_num_signed (NUM_hex (HEX _ s _)) = s
/\  is_num_signed (NUM_real _) = F // reals are real, not unsigned/signed.
;

// note: This really depends on the def. of the system function, but as I only
// support "$signed" and "$unsigned" its much easier to simply check its name.
let is_syscall_signed (SYSCALL (SYSID "signed") _) = T
/\  is_syscall_signed _ = F
;

forward_declare{is_exp_signed::expression->bool};

// > Bit-select results are unsigned, regardless of the operands.
// > Part-select results are unsigned, regardless of the operands even if the
// part-select specifies the entire vector.
// > Concatenate results are unsigned, regardless of the operands.
let is_prim_signed (Prim_num n) = is_num_signed n
/\  is_prim_signed (Prim_hier _ _) = F
/\  is_prim_signed (Prim_cat _) = F
/\  is_prim_signed (Prim_mcat _) = F
/\  is_prim_signed (Prim_syscall f) = is_syscall_signed f
/\  is_prim_signed (Prim_mintypmax (MTM_expression e)) = is_exp_signed e
/\  is_prim_signed (Prim_mintypmax (MTM_minmax e _ _)) = is_exp_signed e
/\  is_prim_signed (Prim_str _) = F
;

// > Expression type depends only on the operands. It does not depend on the
// left-hand side (if any).
// > Comparison results (1, 0) are unsigned, regardless of the operands.
// > The sign and size of any self-determined operand are determined by the
// operand itself and independent of the remainder of the expression.
// > For nonself-determined operands, the following rules apply:
//   - If any operand is unsigned, the result is unsigned, regardless of the
//     operator.
//   - If all operands are signed, the result will be signed, regardless of
//     operator, except when specified otherwise (?).
let is_exp_signed (Exp_primary p) = is_prim_signed p
/\  is_exp_signed (Exp_unary U_pos a) = is_prim_signed a
/\  is_exp_signed (Exp_unary U_neg a) = is_prim_signed a
/\  is_exp_signed (Exp_unary U_log_neg a) = is_prim_signed a
/\  is_exp_signed (Exp_unary U_bit_neg a) = is_prim_signed a
/\  is_exp_signed (Exp_unary _ _) = F
/\  is_exp_signed (Exp_binary a B_add b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_sub b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_mult b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_div _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_mod _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_log_and b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_log_or b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_exp _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_bit_and b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_bit_or b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_bit_xor b) = is_exp_signed a AND is_exp_signed b
/\  is_exp_signed (Exp_binary a B_log_shr _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_log_shl _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_shr _) = is_exp_signed a
/\  is_exp_signed (Exp_binary a B_shl _) = is_exp_signed a
/\  is_exp_signed (Exp_binary _ _ _) = F
/\  is_exp_signed (Exp_conditional _ a _) = is_exp_signed a
;

let ashr_exp a b =
      let p = precedence_binary B_shr in
      val (a', n) = pretty_expression a in
      val (b', m) = pretty_expression b in
      let sa = is_exp_signed a' => wrap_exp a' n p |
            Exp_primary (syscall_signed a')
      in
      (Exp_binary sa B_shr (wrap_exp b' m p), p)
;

let mod_exp a b =
      let p = precedence_binary B_mod in
      val (a', n) = pretty_expression a in
      val (b', m) = pretty_expression b in
      let sa = is_exp_signed a' => wrap_exp a' n p |
            Exp_primary (syscall_signed a')
      in
      (Exp_binary sa B_mod (wrap_exp b' m p), p)
;

let conditional_exp c a b =
      (Exp_conditional
        (fst $ pretty_expression c)
        (fst $ pretty_expression a)
        (fst $ pretty_expression b)
      , 13)
;

let concat_exp as =
      (Exp_primary (Prim_cat (CAT (map (fst # pretty_expression) as))), 100)
;
// todo: precedence correct?

let pretty_expression {we::wexpr} =
      letrec
          go (W_X sz)       = (undef sz, 1)
      /\  go (W_CONST sz c) = const_exp sz c
      /\  go (W_VAR sz v)   = variable_exp sz v
      /\  go (W_AND a b)    = binary_exp B_bit_and a b
      /\  go (W_OR a b)     = binary_exp B_bit_or a b
      /\  go (W_NOT a)      = unary_exp U_bit_neg a
      /\  go (W_EQ a b)     = binary_exp B_log_eq a b
      /\  go (W_GR a b)     = binary_exp B_gt a b
      /\  go (W_ADD a b)    = binary_exp B_add a b
      /\  go (W_SUB a b)    = binary_exp B_sub a b
      /\  go (W_MUL a b)    = binary_exp B_mult a b
      /\  go (W_DIV a b)    = binary_exp B_div a b
      /\  go (W_MOD a b)    = mod_exp a b
      /\  go (W_SHL a b)    = binary_exp B_log_shl a b
      /\  go (W_SHR a b)    = binary_exp B_log_shr a b
      /\  go (W_ASHR a b)   = ashr_exp a b
      /\  go (W_ZX sz a)    = zero_extend_exp sz a
      /\  go (W_SX sz a)    = sign_extend_exp sz a
      /\  go (W_SLICE is w) = slice_exp is w
      /\  go (W_ITE c a b)  = conditional_exp c a b
      /\  go (W_CAT es)     = concat_exp es
      // Ignored op. -----------------------------
      /\  go (W_NAMED_CONST _ sz c) =
            warn "NAMED_CONST is treated as CONST" (const_exp sz c)
      /\  go (W_EXPLICIT_VAR sz v) =
            warn "EXPLICIT_VAR is treated as VAR" (variable_exp sz v)
      /\  go (W_PRED _ a) =
            warn "PRED is ignored" (go a)
      /\  go (W_NAMED_SLICE _ is a) =
             warn "NAMED_SLICE is treated as SLICE" (slice_exp is a)
      // Not yet supported op. -------------------
      /\  go (W_UPDATE_NAMED_SLICE _ _ _ _) =
            error "W_UPDATE_NAMED_SLICE not supported"
      /\  go (W_MEM_READ _ _ _) =
            error "W_MEM_READ not supported"
      /\  go (W_MEM_WRITE _ _ _ _) =
            error "W_MEM_WRITE not supported"
      in
      // todo: Used to do more here, could inline 'go' now.
      go we
;

let assign net_lv exp =
      NPM_Item (MOGI_cont (Cont_assign [(net_lv, exp)]))
;

let always var_lv exp =
      NPM_Item (MOGI_always (Always (Statement_timing
        (PTC (PTC_event (Event_pstar))
        (Statement_nonblocking (Nonblocking_assignment var_lv NONE exp))))))
;

let pretty_update_fn (W_UPDATE_FN lhs rhs) =
      let net_lv = net_lvalue lhs in
      let exp = fst $ pretty_expression rhs in
      assign net_lv exp
/\  pretty_update_fn (W_PHASE_DELAY lhs rhs) =
      let var_lv = var_lvalue lhs in
      let exp = fst $ pretty_expression rhs in
      always var_lv exp
;

// -----------------------------------------------------------------------------

let in_lvalue {id::string} {we::wexpr} =
      letrec
          find (W_VAR _ v) = id == v
      /\  find (W_EXPLICIT_VAR _ v) = id == v
      /\  find (W_SLICE _ w) = find w
      /\  find (W_NAMED_SLICE _ _ w) = find w
      /\  find (W_CAT ws) = any find ws
      in
      find we
;

// Checks if 'id' occurs in the lhs of an 'update_fn', where T=comb & F=delay.
let in_lhs id (W_UPDATE_FN lhs _)   = in_lvalue id lhs => SOME T | NONE
/\  in_lhs id (W_PHASE_DELAY lhs _) = in_lvalue id lhs => SOME F | NONE
;

let in_any_lhs id fs = exhaust (map (in_lhs id) fs);

let is_signed = str_is_prefix "_$s";

let declare_net id [] =
      ND_scalar_id NT_wire (is_signed id) [Net_id (ID id) []]
/\  declare_net id (r:ds) =
      ND_vector_id NT_wire NONE (is_signed id) (range r)
        [Net_id (ID id) (map dimension ds)]
;

let declare_reg id [] =
      Reg_decl (is_signed id) NONE [VT_dim (ID id) []]
/\  declare_reg id (r:ds) =
      Reg_decl (is_signed id) (SOME (range r))
        [VT_dim (ID id) (map dimension ds)]
;

let pretty_internal_decl {vec::string} {wire::bool} =
      val (id, dim) = split_name_dim vec in
      NPM_Item (MOGI_decl (
        wire =>
          MOGID_net (declare_net id dim) |
          MOGID_reg (declare_reg id dim)
      ))
;

let port_range [] = NONE
/\  port_range ((m,l):[]) = SOME (Range (cdec m) (cdec l))
/\  port_range _ = error "Multi-dim. port decl. is not allowed."
;

let input_port_decl {vec::string} =
      val (id, rs) = split_name_rng vec in
      Input_decl (SOME NT_wire) F (port_range rs) [ID id]
;

// Gen. port declarations for each "formal" input vec.
let pretty_decl_inps {f_inps::string list} =
      map (Port_decl_in # input_port_decl) f_inps
;

let output_port_decl {vec::string} {wire::bool} =
      val (id, rs) = split_name_rng vec in
      let r = port_range rs in
      wire =>
        Output_decl_port (SOME NT_wire) F r [ID id] |
        Output_decl_reg F r [VPI (ID id) NONE]
;

// Gen. port declarations for each "formal" output vec. as either wire or reg.
let pretty_decl_outs {f_outs::(string#bool) list} =
      map (Port_decl_out # curry output_port_decl) f_outs
;

// -----------------------------------------------------------------------------

let port {vec::string} =
    str_is_prefix "0b" vec =>
	// Constant
	let sz = strlen vec - 2 in
	let i = sscanf "0b%b" vec in
	bin sz F i
    |
	// Named signal
	val (id,rs) = split_name_rng vec in Exp_primary (prim_hier id rs)
;

let connect_ports f as =
      let connect []     = NONE
      /\  connect (a:[]) = SOME (port a)
      /\  connect (a:as) = SOME (Exp_primary (Prim_cat (CAT (map port as))))
      in
      val (id,_) = split_name_rng f in
      Port_con_named (ID id) (connect as)
;

let port_instantiation mi ai {args::(string#(string list))list} =
      NPM_Item (MOGI_module (Module_instantiation mi
        [Module_instance ai NONE
          (empty args => NONE | SOME (map (curry connect_ports) args))]))
;
// todo: Not sure what the 'range' is used for in module instantiation.

let inst_name name inst =
      let n1 = string_empty name => "m" | name in
      let n2 = string_replace n1 " " "_" in
      let n3 = string_filter n2 valid_ident in
      ID (n3^inst)
;
// note: Can't have spaces in names.

let pretty_port_instantiation {inst::string} (PINST name _ _ fa_inps fa_outs _ _) =
      let module = inst_name name inst in
      let anon   = inst_name "anon" inst in
      port_instantiation module anon (fa_inps @ fa_outs)
;

// -----------------------------------------------------------------------------

let premade_ff_re name clk p q =
      val (p_id, p_rs) = split_name_rng p in
      val (q_id, q_rs) = split_name_rng q in
      let var_lv =
            VLV_hier (hier q_id) (empty q_rs => NONE |
              SOME (map index_exp (tl q_rs), range_exp (hd q_rs)))
      in
      Desc_module (Module_declaration_many name (SOME [
          Port_decl_in (Input_decl (SOME NT_wire) F NONE [ID clk])
        , Port_decl_in (Input_decl (SOME NT_wire) F (port_range p_rs) [ID p_id])
        , Port_decl_out (Output_decl_reg F (port_range q_rs) [VPI (ID q_id) NONE])
        ])
        [NPM_Item (MOGI_always (Always (Statement_timing (PTC
          (PTC_event (Event_control_exp (Event_pos
            (Exp_primary (prim_hier clk [])))))
          (Statement_nonblocking (Nonblocking_assignment var_lv NONE
            (Exp_primary (prim_hier p_id p_rs))))))))
        ])
;

let premade_ff_re_reset name clk re p q =
      val (p_id, p_rs) = split_name_rng p in
      val (q_id, q_rs) = split_name_rng q in
      let var_lv =
            VLV_hier (hier q_id) (empty q_rs => NONE |
              SOME (map index_exp (tl q_rs), range_exp (hd q_rs)))
      in
      Desc_module (Module_declaration_many name (SOME [
          Port_decl_in (Input_decl (SOME NT_wire) F NONE [ID clk, ID re])
        , Port_decl_in (Input_decl (SOME NT_wire) F (port_range p_rs) [ID p_id])
        , Port_decl_out (Output_decl_reg F (port_range q_rs) [VPI (ID q_id) NONE])
        ])
        [NPM_Item (MOGI_always (Always (Statement_timing (PTC
          (PTC_event (Event_control_exp (Event_or
            (Event_pos (Exp_primary (prim_hier clk [])))
            (Event_pos (Exp_primary (prim_hier re []))))))
          (Statement_cond (COND_if_else
            ( (Exp_binary
                (Exp_primary (prim_hier re []))
                (B_log_eq)
                (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 1))))))
            , (Statement_nonblocking (Nonblocking_assignment var_lv NONE
                (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 0))))))))
            (SOME (Statement_nonblocking (Nonblocking_assignment var_lv NONE
              (Exp_primary (prim_hier p_id p_rs))))))))
          )))
        ])
;

let premade_ff_re_with_en name clk en p q =
      val (p_id, p_rs) = split_name_rng p in
      val (q_id, q_rs) = split_name_rng q in
      let var_lv =
            VLV_hier (hier q_id) (empty q_rs => NONE |
              SOME (map index_exp (tl q_rs), range_exp (hd q_rs)))
      in
      Desc_module (Module_declaration_many name (SOME [
          Port_decl_in (Input_decl (SOME NT_wire) F NONE [ID clk, ID en])
        , Port_decl_in (Input_decl (SOME NT_wire) F (port_range p_rs) [ID p_id])
        , Port_decl_out (Output_decl_reg F (port_range q_rs) [VPI (ID q_id) NONE])
        ])
        [NPM_Item (MOGI_always (Always (Statement_timing (PTC
          (PTC_event (Event_control_exp (Event_pos
            (Exp_primary (prim_hier clk [])))))
          (Statement_cond (COND_if_else
            ( (Exp_binary
                (Exp_primary (prim_hier en []))
                (B_log_eq)
                (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 1))))))
            , (Statement_nonblocking (Nonblocking_assignment var_lv NONE
                (Exp_primary (prim_hier p_id p_rs)))))
            (NONE)))))))
        ])
;

let premade_ff_re_with_en_reset name clk en re p q =
      val (p_id, p_rs) = split_name_rng p in
      val (q_id, q_rs) = split_name_rng q in
      let var_lv =
            VLV_hier (hier q_id) (empty q_rs => NONE |
              SOME (map index_exp (tl q_rs), range_exp (hd q_rs)))
      in
      Desc_module (Module_declaration_many name (SOME [
          Port_decl_in (Input_decl (SOME NT_wire) F NONE [ID clk, ID re, ID en])
        , Port_decl_in (Input_decl (SOME NT_wire) F (port_range p_rs) [ID p_id])
        , Port_decl_out (Output_decl_reg F (port_range q_rs) [VPI (ID q_id) NONE])
        ])
        [NPM_Item (MOGI_always (Always (Statement_timing (PTC
          (PTC_event (Event_control_exp (Event_or
            (Event_pos (Exp_primary (prim_hier clk [])))
            (Event_pos (Exp_primary (prim_hier re []))))))
          (Statement_cond (COND_if_else_if (IEI
            ( (Exp_binary
                (Exp_primary (prim_hier re []))
                (B_log_eq)
                (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 1))))))
            , (Statement_nonblocking (Nonblocking_assignment var_lv NONE
                (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 0))))))))
            [( (Exp_binary
                 (Exp_primary (prim_hier en []))
                 (B_log_eq)
                 (Exp_primary (Prim_num (NUM_dec (DEC (UNUM 1))))))
             , (Statement_nonblocking (Nonblocking_assignment var_lv NONE
                 (Exp_primary (prim_hier p_id p_rs)))))]
            (NONE))))))))
        ])
;

forward_declare{pretty_pexlif_h::string->pexlif->(description list)};

let pretty_pexlif_leaf {inst::string} name fa_inps fa_outs f_ints {fns::(update_fn list)} =
      let is_wire i = maybe T (in_any_lhs i fns) id in
      // Declare inp/out as 'port's.
      let f_inps = map fst fa_inps in
      let f_outs = let fs = map fst fa_outs in zip fs (map is_wire fs) in
      let ports_inp = pretty_decl_inps f_inps in
      let ports_out = pretty_decl_outs f_outs in
      let ports = let ps = ports_inp @ ports_out in empty ps => NONE | SOME ps in
      // Declare internals as 'reg'/'net' types (assume 'net' as default).
      let decl_int = map2 pretty_internal_decl f_ints (map is_wire f_ints) in
      // Translate assignments into 'assign'/'always' statements.
      let statements = map pretty_update_fn fns in
      //
      let module = inst_name name inst in
      let body = decl_int @ statements in
      [Desc_module (Module_declaration_many module ports body)]
;

let pretty_pexlif_hier {inst::string} name fa_inps fa_outs f_ints {cs::(pexlif list)} =
      let all_wire xs = replicate (length xs) F in
      // Declare inp/out as 'port's.
      let f_inps = map fst fa_inps in
      let f_outs = map (second (const T)) fa_outs in
      let ports_inp = pretty_decl_inps f_inps in
      let ports_out = pretty_decl_outs f_outs in
      let ports = let ps = ports_inp @ ports_out in empty ps => NONE | SOME ps in
      // Declare internals as 'net' types (hier. pex. only connects other pex.).
      let decl_int = map (flip pretty_internal_decl F) f_ints in
      // Instantiate and pretty children.
      let child i = sprintf "%s_%d" inst i in
      let children = concat (ixmap (\c. \i. pretty_pexlif_h (child i) c) cs) in
      let instant = ixmap (\c. \i. pretty_port_instantiation (child i) c) cs in
      //
      let module = inst_name name inst in
      let body = decl_int @ instant in
      (Desc_module (Module_declaration_many module ports body)) : children
;

let pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs _ _) assuming (name == "draw_ff_re") =
      val ((p,_):(clk,_):[]) = fa_inps in
      val ((q,_):[]) = fa_outs in
      let module = inst_name name inst in
      [premade_ff_re module clk p q]
/\  pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs _ _) assuming (name == "draw_ff_re_reset") =
      val ((p,_):(re,_):(clk,_):[]) = fa_inps in
      val ((q,_):[]) = fa_outs in
      let module = inst_name name inst in
      [premade_ff_re_reset module clk re p q]
/\  pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs _ _) assuming (name == "draw_ff_re_with_en") =
      val ((p,_):(en,_):(clk,_):[]) = fa_inps in
      val ((q,_):[]) = fa_outs in
      let module = inst_name name inst in
      [premade_ff_re_with_en module clk en p q]
/\  pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs _ _) assuming (name == "draw_ff_re_with_en_reset") =
      val ((p,_):(en,_):(re,_):(clk,_):[]) = fa_inps in
      val ((q,_):[]) = fa_outs in
      let module = inst_name name inst in
      [premade_ff_re_with_en_reset module clk en re p q]
/\  pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs f_ints (P_HIER cs)) =
      pretty_pexlif_hier inst name fa_inps fa_outs f_ints cs
/\  pretty_pexlif_h inst (PINST name _ _ fa_inps fa_outs f_ints (P_LEAF fs)) =
      pretty_pexlif_leaf inst name fa_inps fa_outs f_ints fs
;
// todo:
//   1> detect common components by name and then test if name is actually the
//      real component. Components are written in hfl.fl:
//      > flip-flops: re_ff, fe_ff, .. (base_.._ff)
//      > latches: base_ah_latch, base_al_latch,
//      > basically every "draw_..." pexlif.
//   ? compare components independent of sizes - like alpha but for sizes ?
//   2> use bdd to verify correctness of "simple" comb. operations.
//   3> write pexlif-"normalizer" to test with the random-pexlif generator.

// -----------------------------------------------------------------------------


// Modify the node wire names so that they all are valid according to
// the Verilog standard.
// Returns the new pexlif and a connection list for the top-level
// to make the new pexlif equivalent to the original.
let make_verilog_safe p =
    letrec clean (PINST nm attrs lf fa_inps fa_outs ints (P_HIER chs)) =
        letrec mk_int_sub i (v:vs) =
            let sz = md_size v then
            let new = sz = 1 => sprintf "m%d" i |
                                sprintf "m%d[%d:0]" i (sz-1)
            in
            ((v,new):(zip (md_expand_vector v) (md_expand_vector new)))
            @ (mk_int_sub (i+1) vs)
         /\   mk_int_sub i [] = []
        in
        let int_sub = mk_int_sub 1 (md_extract_vectors ints) then
        letrec mk_inp_sub i ((f,as):rem) =
            let sz = md_size f then
            let new = sz = 1 => sprintf "i%d" i |
                                sprintf "i%d[%d:0]" i (sz-1)
            in
            ((f,new):(zip (md_expand_vector f) (md_expand_vector new)))
            @ (mk_inp_sub (i+1) rem)
         /\   mk_inp_sub i [] = []
        in
        let inp_sub = mk_inp_sub 1 fa_inps then
        letrec mk_out_sub i ((f,as):rem) =
            let sz = md_size f then
            let new = sz = 1 => sprintf "o%d" i |
                                sprintf "o%d[%d:0]" i (sz-1)
            in
            ((f,new):(zip (md_expand_vector f) (md_expand_vector new)))
            @ (mk_out_sub (i+1) rem)
         /\   mk_out_sub i [] = []
        in
        let out_sub = mk_out_sub 1 fa_outs then
        let fa_inps' = map (\(f,as). assoc f inp_sub, as) fa_inps then
        let fa_outs' = map (\(f,as). assoc f out_sub, as) fa_outs then
        let ints' = map (\v. assoc v int_sub) ints then
        let sub = inp_sub @ out_sub @ int_sub then
        let try_assoc n = (assoc n sub) catch n in
        let rename (PINST lnm lattrs llf lfa_inps lfa_outs linst lbody) =
            let tr a =
                [(assoc a sub)] catch
                (md_merge_vectors (map try_assoc (md_expand_vector a)))
            in
            let tr_fa (f,as) = (f, flatmap tr as) in
            let lfa_inps' = map tr_fa lfa_inps then
            let lfa_outs' = map tr_fa lfa_outs then
            PINST lnm lattrs llf lfa_inps' lfa_outs' linst lbody
        in
        let chs' = map (\p. rename (clean p)) chs then
        PINST nm attrs lf fa_inps' fa_outs' ints' (P_HIER chs')
     /\    clean other = other
    in
    val (PINST nm attrs lf fa_inps fa_outs ints body) = clean p then
    let sub = (fa_inps @ fa_outs) then
    let fa_inps' = map (\(f,as).f,[f]) fa_inps in
    let fa_outs' = map (\(f,as).f,[f]) fa_outs in
    let final = (PINST nm attrs lf fa_inps' fa_outs' ints body) then
    (final, sub)
;

let safe_pexlif2verilog {fp::stream} {pex::pexlif} =
    val (pex',sub) = make_verilog_safe pex then
    let descriptions = pretty_pexlif_h "" pex' then
    let do1 d =
	(frender fp (p_source_text (Source_text [d]))) fseq (fprintf fp "\n\n")
    in
    (foreach do1 descriptions) fseq
    sub
;

let pexlif2verilog {fp::stream} {pex::pexlif} =
    val (PINST name attrs lf fa_inps fa_outs ints body) = pex in
    let non_matching_io (f,as) = (length as != 1) OR (f != (hd as)) in
    let idx = find_first0 non_matching_io (fa_inps @ fa_outs) then
    let pex' = idx = 0 => pex |
	let mk_io fa = map (\v. v, [v]) (md_extract_vectors (flatmap snd fa)) in
	let fa_inps' = mk_io fa_inps in
	let fa_outs' = mk_io fa_outs in
	PINST name attrs F fa_inps' fa_outs' [] (P_HIER [pex])
    then
    let descriptions = pretty_pexlif_h "" pex' then
    let do1 d =
	(frender fp (p_source_text (Source_text [d]))) fseq (fprintf fp "\n\n")
    in
    foreach do1 descriptions
;

end_abstype safe_pexlif2verilog pexlif2verilog;

// =============================================================================
