load "idv.fl";

open_idv_db "DB_arithm" F;

let SZ = sscanf "%d" (el 1 ARGS);

let make_theorem transform_name spec imp =
    let spec = convert_to_idv_format (remove_wrappers spec) then
    let imp = convert_to_idv_format (remove_wrappers imp) then
    NOT (SZ > 6 OR ((BDD_comb_EQ (wrap_pexlif spec) (wrap_pexlif imp)) == T)) =>
	eprintf "Claim %s is not valid!\n" transform_name
    |
    let signature = pexlif_get_FP spec then
    let imp_sha  = idv_save_pexlif imp then 
    let spec_sha = idv_save_pexlif spec then
    let tr = TRANSFORM transform_name spec_sha imp_sha [MK_THM] then
    (record_transformation signature tr)
;

let do_import_model name p =
    let p' = convert_to_idv_format (remove_wrappers p) then
    import_model name p'
;

TYPE "tp" SZ;
TYPE "tp1" (SZ+1);
TYPE "tp2" (2*SZ);

let a_vars = flatmap depends (wexpr2bool [] (hw_destr {'a::tp}));
let b_vars = flatmap depends (wexpr2bool [] (hw_destr {'b::tp}));
let c_vars = flatmap depends (wexpr2bool [] (hw_destr {'c::tp}));
let n_vars = flatmap depends (wexpr2bool [] (hw_destr {'n::tp}));
var_order (interleave [a_vars, b_vars, c_vars, n_vars]);


let add =
    tp_input a b.
    tp_output o.
    CELL "add" [
	o <- a '+' b
];

let add_rev =
    tp_input a b.
    tp_output o.
    CELL "add_rev" [
	o <- b '+' a
];

let add0 =
    tp_input a.
    tp_output o.
    internal b.
    CELL "add0" [
	b <- '0, 
	add a b o
];

let add0_rev =
    tp_input b.
    tp_output o.
    internal a.
    CELL "add0" [
	a <- '0, 
	add a b o
];

let wire =
    tp_input a.
    tp_output o.
    CELL "add0" [
	o <- a
];

let add3_21 =
    tp_input a b c.
    tp_output o.
    CELL "add3" [
	o <- (a '+' b) '+' c
];

let add3_12 =
    tp_input a b c.
    tp_output o.
    CELL "add3" [
	o <- a '+' (b '+' c)
];

let add_mod1 =
    tp_input a b n.
    tp_output o.
    CELL "add_mod" [
	ASSERT "a in range" (a '<' ''(2**(hw_size a -1))),
	ASSERT "b in range" (b '<' ''(2**(hw_size a -1))),
	ASSERT "n in range" (('0 '<' n) '&' ((n '<' ''(2**(hw_size a -1))))),
	o <- (a '+' b) '%' n
];

let add_mod2 =
    tp_input a b n.
    tp_output o.
    CELL "add_mod" [
	ASSERT "a in range" (a '<' ''(2**(hw_size a -1))),
	ASSERT "b in range" (b '<' ''(2**(hw_size a -1))),
	ASSERT "n in range" (('0 '<' n) '&' ((n '<' ''(2**(hw_size a -1))))),
	o <- ((a '%' n) '+' (b '%' n)) '%' n,
	ASSERT "o in range" (o '<' ''(2**(hw_size a -1)))
];


let mul =
    tp_input a b.
    tp_output o.
    CELL "mul" [
	o <- a '*' b
];

let mul_rev =
    tp_input a b.
    tp_output o.
    CELL "mul_rev" [
	o <- b '*' a
];

let mul1 =
    tp_input a.
    tp_output o.
    internal b.
    CELL "mul1" [
	b <- '1, 
	mul a b o
];

let mul1_rev =
    tp_input b.
    tp_output o.
    internal a.
    CELL "mul1" [
	a <- '1, 
	mul a b o
];

let mul3_21 =
    tp_input a b c.
    tp_output o.
    CELL "mul3" [
	o <- (a '*' b) '*' c
];

let mul3_12 =
    tp_input a b c.
    tp_output o.
    CELL "mul3" [
	o <- a '*' (b '*' c)
];

let mul_mod1 =
    tp_input a b n.
    tp_output o.
    CELL "mul_mod" [
	ASSERT "a in range" (a '<' ''(2**(hw_size a/2))),
	ASSERT "b in range" (b '<' ''(2**(hw_size a/2))),
	ASSERT "n in range" (('0 '<' n) '&' (n '<' ''(2**(hw_size a/2)))),
	o <- (a '*' b) '%' n
];

let mul_mod2 =
    tp_input a b n.
    tp_output o.
    CELL "mul_mod" [
	ASSERT "a in range" (a '<' ''(2**(hw_size a/2))),
	ASSERT "b in range" (b '<' ''(2**(hw_size a/2))),
	ASSERT "n in range" (('0 '<' n) '&' (n '<' ''(2**(hw_size a/2)))),
	o <- ((a '%' n) '*' (b '%' n)) '%' n,
	ASSERT "o in range" (o '<' ''(2**(hw_size a/2)))
];


let mul_impl =
    tp_input   {a:: *a} {b:: *a}.
    tp_output  {o:: *a}.
    let N = hw_size {'q:: *a} in
    list_internal N {psums:: *a list}.
    internal zero.
    CELL "mul_impl" (
        let mk_psum i =
            (el i psums) <-  (a '<<' (''(i-1))) '&' (SX (b~~(i-1)))
        in
        (map mk_psum (N -- 1))@
        [
	    o <- itlist (defix '+') psums zero,
	    zero <- '0
	]
);

// ----------------------------------------------------------------

// ----------------------------------------------------------------

let distr1 =
    tp_input a b c.
    tp_output  o.
    CELL "distr" [
	o <- a '*' (b '+' c)
];

let distr2 =
    tp_input a b c.
    tp_output  o.
    CELL "distr" [
	o <- (a '*' b) '+' (a '*' c)
];





//let mk n =
//    let name = sprintf "bv%d" n in
//    let type = core_TYPE name n T "" then
    

let A     = add {'a::tp} 'b 'o;
do_import_model (sprintf "A<%d>: a+b" SZ) A;
let Ar    = add_rev {'a::tp} 'b 'o;
do_import_model (sprintf "Ar<%d>: b+a" SZ) Ar;
let A0    = add0 {'a::tp} 'o;
do_import_model (sprintf "A0<%d>: a+0" SZ) A0;
let W	  = wire {'a::tp} 'o;
do_import_model (sprintf "W<%d>: wire" SZ) W;
let A0r   = add0_rev {'a::tp} 'o;
do_import_model (sprintf "A0r<%d>: 0+a" SZ) A0r;
let A3_21 = add3_21 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "A3_21<%d>: (a+b)+c" SZ) A3_21;
let A3_12 = add3_12 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "A3_12<%d>: a+(b+c)" SZ) A3_12;
let Amod1 = add_mod1 {'a::tp} 'b 'n 'o;
do_import_model (sprintf "Amod1<%d>: (a+b)%%n" SZ) Amod1;
let Amod2 = add_mod2 {'a::tp} 'b 'n 'o;
do_import_model (sprintf "Amod2<%d>: (a%%n + b%%n)%%n" SZ) Amod2;


make_theorem "add_is_commutative" A Ar;
make_theorem "add_a0_is_wire" A0 W;
make_theorem "wire_is_add_a0" W A0;
make_theorem "add_0b_is_wire" A0r W;
make_theorem "wire_is_add_0b" W A0r;
make_theorem "add_assoc_21-is_12" A3_21 A3_12;
make_theorem "add_assoc_12-is_21" A3_12 A3_21;
make_theorem "add_insert_mods" Amod1 Amod2;
make_theorem "add_remove_mods" Amod2 Amod1;

let B     = mul {'a::tp} 'b 'o;
do_import_model (sprintf "B<%d>: a*b" SZ) B;
let Br    = mul_rev {'a::tp} 'b 'o;
do_import_model (sprintf "Br<%d>: b*a" SZ) Br;
let B1    = mul1 {'a::tp} 'o;
do_import_model (sprintf "B1<%d>: a*1" SZ) B1;
let B1r   = mul1_rev {'a::tp} 'o;
do_import_model (sprintf "B1r<%d>: 1*a" SZ) B1r;
let B3_21 = mul3_21 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "B3_21<%d>: (a*b)*c" SZ) B3_21;
let B3_12 = mul3_12 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "B3_12<%d>: (a*(b*c)" SZ) B3_12;
let Bmod1 = mul_mod1 {'a::tp} 'b 'n 'o;
do_import_model (sprintf "mod1<%d>: (a*b)%%n" SZ) Bmod1;
let Bmod2 = mul_mod2 {'a::tp} 'b 'n 'o;
do_import_model (sprintf "mod2<%d>: (a%%n * b%%n)%%n" SZ) Bmod2;
let Bimp = mul_impl {'a::tp} 'b 'o;
do_import_model (sprintf "Bimp<%d>:" SZ) Bimp;

make_theorem "mul_is_commutative" B Br;
make_theorem "mul_a1_is_wire" B1 W;
make_theorem "wire_is_mul_a1" W B1;
make_theorem "mul_1b_is_wire" B1r W;
make_theorem "wire_is_mul_1b" W B1r;
make_theorem "mul_assoc_21_is_12" B3_21 B3_12;
make_theorem "mul_assoc_12_is_21" B3_12 B3_21;
make_theorem "mul_insert_mods" Bmod1 Bmod2;
make_theorem "mul_remove_mods" Bmod2 Bmod1;

make_theorem "mul_expand_to_sum_of_partial_products" B Bimp;
make_theorem "mul_collapse_from_sum_of_partial_products" Bimp B;

let D1 = distr1 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "D1<%d>: a*(b+c)" SZ) D1;
let D2 = distr2 {'a::tp} 'b 'c 'o;
do_import_model (sprintf "D2<%d>: (a*b)+(a*c)" SZ) D2;

make_theorem "mul_distributes_over_add" D1 D2;
make_theorem "reverse_mul_distributes_over_add" D2 D1;


fl_save_idv_db "exit";

quit;
