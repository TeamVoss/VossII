//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

let clean_error_message msg = hd (str_split msg "Stack trace");

let log_all_transformations = T;

//let log cmd p 

let Init_idv_gui = (tcl_eval [sprintf "source %sidv_gui.tcl" DIR]) fseq ();
NOT noX => Init_idv_gui | ();

let make_info_window title container =
    let t = (str_is_substr " " title) => sprintf "{%s}" title | title in
    let cmd = sprintf "idv:make_info_window %s %d" t (container => 1 | 0) in
    container => 
	tcl_eval [sprintf "winfo id [%s]" cmd]
    |
	tcl_eval [sprintf "%s" cmd]
;
non_lazy make_info_window;

let clean_name s =
    let tr c =
	c = " " => "_" |
	c = "{" => "_" |
	c = "}" => "_" | c
    in
    implode (map tr (explode s))
;

let EDIT_cmd file =
    let cmd = "/usr/bin/X11/xterm -sb -sl 20000 -j -rw -ls -bg white "^
	      "-fg black -fn 7x14 -geometry 80x40 -e /usr/bin/vi "
    in
    sprintf "%s %s" cmd file
;

let idv_gui_cnt_ref = ref 0;
let mk_idv_gui_window {dummy::void} =
    let idx = deref idv_gui_cnt_ref + 1 then
    (idv_gui_cnt_ref := idx) fseq
    sprintf ".idv_gui_%d" idx
;
non_lazy mk_idv_gui_window;

lettype idv_trfm_info =
    IDV_TRANSFORM_INFO
	{model_names :: (bool#string#string) list}// (top#name#sha256_sig) list
	{trfms :: ((int#transform list) list)}	// signature#(transform list)
;

lettype idv_rw_db =
    IDV_RW_DB
	    {sname:: string}		// Database short name
	    {fname:: string}		// Database full path name
		// Model names: [(spec # nm # sha_name)]
	    {mnames::(bool#string#string) list}
	    ({int,transform list} tbl)	// Transform table
;

let cur_idv_rw_transform_db = ref {[]:: idv_rw_db list};
let cur_idv_readonly_transform_dbs = ref {[]:: idv_rw_db list};

let db_sname (IDV_RW_DB sname fname mnames tbl) = sname;

let db_fname (IDV_RW_DB sname fname mnames tbl) = fname;

let db_mnames (IDV_RW_DB sname fname mnames tbl) = mnames;

let db_tbl (IDV_RW_DB sname fname mnames tbl) = tbl;

let DBG_get_tbl_entries {dummy::void} =
    tbl2list (db_tbl (hd (deref cur_idv_rw_transform_db)))
;
non_lazy DBG_get_tbl_entries;

let get_idv_db name =
    let dbs = (deref cur_idv_rw_transform_db)@
	      (deref cur_idv_readonly_transform_dbs)
    then
    let alts = filter (\db. db_sname db = name) dbs then
    alts = [] => eprintf "Cannot find a DB named %s" name |
    length alts > 1 => eprintf "More than one DB named %s" name |
    hd alts
;

let CHECK_FOR_RW_DB {dummy::void} =
    (deref cur_idv_rw_transform_db) != [] => () |
    eprintf "No IDV r/w database open."
;

let add_model_in_rw_db top_level name sha_name =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    ((find_first0 (\(top,mname,sha). mname = name) mnames) != 0)
    AND (
	let msg =
	    sprintf "A model named %s already exists. Replace it?" name
	in
	NOT (window_yes_no (get_current_idv_window ()) msg) 
    ) => () |
    let idx =
	let same_sha (top,mname,sha) = sha = sha_name in
	(find_first0 same_sha mnames)
    then
    (idx != 0) AND
    (
	val (top,mname,sha) = el idx mnames then
	let msg = (sprintf "This circuit is alrady named %s." mname)^
		  "  Do you still want to save it?"
	in 
	NOT (window_yes_no (get_current_idv_window ()) msg)
    ) => () |
    let mnames' = filter (\(top,mn,sn). mn != name) mnames then
    let mnames'' = (top_level, name, sha_name):mnames' then
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames'' tbl)])
;

let sha2model db sha_name =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    let same_sha (top,mname,sha) = sha = sha_name in
    let name (top,mname,sha) = mname in
    map name (filter same_sha mnames)
;

let model2sha db model_name =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    let same_model (top,mname,sha) = mname = model_name in
    let get_sha (top,mname,sha) = sha in
    let cands = map get_sha (filter same_model mnames) then
    cands = [] => eprintf "Cannot find model %s" model_name |
    length cands > 1 => eprintf "More than one model named %s" model_name |
    hd cands
;

let delete_model_in_rw_db model_name =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    let mnames' = filter (\(top,mname,sname). mname != model_name) mnames then
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames' tbl)])
;

let get_transform_tbl db =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    tbl
;

let update_rw_transform_tbl tbl' =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames tbl')])
;
non_lazy update_rw_transform_tbl;

let get_rw_db {dummy::void} =
    let cur_tbls = deref cur_idv_rw_transform_db then
    (cur_tbls = []) => eprintf "No IDV r/w database open." |
    (length cur_tbls > 1) => eprintf "More than one IDV r/w table open???" |
    hd cur_tbls
;
non_lazy get_rw_db;


let get_selected_wires vfsm =
    let selection = qsort node_name_cmp (deref (vfsm2selection_r vfsm)) then
    setify (md_expand_vectors selection)
;

let find_next_anon_name {dummy::void} =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let get_mname (top,mname,sha_name) = mname in
    let anons =
	map get_mname (filter (\p. str_is_prefix "anon_" (get_mname p)) mnames)
    in
    let next = 
	anons = [] => 1 |
	let indices = qsort (defix -) (map (sscanf "anon_%d") anons) in
	(last indices) + 1
    in
    sprintf "anon_%d" next
;
non_lazy find_next_anon_name;

let find_next_anon_transform_name signature class =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let cur = tbl_member tbl signature => tbl_get tbl signature | [] then
    let in_use = map get_transform_name cur then
    let anons = filter (str_is_prefix "tr_") in_use then
    let next = 
	anons = [] => 1 |
	let indices = qsort (defix -) (map (sscanf "tr_%d") anons) in
	(last indices) + 1
    in
    sprintf "tr_%d_%s" next class
;
non_lazy find_next_anon_transform_name;

//
// Much too simplistic and (fatally) not guaranteed to be valid!
//
letrec equal_pexlif (PINST nm1 attr1 lf1 in1 out1 int1 (P_HIER ch1))
		    (PINST nm2 attr2 lf2 in2 out2 int2 (P_HIER ch2)) =
    (find_signature attr1 == find_signature attr2) => T |
    (find_fingerprint attr1 != find_fingerprint attr2) => F |
    (length ch1) != (length ch2) => F |
    (length in1) != (length in2) => F |
    (length out1) != (length out2) => F |
    (length int1) != (length int2) => F |
    let mk_sub sp1 sp2 =
	val (PINST snm1 sattr1 slf1 sin1 sout1 sint1 sbody1) = sp1 in
	val (PINST snm2 sattr2 slf2 sin2 sout2 sint2 sbody2) = sp2 in
	NOT (equal_pexlif sp1 sp2) => (F,[]) |
	let ainp1 = md_expand_vectors (flatmap snd sin1) in
	let ainp2 = md_expand_vectors (flatmap snd sin2) in
	let aout1 = md_expand_vectors (flatmap snd sout1) in
	let aout2 = md_expand_vectors (flatmap snd sout2) in
	let sub = setify ((zip ainp1 ainp2)@(zip aout1 aout2)) then
	let idx = find_first0 (\l. length l > 1) (partition fst sub) in
	idx = 0 => (T,sub) | (F,[])
    in
    let subs = map2 mk_sub ch1 ch2 then
    let idx = find_first (\p. NOT (fst p)) subs in
    idx != 0 => F |
    let sub = setify (flatmap snd subs) then
    let idx = find_first0 (\l. length l > 1) (partition fst sub) in
    idx = 0
 /\    equal_pexlif _ _ = F
;


let get_idv_candidates p =
    let signature = pexlif_get_FP p then
    let get_cand db =
	let tbl = get_transform_tbl db in
	tbl_member tbl signature => [(db,(tbl_get tbl signature))] | []
    in
    let pots = flatmap get_cand ((deref cur_idv_rw_transform_db)@
				 (deref cur_idv_readonly_transform_dbs))
    then
    let check (db,alts) =
	let same_spec (TRANSFORM name spec imp just) =
	    let ps = read_pexlif spec then
	    equal_pexlif p ps
	in
	let alts' = filter same_spec alts then
	alts' = [] => [] | [(db,alts')]
    in
    flatmap check pots
;


let record_transformation signature tr =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let old = tbl_member tbl signature => tbl_get tbl signature | [] then
    let new = tr:old then
    let tbl' = tbl_member tbl signature => tbl_delete tbl signature | tbl then
    let tbl'' = tbl_insert tbl' signature new then
    update_rw_transform_tbl tbl''
;

let load_idv_db sname fname =
    let db_file = sprintf "%s/transform_db" fname then
    NOT (file_exists db_file) => IDV_RW_DB sname fname [] (list2tbl []) |
    val (IDV_TRANSFORM_INFO mnames sig_trfs) = read_idv_trfm_info db_file then
    let tbl = list2tbl sig_trfs then
    IDV_RW_DB sname fname mnames tbl
;

let fl_save_idv_db {cmd::string} =
    let dbl = deref cur_idv_rw_transform_db then
    dbl = [] => () |
    val (IDV_RW_DB sname fname mnames tbl) = hd dbl then
    let sig_transf_list = tbl2list tbl then
    let data = IDV_TRANSFORM_INFO mnames sig_transf_list then
    let db_file = sprintf "%s/transform_db" fname then
    (NOT (file_exists db_file) => () |
	system (sprintf "/bin/mv -f %s %s.bkp" db_file db_file) fseq ()
    ) fseq
    (write_idv_trfm_info db_file data) fseq 
    cmd != "exit" => () |
    // If exit, remove lock file and clean up
    let cmd = sprintf "/bin/rm -f %s/lock" fname in
    (system cmd) fseq
    (cur_idv_rw_transform_db := [])
;
export_to_tcl fl_save_idv_db;

let open_idv_db dir readonly =
    NOT readonly AND ((deref cur_idv_rw_transform_db) != []) =>
	eprintf "Only one r/w IDV database can be open at the same time"
    |
    let do_cmd cmd =
	let status = system cmd then
	status = 0 => () |
	eprintf "FAILURE: %s\n" cmd
    in
    let full_name = normalize_file dir then
    let my_host = hd (snd (exec "hostname")) then
    let my_pid  = pid then
    NOT (file_exists full_name) =>
	readonly => eprintf "%s is not a readable IDV database" dir |
	(do_cmd (sprintf "mkdir %s" dir)) fseq
	(do_cmd (sprintf "mkdir %s/code" dir)) fseq
	(do_cmd (sprintf "mkdir %s/pexlifs" dir)) fseq
	let fp = fopen (sprintf "%s/lock" full_name) "w" then
	(fprintf fp "%s|%d" my_host my_pid) fseq
	(fclose fp) fseq
	cur_idv_rw_transform_db :=
	    [(IDV_RW_DB dir full_name [] (tbl_create 100))]
    |
    // Check that the DB looks ok
    let check_file file =
	file_exists (sprintf "%s/%s" full_name file) => () |
	eprintf "IDV database corrupted. Missing %s\n" file
    in
    (check_file "pexlifs") fseq
    (check_file "code") fseq
    readonly =>
	let db_info = load_idv_db dir full_name then 
	let cur_dbs = deref cur_idv_readonly_transform_dbs then
	(cur_idv_readonly_transform_dbs := (db_info:cur_dbs))
    |
    // For read/write data bases, check that no active lock exists
    let lockfile = sprintf "%s/lock" full_name then
    // Make sure DB isn't locked by a running process
    (NOT (file_exists lockfile) => () |
	let fp = fopen lockfile "r" then
	let line = fgets fp then
	let parts = str_split line "|" then
	(fclose fp) fseq
	length parts != 2 => eprintf "Corrupted lockfile (%s)" line |
	val [lhost,lpid] = parts in
	let lpid_alive =
	    (snd (exec (sprintf "ps --no-headers --pid %s" lpid))) != []
	then
	lhost == my_host AND lpid_alive =>
	    eprintf "IDV_DB %s is owned by running process %s" full_name lpid
	| 
	(fprintf stdinfo "-I-: removing lockfile since owner no longer alive\n")
	fseq
	(do_cmd (sprintf "/bin/rm -f %s" lockfile)) 
    ) fseq
    // Write lockfile
    let fp = fopen (sprintf "%s/lock" full_name) "w" then
    (fprintf fp "%s|%d" my_host my_pid) fseq
    (fclose fp) fseq
    let db_info = load_idv_db dir full_name then 
    (cur_idv_rw_transform_db := [db_info])
;

let get_idv_db_dir {dummy::void} =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    fname
;
non_lazy get_idv_db_dir;

let is_rw_db db_name =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    db_name == sname
;

let get_db_info db_name =
    let pot_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let idx = find_first0 (\t. (db_sname t) = db_name) pot_dbs in
    idx = 0 =>
	eprintf "Cannot find %s in %S" db_name (map db_sname pot_dbs)
    |
    el idx pot_dbs
;

let get_db_dir db_name = db_fname (get_db_info db_name);

let get_models db_name toplevel_only = 
    let get_model (top,model,sha) = model in
    let raw = db_mnames (get_db_info db_name) then
    let relevant = toplevel_only => filter fst raw | raw then
    map get_model relevant
;

let get_sha_for_model db model =
    let is_sel_model (top,mname,sha) = mname = model in
    let alts = filter is_sel_model (db_mnames (get_db_info db)) then
    alts = [] => eprintf "Cannot find model %s" model |
    length alts > 1 => eprintf "More than model named %s" model |
    val [(top,mname,sha)] = alts in
    sha
;


//let get_db_mnames db_name =
//    val (sname,fname,mnames,tbl) = get_db_info db_name then
//    mnames
//;

let get_db_transf_tbl db_name =
    val (IDV_RW_DB sname fname mnames tbl) = get_db_info db_name then
    tbl
;

let idv_save_pexlif p =
    let sha = pexlif_get_SHA p then
    let db_dir = get_idv_db_dir () then
    let file = sprintf "%s/pexlifs/%s" db_dir sha in
    file_exists file => sha |
    ((write_pexlif file p) fseq sha)
;


let idv_load_pexlif db p_sha =
    let db_dir = get_db_dir db then
    let file = sprintf "%s/pexlifs/%s" db_dir p_sha in
    file_exists file => read_pexlif file |
    eprintf "Failed to load %s. IDV database corrupted?" file
;


let cur_transf_windowsr = ref {[]:: (string#vfsm) list};

let get_new_idv_window {dummy :: void} =
    let l = length (deref cur_transf_windowsr) then
    sprintf ".idv_%d" l
;
non_lazy get_new_idv_window;

let get_number_of_children (PINST _ _ _ _ _ _ (P_HIER chs)) =
    length chs
 /\ get_number_of_children other = 0
;

let refresh_idv_canvas canvas cmd =
    (start_draw_op canvas) fseq
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent inside sell rvis rtrf) = evis then
    let trf = get_idv_info canvas then
    val (p,ckt,_) = hd trf in
    let outs = outputs ckt then
    let props = assertions ckt then
    let vis = visualize_fanin ckt [] [] 100 (outs@props) 0 then
    (rvis := vis) fseq
    (rtrf := trf) fseq
    (add_command vfsm cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas,
                sprintf "sc:remove_draw_info %s" canvas
              ]) fseq
    ()
;


let start_new_transform p w =
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    let props = assertions ckt then
    //
    let vfsm = w2vfsm w then
    let vis = visualize_fanin ckt [] [] 100 (outs@props) 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" "" then
    (start_draw_op c) fseq
    let cmd = "DUMMY" in
    let evis = TR_SEQ "" F [] (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
	      ]
    ) fseq
    ()
;

let import_model name p =
    p fseq
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let p_sha  = idv_save_pexlif p then
    (add_model_in_rw_db T name p_sha) fseq
    ()
;

let get_current_model model_name =
    let db = get_rw_db () then
    val (IDV_RW_DB sname fname mnames tbl) = db then
    let sha_imp = model2sha db model_name then
    idv_load_pexlif sname sha_imp
;

let IDV0 rw_database read_only_dbs =
    // Open the databases
    (open_idv_db rw_database F) fseq
    (foreach (\db. open_idv_db db T) read_only_dbs) fseq
    // Start GUI
    noX => "" |
    let w = get_new_idv_window () then
    (tcl_eval [sprintf "idv:create_idv_gui %s %s 0" w rw_database]) fseq
    let vfsm = IDV_ENV w (ref []) (ref []) (ref []) (ref []) (ref []) in
    (cur_vfsm := (vfsm:(deref cur_vfsm))) fseq
    (register_vfsm vfsm w) fseq
    (cur_transf_windowsr := ((w,vfsm):(deref cur_transf_windowsr))) fseq
    w
;

let IDV_dbg p rw_database read_only_dbs =
    let w = IDV0 rw_database read_only_dbs then
    let name = pexlif_get_name p then
    (import_model name p) fseq
    noX => "" |
    (tcl_eval ["idv:update_idv_list"]) fseq
    w
;

overload IDV IDV0 IDV_dbg;


let add_transform canvas p tr =
    let vfsm = w2vfsm canvas in
    let ckt = accurate_toplevel_pexlif2fsm p then
    let trfsr = get_idv_info_r canvas then
    (trfsr := ((p,ckt,tr):(deref trfsr))) fseq
    ()
;
non_lazy add_transform;

let fl_is_toplevel_transform canvas =
    val (parent,inside,sell) = get_idv_parent_info canvas then
    parent == ""
;
export_to_tcl fl_is_toplevel_transform;


let unfold_all_labeled p lbl =
    letrec do1 p =
	val (PINST nm attrs lf fa_inps fa_outs ints (P_HIER chs)) = p in
	let idx = find_first0 (\p. pexlif_get_name p = lbl) chs in
	idx = 0 => p |
	let p' = unfold_pexlif p idx then
	do1 p'
    in
    do1 p
;

let rename_name (PINST _ attrs lf fa_inps fa_outs ints body) new_name =
    PINST new_name attrs lf fa_inps fa_outs ints body
;

let get_selected_pinsts canvas =
    let vfsm = w2vfsm canvas in
    let selection = deref (vfsm2selection_r vfsm) then
    let p = get_idv_current_pexlif canvas then
    let tst pp = ((pexlif_get_outs_actuals pp) vec_intersect selection) != [] in
    find_all tst (pexlif_get_children p)
;


let fl_do_fold canvas name =
  (
    let name' = "draw_hier "^name then
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let p = get_idv_current_pexlif canvas then
    let p' = fold_pexlif p il name' then
    (add_transform canvas p' (FOLD il name')) fseq
    let cmd = sprintf "fold vis %s \"%s\";"
		      (list2str T "[" "," "]" int2str il) name
    in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_fold;

let fl_do_unfold canvas =
  (
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    // Process the unfolds in reverse order
    // Relies on unfold1 i does not change children 1--(i-1).
    let il = qsort (\i1.\i2. i1-i2) (setify il) then
    let p = get_idv_current_pexlif canvas then
    let p' = itlist (\i.\p. unfold_pexlif p i) il p then
    (add_transform canvas p' (UNFOLD il)) fseq
    let cmd = sprintf "unfold vis %S;" (map int2str il) in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_unfold;

let fl_do_flatten canvas =
  (
    let vfsm = w2vfsm canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = flatten_pexlif p then
    (add_transform canvas p' FLATTEN) fseq
    let cmd = sprintf "flatten vis;" in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_flatten;

let fl_do_idv_undo canvas =
    let vfsm = w2vfsm canvas then
    let trfsr = get_idv_info_r canvas then
    let trfs = deref trfsr then
    length trfs <= 1 => () |
    let trfs' = tl trfs then
    (trfsr := trfs') fseq
    val (p,ckt,_) = hd trfs' in
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent inside sell rvis rtrf) = evis then
    let outs = outputs ckt then
    let props = assertions ckt then
    (start_draw_op canvas) fseq
    let vis = visualize_fanin ckt [] [] 100 (outs@props) 0 then
    (rvis := vis) fseq
    (rtrf := trfs') fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas,
                sprintf "sc:remove_draw_info %s" canvas
              ]) fseq
    ()
;
;
export_to_tcl fl_do_idv_undo;


let duplicate_instance p idx =
    let io = buid_io_tbl p then
    let fanouts = inst_fanout io idx then
    length fanouts < 2 => p |
    let name_db = build_name_db p then
    let to_reconnect = mem idx fanouts => fanouts subtract [idx] | tl fanouts in
    let selected = io_get_child io idx then
    val (PINST sname sattrs slf sfa_inps sfa_outs sints sbody) = selected in
    let aouts = md_extract_vectors (flatmap snd sfa_outs) then
    let new_ints = ref [] in
    let process1 d_idx =
	let driven = io_get_child io d_idx in
	val (PINST dname dattrs df dfa_inps dfa_outs dint dbody) = driven in
	let aouts' = map (get_unique_name name_db) aouts then
	(new_ints := (aouts' @ (deref new_ints))) fseq
	let vsub = vec_zip aouts aouts' then
	let dfa_inps' =
	    let tr (f, as) =
		let tr1 a = (vec_assoc a vsub) catch [a] in
		f, (flatmap tr1 as)
	    in
	    map tr dfa_inps
	in
	let driven' = PINST dname dattrs df dfa_inps' dfa_outs dint dbody then
	let sfa_outs' =
	    let tr (f, as) =
		let tr1 a = (vec_assoc a vsub) catch [a] in
		f, (flatmap tr1 as)
	    in
	    map tr sfa_outs
	in
	let copy = (PINST sname sattrs slf sfa_inps sfa_outs' sints sbody) then
	[copy, driven']
    in
    let new = flatmap process1 to_reconnect then
    val (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) = p then
    let keep = gather cs ((1 upto (length cs)) subtract to_reconnect) then
    let cs' = keep @ new then
    let ints' = ints @ (deref new_ints) then
    (PINST name attrs lf fa_inps fa_outs ints' (P_HIER cs'))
;



let fl_do_duplicate canvas =
  (
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    length il > 1 => 
	report_error "Can only duplicate one instance at a time"
    |
    let p = get_idv_current_pexlif canvas then
    let p' = duplicate_instance p (hd il) then
    (add_transform canvas p' (DUPLICATE (hd il))) fseq
    let cmd = sprintf "duplicate vis %d;" (hd il) in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_duplicate;




let mk_buf inps outs =
    let vinps = md_merge_vectors inps in
    let vouts = md_merge_vectors outs in
    let sz = md_sizes vinps in
    md_sizes vouts != sz => error "Length mismatch in mk_buf" |
    let p = (W_VAR sz "o") <- (W_VAR sz "i") in
    val (PINST name attrs leaf [(fi,_)] [(fo,_)] ints body) = p in
    PINST name attrs leaf [(fi,vinps)] [(fo,vouts)] ints body
;

let merge_instances p ids =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
    let sels = map (\i. el i chs) ids in
    length sels <= 1 => p |
    let remain = chs subtract sels in
    let master = hd sels in
    let victims = tl sels in
    // Make sure all victims are the same as the master
    let not_identical_pexlif p1 p2 =
	pexlif_get_SHA p1 != pexlif_get_SHA p2 => T |
	val (PINST _ _ _ fa_inps1 fa_outs1 _ _) = p1 in
	val (PINST _ _ _ fa_inps2 fa_outs2 _ _) = p2 in
	let cmp (f1,as1) (f2,as2) = strcmp f1 f2 in
	let i1 = qsort cmp fa_inps1 in
	let i2 = qsort cmp fa_inps2 in
	i1 != i2
    in
    let idx = find_first0 (not_identical_pexlif master) victims then
    idx != 0 => 
	report_error "Not all selected instances are identical" fseq p
    |
    let get_fa_out (PINST _ _ _ _ fa_outs _ _) = fa_outs in
    let master_sub = get_fa_out master in
    let mk_sub vp =
	let v_fa_outs = get_fa_out vp then
	let mk (vf,vas) =
	    let mas = assoc vf master_sub in
	    zip (md_expand_vectors vas) (md_expand_vectors mas) 
	in
	flatmap mk v_fa_outs
    in
    let subs = flatmap mk_sub victims then
    let rename a = (assoc a subs) catch a in
    let rename_fa fa =
	let rename1 (f,as) =
	    f, (md_merge_vectors (map rename (md_expand_vectors as)))
	in
	map rename1 fa
    in
    let rename_pexlif (PINST name attrs leaf fa_inps fa_outs ints body) =
	let fa_inps' = rename_fa fa_inps in
	let fa_outs' = rename_fa fa_outs in
	(PINST name attrs leaf fa_inps' fa_outs' ints body)
    in
    // Build new pexlif
    let chs = map rename_pexlif (master:remain) in
    let mk_wire (f,as) =
	let nds = md_expand_vector f in
	let nds' = map rename nds in
	nds' = nds => [] |
	// Must add a buffer since multiple outputs are now driven
	// by the same signal
	[mk_buf nds' nds]
    in
    let buffers = flatmap mk_wire (fa_outs) then
    let chs' = buffers@chs then
    // TODO: Clean up "ints"
    (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs'))
;


let fl_do_merge canvas =
  (
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = merge_instances p il then
    (add_transform canvas p' (MERGE il)) fseq
    let cmd = sprintf "merge vis %s;" (list2str T "[" "," "]" int2str il) in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_merge;

let fl_do_new_tranf canvas =
  (
    let vfsm = w2vfsm canvas then
    let w = vfsm2id vfsm then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let parent = get_idv_current_pexlif canvas then
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif parent il "_TMP_" then
    val (PINST _ _ _ _ _ _ (P_HIER chs)) = p' in
    let p = el 1 chs then
    //
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    let props = assertions ckt then
    let vis = visualize_fanin ckt [] [] 100 (outs@props) 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" "" then
    (start_draw_op c) fseq
    let cmd =
	let tab = canvas2tab c then
	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") outs in
	sprintf "OBSOLETE: let %s = draw_fanin vis (%d) %d %s;\n%s;"
		 tab 0 100 svecs tab
    in
    let evis = TR_SEQ canvas F il (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
	      ]) fseq
    ()
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_new_tranf;

let fl_model_name_used name =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let idx = find_first0 (\(top,mname,sha). mname = name) mnames then
    idx != 0
;
export_to_tcl fl_model_name_used;

let fl_do_name_model canvas name version =
    let trfs = get_idv_info canvas then
    let p = fst (version = "specification" => (last trfs) | (hd trfs)) then
    let p_sha  = idv_save_pexlif p then
    add_model_in_rw_db F name p_sha
;
export_to_tcl fl_do_name_model;

let fl_idv_get_db_names {canvas::string} =
    map db_sname ((deref cur_idv_rw_transform_db)@
		      (deref cur_idv_readonly_transform_dbs))
;
export_to_tcl fl_idv_get_db_names;

let fl_get_idv_models {canvas::string} db visible pat =
    let relevant = 
	visible = "All" => get_models db F |
	visible = "User given" =>
	    let user_given n = NOT (str_is_prefix "anon_" n) in
	    filter user_given (get_models db F) |
	visible  = "Imported" => get_models db T |
	eprintf "Unknwn visible argument (%s)" visible
    then
    qsort strcmp (filter (str_match pat) relevant)
;
export_to_tcl fl_get_idv_models;

let get_transform_fanout p =
    let p_fp = pexlif_get_FP p then
    let p_SHA = pexlif_get_SHA p then
    let all_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let get_fanout db =
	val (IDV_RW_DB sname fname mnames tbl) = db in
	let get_info (TRANSFORM name sha_spec sha_imp just) =
	    p_SHA != sha_spec => [] |
	    let id = sprintf " %s:%s" sname name in
	    let dest = sha2model db sha_imp in
	    dest = [] => [] |
	    [(id, hd dest, (idv_load_pexlif sname sha_imp))]
	in
	flatmap get_info (tbl_member tbl p_fp => tbl_get tbl p_fp | [])
    in
    flatmap get_fanout all_dbs
;

let fl_do_new_toplevel_transf {w::string} db name =
    (CHECK_FOR_RW_DB ()) fseq
    let p_sha = get_sha_for_model db name then
    let p = idv_load_pexlif db p_sha then
    (start_new_transform p w) fseq
    (tcl_eval ["update"]) fseq
    is_rw_db db => () |
    (tcl_eval [sprintf "idv:name_and_save_model %s specification {%s}" w name])
    fseq ()
;
export_to_tcl fl_do_new_toplevel_transf;

letrec trim_leading_space s =
	s = "" => s |
	(string_hd s) != " " => s | trim_leading_space (string_tl s)
;

let fl_format_transf_name max_size name =
    // Strip database name
    let tr_name = list2str T "" ":" "" id (tl (str_split name ":")) then
    // Remove leading space
    let tr_name = trim_leading_space tr_name in
    // Insert newlines to avoid too long lines
    letrec split_lines cur_len (n:ns) =
	let l = strlen n in
	n^((cur_len+l) > max_size => ("\n"^(split_lines 0 ns))
				   | (" "^(split_lines (cur_len+l+1) ns)))
     /\    split_lines _ [] = ""
    in
    split_lines 0 (str_split tr_name " ")
;
export_to_tcl fl_format_transf_name;

let fl_display_transform_tree canvas dbname name =
    (tcl_eval ["catch {unset ::idv_transf_node_map}"]) fseq
    let db = get_idv_db dbname then
    let p_sha = model2sha db name then
    let p = idv_load_pexlif dbname p_sha then
    let done = ref [] in
    let vertices = ref [] in
    let edges = ref [] in
    let vertex_map = ref [] in
    let edge_map = ref [] in
    letrec fanout_rec name p =
	let idx = find_first0 (\pp. fst pp == p) (deref done) then
	idx != 0 => snd (el idx (deref done)) |
	let vertex_name = sprintf "n%d" (length (deref done)) then
	let ext_name = sprintf "%s:%s" dbname name in
	(vertex_map := ((vertex_name,ext_name):(deref vertex_map))) fseq
	let sz = float2str (int2float (1+strlen ext_name)*0.1) then
	let dc = sprintf
      "%s [shape=box, fixedsize=shape, label = \"%s\", fontname=\"Courer New\", fontsize=\"12\"]\n"
			vertex_name vertex_name
	then
	(vertices := (dc:(deref vertices))) fseq
	(done := ((deref done)@[(p,vertex_name)])) fseq
	let next_states = get_transform_fanout p then
	let mk_edge (trans_name, dest_name, p_dest) =
	    let dest = fanout_rec dest_name p_dest then
	    let edge_name =
		let name = clean_name (trim_leading_space trans_name) in
		let len = strlen name in
		let name' = len <= 200 => name | string_butlastn name (len-20) in
		sprintf "e%d-%s" (length (deref edges)) name'
	    then
	    (edge_map := ((edge_name, trans_name):(deref edge_map))) fseq
	    let edge = sprintf "%s -> %s [ label = \"%s\", fontname=\"Courier New\", fontsize=\"12\"];\n"
			       vertex_name dest edge_name
	    then
	    (edges := (edge:(deref edges)))
	in
	(foreach mk_edge next_states) fseq
	vertex_name
    in
    let res = fanout_rec name p then
    //
    let fp = mktemp "transform_draw" then
    let file = stream2filename fp then
    (fprintf fp "digraph transform_tree {\n") fseq
    (fprintf fp "rankdir=TB;\n") fseq
    (foreach (fprintf fp "%s") (deref vertices)) fseq
    (foreach (fprintf fp "%s") (deref edges)) fseq
    (fprintf fp "}\n") fseq
    (fclose fp) fseq
    //
    let mk_ndmap (n,nn) =
	let cmd = sprintf "set ::idv_transf_node_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_ndmap (deref vertex_map)) fseq
    //
    (tcl_eval ["catch {unset ::idv_transf_edge_map}"]) fseq
    let mk_edgemap (n,nn) =
	let cmd = sprintf "set ::idv_transf_edge_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_edgemap (deref edge_map)) fseq
    //
    (tcl_eval [sprintf "idv:show_transformations %s %s" file canvas]) fseq
    ()
;

export_to_tcl fl_display_transform_tree;

//cletrec convert_to_idv_format p =
//    letrec cnv p =
//	let do1 (PINST nm attrs lf fa_inps fa_outs ints (P_HIER ps)) =
//	    let ps' = map cnv ps then
//	    let get_assert_nd (PINST _ _ _ _ outs _ _) =
//		length outs != 1 => [] |
//		val (f,as) = hd outs then
//		md_size f != 1 => [] |
//		let a = hd as in
//		str_is_substr "assert__" a => as | []
//	    in
//	    let assertion_nds = flatmap get_assert_nd ps' then
//	    (assertion_nds = []) AND (ps' == ps) => p |
//	    let ints' = ints @ assertion_nds then
//	    PINST nm attrs lf fa_inps fa_outs ints' (P_HIER ps')
//	 /\    do1 (PINST nm attrs lf fa_inps fa_outs ints leaf) =
//	    PINST nm attrs lf fa_inps fa_outs ints leaf
//	in
//	do1 p
//    in
//    cnv p
//;

let fl_import_model w filename =
    let p = read_pexlif filename then
    let tent_name = pexlif_get_name p then
    let name = 
	(tent_name != "") AND (NOT (fl_model_name_used tent_name))
	=> tent_name | tcl_eval ["idv:ask_for_model_name "^w]
    then
    (import_model name p) fseq
    (tcl_eval ["idv:update_idv_list"]) fseq
    ()
;
export_to_tcl fl_import_model;

let generate_hfl_template fp p basename pexlif_file =
    val (PINST name attrs lf fa_inps fa_outs ints body) = p in
    (fprintf fp "load \"ste.fl\";\n") fseq
    let name' = clean_name basename then
    let inps = map fst fa_inps in
    let outs = map fst fa_outs in
    let ios = inps @ outs in
    let szs = qsort (defix -) (setify (map md_size ios)) in
    let declare sz = 
	sz = 1 => () |
	fprintf fp "TYPE \"bv%d\" %d;\n" sz sz
    in
    (foreach declare szs) fseq
    (fprintf fp "\nlet %s =\n" name') fseq
    let rcnt = ref 1 in
    let emit_io io v =
	let sz = md_size v in
	let type = sz = 1 => "bit" | sprintf "bv%d" sz in
	let idx = deref rcnt then
	(rcnt := idx+1) fseq
	let base = sprintf "%s%d" (io = "input" => "i" | "o") idx then
	(fprintf fp "    %s_%s   %s.  // %s\n" type io base v)
    in
    (foreach (emit_io "input") inps) fseq
    (rcnt := 1) fseq
    (foreach (emit_io "output") outs) fseq
    (fprintf fp "    CELL \"%s\" [\n\n    // Your code\n\n];\n" basename) fseq
    (fprintf fp "\n\nlet p = %s" name') fseq
    let emit_tv v =
	let sz = md_size v in
	let type = sz = 1 => "bit" | sprintf "bv%d" sz in
	(fprintf fp "\n\t\t{(_s2_var \"%s\")::%s}" v type)
    in
    (foreach emit_tv (ios)) fseq
    (fprintf fp "\n;\np fseq ();\n") fseq
    (fprintf fp "write_pexlif \"%s\" p;\n" pexlif_file) fseq
    (fprintf fp "\"===SuCcEsS===\";\n") fseq
    (fprintf fp "quit;\n")
;

//let make_anon_names top_name p =
//    letrec mk_anon inst (PINST nm attrs lf fa_inps fa_outs ints (P_HIER chs)) =
//	let nm' = inst in
//	letrec do i (c:cs) =
//	    let inst' = sprintf "%s_%d" inst i in
//	    let c' = mk_anon inst' c then
//	    c' : (do (i+1) cs)
//	 /\   do i [] = []
//	in
//	let chs' = do 1 chs then
//	let nm'' =
//	    (str_is_prefix "draw_" nm) AND NOT (str_is_prefix "draw_hier" nm) =>
//	    nm | nm'
//	in
//	PINST nm'' attrs lf fa_inps fa_outs ints (P_HIER chs')
//     /\   mk_anon inst (PINST nm attrs lf fa_inps fa_outs ints leaf) =
//	PINST inst attrs lf fa_inps fa_outs ints leaf
//    in
//    mk_anon top_name p
//;

let make_anon_names top_name p =
    val (PINST nm attrs lf fa_inps fa_outs ints body) = p in
    PINST top_name attrs lf fa_inps fa_outs ints body
;

let create_verilog_load_file basename file pexlif_file =
    let fp = mktemp "verilog_reader" then 
    let load_file = stream2filename fp then
    (fprintf fp "load \"ste.fl\";\n") fseq
    (fprintf fp "let p = verilog2pexlif F \"-I.\" \"%s\" [\"%s\"] [];\n"
		basename file) fseq
    (fprintf fp "p fseq (write_pexlif \"%s\" p);\n" pexlif_file) fseq
    (fprintf fp "\"===SuCcEsS===\";\n") fseq
    (fprintf fp "quit;\n") fseq
    (fclose fp) fseq
    load_file
;

let synth_args_ref = ref {[] :: (string#string) list};
let synth_script_ref   = ref {[]:: string list};
let synth_stdcell_names = ref {[]:: string list};

let get_synth_opt key =
    (assoc key (deref synth_args_ref)) catch
    eprintf "Failed to find synthesis option '%s'\n" key
;


let fl_get_synthesis_script_dir {dummy::void} =
    sprintf "%s/yosys_scripts" DIR
;
export_to_tcl fl_get_synthesis_script_dir;

let do_synthesis file bname pexlif_file p synth_type synth_script =
    let cw = make_info_window "Write Verilog" F then
    let info_cmd = "echo 'Clean and write out synthesis friendly Verilog'\n" in
    val (status, _, _) = gui_exec cw "Prepare for synthesis" info_cmd "" then
    status = "SIGKILL" => "" |
    // Rename Verilog hierarchy to sane names
    // Toplevel name is `bname`
    let p' = make_anon_names bname p then
    val (PINST nm attrs lf fa_inps fa_outs ints body) = p' then
    let ios = map fst (fa_inps @ fa_outs) then
    // Write out a Verilog version of the pexlif
    let fp = mktemp "pre_verilog" then
    let pre_v_file = stream2filename fp then
    let io_sub = safe_pexlif2verilog F fp p' then
    (fclose fp) seq
    let edit_file = sprintf "%s/verilog_filter.sed" DIR then
    let cmd = sprintf "sed -f %s < %s > %s.v" edit_file pre_v_file file then
    (system cmd) != 0 => eprintf "System command |%s| failed\n" cmd |
    // Create a yosys synthesis script for this Verilog file
    (synth_args_ref := [
	    ("basename", bname),
	    ("file",	 file),
	    ("flatten",  (synth_type = "Flat" => "flatten" | "")),
	    ("libdir", DIR^"../../../../lib/osu018_stdcells/")]) fseq
    (_load (sprintf "%s/%s.fl" (fl_get_synthesis_script_dir ()) synth_script) F)
    seq
    let fp = mktemp "yosys_script" then
    let yosys_file = stream2filename fp then
    let script = deref synth_script_ref then
    (list2fp fp T "" "" "" (\fp.\s. fprintf fp "%s\n" s) script) fseq
    (fclose fp) seq
    // Now run Yosys 
    let wr_pexlif = (get_vossrc "VOSS-BINARY-DIRECTORY")^"/write_pexlif.so" in
    let cmd = sprintf "yosys -m %s -s %s" wr_pexlif yosys_file then
    let cw = make_info_window "Yosys" F then
    val (status, emsg, logfile) = gui_exec cw "Yosys synthesis" cmd "" then
    status = "SIGKILL" => "" |
    status != "0" => eprintf "yosys failed\nSee %s for details" logfile |
    // Now append the loading commands
    let fp = fopen (file^"_load.fl") "w" then
    (synth_script = "osu018_synthesis" =>
	(fprintf fp "cload \"osu018_stdcells.fl\";\n")
    |
	let pre = "let stdcells = [\n\t" then
	let cells = deref synth_stdcell_names then
	let ps fp s = fprintf fp "\"%s\"" s then
	(list2fp fp T  pre ",\n\t" "\n];\n" ps cells) seq
	(fprintf fp "cload \"synth_load_file.fl\";\n")
    ) seq
    (fprintf fp "(update_vossrc \"RECURSION-CALL-LIMIT\" \"100000\") seq ();\n")
    seq
    (fprintf fp "load \"%s.fl\";\n" file) seq
    (fprintf fp "\n\nlet p = rename_stdcells (unfold_pexlif (wrap_pexlif ") fseq
    (fprintf fp "(Q%s [(\"instance\", \"%s\")]" bname bname) fseq
    let pr1 fp (f,as) = list2fp fp T (sprintf "(\"%s\", [" f) ", " "])"
				(\fp.\a. fprintf fp "\"%s\"" a) as
    in
    (list2fp fp T "\n\t[" ",\n\t" "\n\t])) 1);\n" pr1 io_sub) fseq
    (fprintf fp "\np fseq ();\n") seq
    (fprintf fp "write_pexlif \"%s\" p;\n" pexlif_file) seq
    (fprintf fp "\"===SuCcEsS===\";\n") seq
    (fprintf fp "quit;\n") seq
    (fclose fp) seq
    (file^"_load.fl")
;

let fl_do_synthesis canvas file basename synth_type synth_script =
    let vfsm = w2vfsm canvas then
    let pexlif_file = sprintf "%s/pexlifs/%s.pexlif"
			      (get_idv_db_dir ()) (clean_name basename)
    then
    let p = get_idv_current_pexlif canvas then
    let load_file =
	    do_synthesis file basename pexlif_file p synth_type synth_script
    then
    load_file = "" => ["-", "-"] |
    [pexlif_file, load_file]
;
export_to_tcl fl_do_synthesis;


let fl_run_fl_loader file =
    let cmd = sprintf "fl -noX -unbuf_stdout -F %s" file then
    let cw = make_info_window "Load result" F then
    val (status, _, _) = gui_exec cw "Load result" cmd "" then
    status
;
export_to_tcl fl_run_fl_loader;

let fl_make_template canvas type file basename create =
    let vfsm = w2vfsm canvas then
    let pexlif_file = sprintf "%s/pexlifs/%s.pexlif"
			      (get_idv_db_dir ()) (clean_name basename)
    then
    let p = get_idv_current_pexlif canvas then
    let load_file =
	type = "hfl" =>
	    (create = 0 => () |
		let fp = fopen file "w" then
		(generate_hfl_template fp p basename pexlif_file) fseq
		(fclose fp)
	    ) fseq
	    file
	|
	type = "verilog" =>
	    val (PINST nm attrs lf fa_inps fa_outs ints body) = p in
	    let load_file =
		create_verilog_load_file basename file pexlif_file
	    then
	    (create = 0 => () |
	      let p' = PINST basename attrs lf fa_inps fa_outs [] (P_HIER []) in
	      let fp = fopen file "w" then
	      (pexlif2verilog F fp p') fseq
	      (fclose fp)
	    ) fseq
	    load_file
	|
	eprintf "Unknown template type (%s)" type
    then
    load_file = "" => ["-", "-"] |
    [pexlif_file, load_file]
;
export_to_tcl fl_make_template;


let fl_bdd_var_order {canvas::string} {file::string} =
    let vfsm = w2vfsm canvas then
    let p = get_idv_current_pexlif canvas then
    let ofile =
	let name = last (str_split (clean_name file) "/") in
	let base =
	    NOT (str_is_suffix ".pexlif" name) => name |
	    substr name 1 (strlen name - 7)
	in
	sprintf "%s/code/%s.order" (get_idv_db_dir ()) base
    then
    let fp = fopen ofile "w" then
    val (PINST name attrs lf fa_inps fa_outs ints body) = p in
    let name' = clean_name name then
    let inps = map fst fa_inps in
    (fprintf fp "\nlet ordering_%s \n" name') fseq
    let rcnt = ref 1 in
    let emit_inp v =
	let idx = deref rcnt then
	(rcnt := idx+1) fseq
	(fprintf fp "    i%d	// %s\n" idx v)
    in
    (foreach emit_inp inps) fseq
    (fprintf fp
	" = (\n\n   [] // Your code (e.g., interleave [i1,i2,i3])\n\n);\n\n"
    ) fseq
    (fprintf fp "var_order (ordering_%s \n" name') fseq
    let emit_tv v = (fprintf fp "\n\t\t(md_expand_vector \"%s\")" v) in
    (foreach emit_tv (inps)) fseq
    (fprintf fp "\n);\n") fseq
    (fprintf fp "\"===SuCcEsS===\";\n") fseq
    (fprintf fp "ARGS = [\"DONT_QUIT\"] => () | quit;\n") fseq
    let full_file_name = stream2filename fp then
    (fclose fp) fseq
    full_file_name
;
export_to_tcl fl_bdd_var_order;


// Function to compute a unique parametric representation
let unique_param pvec =
    let base_unique_param pvec =
	// Make all variables current and extract the parametric vars
	let c_pvec = bdd_next2current pvec then
	let pvars = depends c_pvec then
	// Now recursively make the pvec canonical
	letrec clean i (v:vs) cond =
	    let nv = bdd_current2next (variable ("$"^(int2str i))) then
	    let H = Quant_thereis pvars (cond AND v) then
	    let L = Quant_thereis pvars (cond AND NOT v) then
	    let bit = nv => H | NOT L then
	    let cond' = cond AND (bit = v) then
	    // Try to simplify cond' if no further dependencies are needed
	    let pv =
		(pvars intersect (depends [cond'])) subtract (depends vs)
	    then
	    let cond'' = Quant_thereis pv cond' then
	    bit:(clean (i+1) vs cond'')
	 /\    clean i [] cond = [] in
	clean 1 c_pvec T
    in
    let ipvec = map_index (\i.\r. i,r) pvec then
    let ps = partition snd ipvec then
    let u_pvec = map (\l. snd (hd l)) ps then
    let u_res = base_unique_param u_pvec then
    let expand (l,res) = map (\(i,_). i, res) l in
    let result = flatmap expand (zip ps u_res) then
    let pcmp (i1,_) (i2,_) = i1-i2 in
    map snd (qsort pcmp result)
;

let mk_HLs_unique HLs =
    let p2l (H,L) = [H,L] in
    let l = flatmap p2l HLs then
    let l' = unique_param l then
    let l2p [H,L] = (H,L) in
    map l2p (cluster 2 l')
;

let check_eq ckt ant cons assumes asserts trl =
    let old_pref = update_vossrc "NOTIFY-CHECK-FAILURES" "NO" then
    let ste =
	NOT noX => STE "" ckt [] ant cons trl |
	let old = update_vossrc "PRINT-TIME" "NO" then
	let res = STE "-s" ckt [] ant cons trl then
	(update_vossrc "PRINT-TIME" old) fseq
	res
    then
    (update_vossrc "NOTIFY-CHECK-FAILURES" old_pref) fseq
    let base_ok = get_ste_result ste "" then
    let a_c =
	itlist (\a.\r. r AND ((get_trace_val ste a 0) = (T,F))) assumes T
    then
    let c_c = 
	itlist (\a.\r. r AND ((get_trace_val ste a 0) = (T,F))) asserts T
    then
    let ok = NOT a_c OR (c_c AND base_ok) then
    ok == T => T,[] |
    let vars = depends ant in
    let cex = full_example F vars (NOT ok) then 
    (ok,cex)
;

let BDD_EQ_base p1 p2 =
    val (miter_pexlif, ant) = mk_miter p1 p2 then 
    let cons = [(T,"_OK_",T,0,1)] in
    let ckt = pexlif2fsm miter_pexlif then
    val (assumes,asserts) = split (str_is_prefix "i1/") (assertions ckt) then
    let phdels = setify (filter (is_phase_delay ckt) (nodes ckt)) then
    let trl = map (\n. n,0,2) (assumes@asserts@phdels) then
    phdels = [] =>
	//
	// Combinational circuits
	//
	val (ok,cex) = check_eq ckt ant cons assumes asserts trl then
	ok == T => (T,NONE) |
	let cex_ant = substitute cex ant then
	(ok, SOME (ckt, asserts, cex_ant))
    |
    //
    // Sequential circuit.
    //
    // Perform reachability analysis for phase delays
    let init_state = map (\n.(T,T)) phdels then
    let state_sequence = ref [init_state] in
    let next_state_fns = ref [] in
    letrec reach idx HLs =
	(fprintf stdinfo "Sequential BDD_EQ Iteration %d\n" idx) fseq
	let mk_ant nd (H,L) = ((H = NOT L), nd, H, -1, 0) in
	let ph_ant = map2 mk_ant phdels HLs then
	let full_ant = ant @ ph_ant in
        let ste = STE "" ckt [] full_ant [] trl then
	let newHLs = map (\nd. get_trace_val ste nd 1) phdels then
	(next_state_fns := (newHLs : (deref next_state_fns))) fseq
	let HLs' = mk_HLs_unique ((variable "__1") => HLs | newHLs) then
	(state_sequence := (HLs' : (deref state_sequence))) fseq
	(HLs' == HLs) => ph_ant | reach (idx+1) HLs'
    in
    let ph_ant = reach 1 (map (\n.(T,T)) phdels) then
    let total_ant = ant @ ph_ant then
    // First try for every state (including partial X states).
    val (ok, cex) = check_eq ckt total_ant cons assumes asserts trl then
    ok == T => (T, NONE) |
    // Try the same verificataion but assuming binary inputs & state
    let bcond = itlist (\ft.\r. (fst ft) AND r) ph_ant T then
    let bsub = param bcond then
    let total_ant' = substitute bsub total_ant then
    val (ok, cex) = check_eq ckt total_ant' cons assumes asserts trl then
    ok == T => (T, NONE) |
    // Failed. Now build the shortest sequence that shows the failure
    let cex_state = substitute cex (hd (deref state_sequence)) then
    letrec find_last_possible cnt (HL:rem) =
	(HL = cex_state) == F => cnt | find_last_possible (cnt+1) rem
    /\     find_last_possible cnt _ = cnt
    in
    let start = (find_last_possible 0 (deref state_sequence))-1 then
    let rel_next_funs = butfirstn start (deref next_state_fns) then
    let rel_states = butfirstn start (deref state_sequence) then
    let cex_state = substitute cex (hd rel_states) then
    let avars = depends ant in
    letrec mk_cex t (nfn:nfns) (st:sts) cur =
	let cond = (cur = nfn) then
	let vars = (depends cond) union avars in
	let cex = full_example F vars cond then
	let new_state = substitute cex st then
	let delay (w,n,v,_,_) = (w,n,v,t-1,t) in
	let ant' = map delay (substitute cex ant) then
	(ant')@(mk_cex (t-1) nfns sts new_state)
     /\   mk_cex t [] _ cur = []
    in
    let etime = length rel_states in
    let cex_ant =
	(substitute cex (map (\(w,n,v,_,_). w,n,v,etime,etime+1) ant)) @
	mk_cex etime rel_next_funs rel_states cex_state
    then
    ok, SOME (ckt, asserts, cex_ant)
;


let BDD_remote_types =
    let tp =
	"(bool#{fsm#(string list)#((bool#string#bool#int#int) list)} opt)"
    in
    (sprintf "lettype remote_bdd_req = REMOTE_BDD_REQ {fun:: void->%s};\n" tp)^
    (sprintf "lettype remote_bdd_result = REMOTE_BDD_REPLY {res_cex::%s};\n" tp)
;
(eval BDD_remote_types) fseq ();

let use_separate_process_evaluation_r = ref T;

slet BDD_EQ_1 p1 p2 order_file =
    NOT (deref use_separate_process_evaluation_r) =>
	noX => fst (BDD_EQ_base p1 p2) |
	val (res, opt_cex) = BDD_EQ_base p1 p2 then
	res == T => res |
	val (ckt, asserts, cex_ant) = get_value opt_cex then
	let cw = make_info_window "CEX" F then
	let sel = window_choose_alternative cw
			"Verification failed."
			"Do you want to simulate a counterexample?"
			[("Yes", "Yes"), ("No","No")]
	then
	sel = "No" => res |
	let vis = STE_debug ckt then
	let tab_1 = draw_fanin vis (0) 100 ("_OK_":asserts) then
	tab_1 fseq
	let ste = STE "-e" vis [] cex_ant [] [] then
	res
    |
    let dir = mktempd "extern_eval" then
    let fl_f = sprintf "%s/run.fl" dir then
    let req_f = sprintf "%s/req" dir then
    let res_f = sprintf "%s/res" dir then
    let task = REMOTE_BDD_REQ (\v. BDD_EQ_base p1 (v fseq p2)) then
    (write_remote_bdd_req req_f task) fseq
    let fp = fopen fl_f "w" then
    (fprintf fp "(update_vossrc \"RECURSION-CALL-LIMIT\" \"%s\") seq ();\n"
		(get_vossrc "RECURSION-CALL-LIMIT")) fseq
    (((order_file = "") OR (order_file = "{}")) => () |
		fprintf fp "load \"%s\";\n" order_file 
    ) fseq
    (fprintf fp "%s\n" BDD_remote_types) fseq
    (fprintf fp "val (REMOTE_BDD_REQ f) = read_remote_bdd_req \"%s\";\n" req_f)
    fseq
    (fprintf fp "let res = f ();\nres fseq ();\n") fseq
    (fprintf fp "write_remote_bdd_result \"%s\" (REMOTE_BDD_REPLY res);\n"
		res_f) fseq
    (fprintf fp "quit;\n") fseq
    (fclose fp) fseq
    (noX =>
	let cmd = sprintf "fl -noX -use_stdout -F %s DONT_QUIT" fl_f then
	(system cmd)
    |
	let wid = make_info_window "FEV" T then
	let cmd = sprintf "fl -use %s -use_stdout -F %s DONT_QUIT" wid fl_f then
	(system cmd)
    ) fseq
    NOT (file_exists res_f) => F |
    val (REMOTE_BDD_REPLY (res,opt_cex)) = read_remote_bdd_result res_f then
    res == T OR noX => res |
    val (ckt, asserts, cex_ant) = get_value opt_cex then
    let cw = make_info_window "CEX" F then
    let sel = window_choose_alternative cw
		    "Verification failed."
		    "Do you want to simulate a counterexample?"
		    [("Yes", "Yes"), ("No","No")]
    then
    sel = "No" => res |
    let vis = STE_debug ckt then
    let tab_1 = draw_fanin vis (0) 100 ("_OK_":asserts) then
    tab_1 fseq
    let ste = STE "-e" vis [] cex_ant [] [] then
    res
;

let BDD_EQ_2 p1 p2 variable_order =
    let fp = mktemp "var_order" then
    let order_file = stream2filename fp then
    (fprintf fp "var_order ") fseq
    let pfn fp s = fprintf fp "\"%s\"" s in
    (list2fp fp T "[\n\t" ",\n\t" "\n];\n" pfn variable_order) fseq
    (fclose fp) fseq
    BDD_EQ_1 p1 p2 order_file
;

overload BDD_EQ BDD_EQ_1 BDD_EQ_2;

let IDV_BDD_EQ name spec imp ordering =
    let ok = BDD_EQ spec imp ordering then
    NOT (ok == T) => error "Not a valid transformation" |
    let just = FEV "BDD" [("ordering", (sprintf "%S" ordering))] then
    TRANSFORM name (idv_save_pexlif spec) (idv_save_pexlif imp) [just]
;

// Try to verify two combinational pexlifs are equal by building
// a miter circuit and simulating the circuit.
let SAT_comb_EQ p1 p2 =
    val (miter_pexlif, ant) = mk_miter p1 p2 then
    let bant = map (\(w,n,v,f,t).bT,n,bdd2bexpr v,f,t) ant in
    let bcons = [(bT,"_OK_",bT,0,1)] in
    let ckt = pexlif2fsm miter_pexlif then
    let ste = bSTE "-s" ckt [] bant bcons [] then
    let ok = bget_ste_result ste "" then
    ok == bT => bT |
    let bcex = bget_model [bNOT ok] 10 then
    bcex = [] => bT |
    let cex = bexpr2bdd bcex then
    let ant' = substitute cex ant then
    let vis = STE_debug ckt then
    let tab_1 = draw_fanin vis (0) 100 ["_OK_"] then
    tab_1 fseq
    (STE "-e" vis [] ant' (bexpr2bdd bcons) []) fseq
    ok
;

let IDV_SAT_comb_EQ name spec imp =
    let ok = SAT_comb_EQ spec imp then
    NOT (ok == bT) => error "Not a valid transformation" |
    let just = FEV "SAT" [] in
    TRANSFORM name (idv_save_pexlif spec) (idv_save_pexlif imp) [just]
;
    

let make_symb_random vars vec_size =
    letrec build (v:vs) =
        (variable v) => (build vs) | (build vs)
     /\    build [] = int2bv (random2 vec_size)
    in
    build vars
;

// Try to verify two combinational pexlifs are equal by building
// a miter circuit and simulating the circuit.
let Sim_comb_EQ effort p1 p2 =
    val (miter_pexlif, ant) = mk_miter p1 p2 then
    let choice_vars = md_expand_vector (sprintf "ch[%d:0]" (effort-1)) in
    let vs = depends ant in
    let sz = length vs in
    let rand_vec = fixed_bv2list (sz+1) T (make_symb_random choice_vars sz) then
    let sub = zip vs (tl rand_vec) then
    let ant = substitute sub ant then
    let cons = [(T,"_OK_",T,0,1)] in
    let ckt = pexlif2fsm miter_pexlif then
    val (assumes,asserts) = split (str_is_prefix "i1/") (assertions ckt) then
    let trl = map (\n. n,0,1) (assumes@asserts) then
    let old_pref = update_vossrc "NOTIFY-CHECK-FAILURES" "NO" then
    let ste = STE "-s" ckt [] ant cons trl then
    (update_vossrc "NOTIFY-CHECK-FAILURES" old_pref) fseq
    let base_ok = get_ste_result ste "" then
    let a_c =
	itlist (\a.\r. r AND ((get_trace_val ste a 0) = (T,F))) assumes T
    then
    let c_c =
	itlist (\a.\r. r AND ((get_trace_val ste a 0) = (T,F))) asserts T
    then
    let ok = NOT a_c OR (c_c AND base_ok) then
    ok == T => T |
    let vars = depends ant in
    let cex = full_example F vars (NOT ok) then
    let ant' = substitute cex ant then
    let vis = STE_debug ckt then
    let tab_1 = draw_fanin vis (0) 100 ("_OK_":asserts) then
    tab_1 fseq
    (STE "-e" vis [] ant' cons []) fseq
    ok
;



let fl_do_verify canvas {file::string} {type::string} {ordering_file::string} =
    (
	let vfsm = w2vfsm canvas then
	let spec = get_idv_current_pexlif canvas then
	let imp = read_pexlif file then
	let ok = type = "BDD"	     => ((BDD_EQ spec imp ordering_file) == T) |
		 type = "SAT"	     => ((SAT_comb_EQ spec imp) == bT) |
		 type = "Sim_None"   => T |
		 type = "Sim_Light"  => ((Sim_comb_EQ 5 spec imp) == T) |
		 type = "Sim_Medium" => ((Sim_comb_EQ 8 spec imp) == T) |
		 type = "Sim_Heavy"  => ((Sim_comb_EQ 12 spec imp) == T) |
		 eprintf "Unknown engine (%s)" type
	then
	NOT ok => (type = "BDD" => "already_dealt_with_cex" | "cex") |
	let just = FEV type [] in
	(add_transform canvas imp just) fseq
	let signature = pexlif_get_FP spec then
	let transform_name = find_next_anon_transform_name signature "FEV" then
	let imp_sha  = idv_save_pexlif imp then
	let spec_sha = idv_save_pexlif spec then
	let tr = TRANSFORM transform_name spec_sha imp_sha [just] then
	(record_transformation signature tr) fseq
	let cmd = sprintf "flatten vis;" in
	(refresh_idv_canvas canvas cmd) fseq
	"ok"
    ) gen_catch (\msg. msg)
;
export_to_tcl fl_do_verify;

let compress_formals fas =
    let sub = 
	let mk1 (f, as) = zip (md_expand_vector f) (md_expand_vectors as) in
	flatmap mk1 fas
    then
    let fs = merge_vectors (map fst fas) in
    let mk f =
	let fs = md_expand_vector f in
	let as = map (\f. assoc f sub) fs then
	f, (merge_vectors as)
    in
    map mk fs
;
    

letrec rename_pexlif_wires
	    sub
	    (PINST name attrs lf fa_inps fa_outs ints (P_HIER children))
    = 
    let in_use = md_expand_vectors ((map fst (fa_inps @ fa_outs))@ints) in
    let from = map fst sub then
    let to   = map snd sub then
    (length to != length (setify to)) => eprintf "Duplicate new names" |
    ((in_use subtract from) intersect to) != [] =>
	eprintf "Name clash(es) in renaming wires (%S)"
		((in_use subtract from) intersect to)
    |
    let trf (f,as) =
	let fnds = md_expand_vector f then
	let fnds' = map (\f. (assoc f sub) catch f) fnds then
	let f' = md_merge_vectors fnds' then
	length f' = 1 => [((hd f'),as)] |
	letrec mk (f:fs) as =
	    let len = md_size f in
	    let p_as = firstn len as in
	    (f,md_merge_vectors p_as):
	    (mk fs (butfirstn len as))
	 /\    mk [] as = 
	    as != [] => error "WHAT? Should not be possible" |
	    []
	in
	mk f' (md_expand_vectors as)
    in
    let fa_inps' = compress_formals (flatmap trf fa_inps) in
    let fa_outs' = compress_formals (flatmap trf fa_outs) in
    let ints' = md_extract_vectors (map (\n.(assoc n sub) catch n)
					(md_expand_vectors ints))
    then
    let tra (f,as) =
	let as' = md_merge_vectors (map (\n.(assoc n sub) catch n)
					(md_expand_vectors as))
	then
	(f,as')
    in
    let mk_sub (f,as) =
	let fs = md_expand_vector f then
	let as = md_expand_vectors as then
	let tr f a =
	    (
		let new = assoc a sub then
		[(f,new)]
	    ) catch []
	in
	flat (map2 tr fs as)
    in
    let process_child (PINST cn ca cl cfa_inps cfa_outs cints cbody) =
	let cfa_inps' = map tra cfa_inps then
	let cfa_outs' = map tra cfa_outs then
	let cp = PINST cn ca cl cfa_inps' cfa_outs' cints cbody then
	let sub' = flatmap mk_sub (cfa_inps@cfa_outs) then
	(rename_pexlif_wires sub' cp) catch cp
    in
    let children' = map process_child children then
    PINST name attrs lf fa_inps' fa_outs' ints' (P_HIER children')
 /\    rename_pexlif_wires sub other = other
;


let fl_rename_wires canvas =
  (
    let vfsm = w2vfsm canvas in
    let p = get_idv_current_pexlif canvas then
    let selected_wires = get_selected_wires vfsm then
    let mlen = itlist (\s.\m. max m (strlen s)) selected_wires 0 then
    let fp = mktemp "rename_wires" then
    let filename = stream2filename fp then
    (foreach (fprintf fp "%-*s -> \n" mlen) selected_wires) fseq
    (fclose fp) fseq
    letrec try dummy =
	let pid = tcl_eval [sprintf "exec %s &" (EDIT_cmd filename)] then
	(tcl_eval ["set ::done_edit 0",
		   sprintf "util:watch_process %s 50 {set ::done_edit 1}"
			    pid]) fseq
	(tcl_eval ["tkwait variable ::done_edit"]) fseq
	let fp = fopen filename "r" then
	letrec read fp =
	    let line = fgets fp then
	    line = "" => [] |
	    (string_butlast line):(read fp)
	in
	let lines = read fp then
	let mk_sub i l =
	    let sl = str_split l "->" then
	    length sl != 2 =>
		let msg = sprintf "Syntax error around line %d\n``%s''\n" i l in
		(report_error msg) fseq
		error "FAIL"
	    |
	    val [raw_old,raw_new] = sl then
	    let old = trim raw_old then
	    let new = trim raw_new then
	    (old,new)
	in
	let sub = (map2 mk_sub (1 upto (length lines)) lines) catch [] in
	sub == [] => (try ()) |
	(sub,(rename_pexlif_wires sub p)) gen_catch
	(\msg. (report_error msg) fseq (try ()))
    in
    val (sub, p') = try () then
    (add_transform canvas p' (RENAME_WIRES sub)) fseq
    let cmd = sprintf "rename_wires vis ...;"  in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_rename_wires;


lettype draw_tree =
	    DT_BR {pfn :: string} {children :: draw_tree list}
	  | DT_CONST
	  | DT_INP
	  | DT_CYCLE
;

let Pdraw_tree dt =
    letrec pr indent (DT_BR pfn chs) =
	let pre  = sprintf "%*s(%s [\n" indent " " pfn in
	let post = sprintf "%*s])\n" indent " " in
	list2str T pre "" post (pr (indent+4)) chs
     /\    pr indent DT_CONST = sprintf "%*sDT_CONST\n" indent " "
     /\    pr indent DT_INP = sprintf "%*sDT_INP\n" indent " "
     /\    pr indent DT_CYCLE = sprintf "%*sDT_CYCLE\n" indent " "
    in
    "\n"^(pr 0 dt)
;
install_print_function Pdraw_tree;    

let remove_add_inst pfn =
    let clean_draw_fub pfn =
	NOT (str_is_substr "draw_fub " pfn) => pfn |
	list2str T "" " " "" id (firstn 2 (str_split pfn " "))
    in
    NOT (str_is_prefix "add_inst " pfn) => clean_draw_fub pfn |
    letrec skip_digit (c:cs) = 
	let oc = ord c in
	(ord "0" <= oc) AND (oc <= ord "9") => skip_digit cs | implode cs
     /\    skip_digit [] = eprintf "remove_add_inst failed on %s" pfn
    in
    clean_draw_fub (skip_digit (butfirstn (strlen "add_inst ") (explode pfn)))
;

let build_vfanin_tbl ckt =
    let vec_vis_fanin vecs =
        let nds = md_expand_vectors vecs in
        let get_pfn nd = (get_visualization_id ckt nd (-1)),
                         (remove_add_inst (get_visualization_pfn ckt nd (-1))),
                         nd
        in
        let p = partition fst (map get_pfn nds) then
        let process l =
            val ((id,pfn,nd):rem) = l in
            let vec = md_extract_vectors (map (\(id,pfn,nd).nd) l) in
            let fi = get_visualization_fanins ckt nd (-1) in
            let vfi = md_merge_vectors (flatmap snd fi) then
            map (\v. (v, pfn, vfi)) vec
        in
        flatmap process p
    in
    let res = vec_vis_fanin (visualization_nodes ckt (-1)) then
    list2tbl res
;

let get_io_order p =
    let MAX_DEPTH = 100 in
    let ckt = accurate_pexlif2fsm p then
    let vfi_tbl = build_vfanin_tbl ckt then
    let vinps = inputs ckt in
    let inps = md_expand_vectors vinps in
    let res = ref [] then
    letrec tr seen path vec =
        mem vec vinps => ((res := ((vec,rev path):(deref res))) seq DT_INP) |
        mem vec seen => DT_CYCLE |
        val (pfn,vfanins) = tbl_get vfi_tbl vec then
        (vfanins = []) AND (str_is_substr "draw_input" pfn) => DT_CONST |
        let id_vfanins = zip (1 upto length vfanins) vfanins in
        let do (i,vfi) = tr (vec:seen) ((int2str i):pfn:path) vfi in
        DT_BR pfn (map do id_vfanins)
    in
    let do_out vo = vo, (tr [] [vo] vo) in
    let omaps = map do_out (outputs ckt) then
    let do l = (fst (hd l)), (setify (map snd l)) in
    let inps = map do (partition fst (deref res)) then
    let sel l =
        let vs = md_extract_vectors (map fst l) then
        let sig = snd (hd l) in
        map (\v. v, sig) vs
    in
    omaps, (flatmap sel (partition snd inps))
;


let get_input_order p =
    let MAX_DEPTH = 100 in
    let ckt = accurate_toplevel_pexlif2fsm (flatten_pexlif p) then
    let vinps = inputs ckt in
    let inps = md_expand_vectors vinps in
    let res = ref [] then
    letrec tr depth path nd =
	mem nd inps => (res := ((nd,path):(deref res))) |
	depth > MAX_DEPTH => () |
	let pfn = get_visualization_pfn ckt nd 0 in
	let vfanins = get_visualization_fanins ckt nd 0 in
	let id_vfanins = zip (1 upto length vfanins) vfanins in
	let do (i,(vfi,nds)) =
	    let do1 fi = tr (depth+1) ((int2str i):pfn:path) fi in
	    foreach do1 nds
	in
	foreach do id_vfanins
    in
    let id_vouts =
	let vouts = outputs ckt in
	zip (1 upto length vouts) vouts
    in
    let do (i,vo) =
	let do1 o = tr 1 [(sprintf "o%d" i)] o in
	foreach do1 (md_expand_vector vo)
    in
    (foreach do id_vouts) fseq
    let do l = (fst (hd l)), (setify (map snd l)) in
    let inps = map do (partition fst (deref res)) then
    let sel l =
	let vs = md_extract_vectors (map fst l) then
	let sig = snd (hd l) in
	map (\v. v, sig) vs
    in
    flatmap sel (partition snd inps)
;

let check_eq_by_sim p1 p2 =
    let ckt1 = pexlif2fsm (wrap_pexlif p1) then
    let ckt2 = pexlif2fsm (wrap_pexlif p2) then
    let inps1 = md_expand_vectors (inputs ckt1) in
    let inps2 = md_expand_vectors (inputs ckt2) in
    let outs1 = md_expand_vectors (outputs ckt1) in
    let outs2 = md_expand_vectors (outputs ckt2) in
    (set_neq inps1 inps2) => F |
    (set_neq outs1 outs2) => F |
    let ant = map (\n.bT,n, bvariable n, 0, 1) inps1 then
    let trl = map (\n.n,0,1) outs1 then
    let ste1 = bSTE "-s" ckt1 [] ant [] trl then
    let ste2 = bSTE "-s" ckt2 [] ant [] trl then
    let tst n r = 
	r AND ((bget_trace_val ste1 n 0) == (bget_trace_val ste2 n 0))
    in
    itlist tst outs1 T
;

let pexlif_ifc_substitute sub p =
    val (PINST nm attrs lf fa_inps fa_outs ints body) = p then
    let sub_fa (f,as) =
	let as' = map (\n. (assoc n sub) catch n) (md_expand_vectors as) then
	(f, md_merge_vectors as')
    in
    let fa_inps' = map sub_fa fa_inps then
    let fa_outs' = map sub_fa fa_outs then
    (PINST nm attrs lf fa_inps' fa_outs' ints body)
;

// Try by simply swapping actuals.
let simple_get_specialized_imp spec imp p =
    val (PINST nm_s attr_s lf_s in_s out_s int_s sckt_s) = spec in
    val (PINST nm_p attr_p lf_p in_p out_p int_p sckt_p) = p in
    length in_s != length in_p => NONE |
    length out_s != length out_p => NONE |
    let fa2 = (zip in_s in_p)@(zip out_s out_p) in
    let ok =
	itlist (\((f1,_),(f2,_)).\r. r AND (md_size f1 = md_size f2)) fa2 T
    then
    NOT ok => NONE |
    // Try assuming order is correct
    let sub =
	let exp ((_,a1),(_,a2)) =
	    zip (md_expand_vectors a1) (md_expand_vectors a2)
	in
	flatmap exp fa2
    then
    let spec' = pexlif_ifc_substitute sub spec then
    let ok = check_eq_by_sim p spec' then
    NOT ok => NONE |
    let imp' = pexlif_ifc_substitute sub imp then
    SOME imp'
;

let lcmp l1 l2 =
    let len1 = length l1 in
    let len2 = length l2 in
    len1 > len2 => 1 |
    len1 < len2 => -1 |
    letrec cmp (st1:st1s) (st2:st2s) =
	let res = strcmp st1 st2 in
	res > 0 => res |	
	res < 0 => res |
	cmp st1s st2s
     /\    cmp [] [] = 0
    in
    cmp l1 l2
;

// Find a substitution that makes spec == p.
// If such is found, return imp after applying the same substitution.
let get_specialized_imp spec imp p =
    let ores = simple_get_specialized_imp spec imp p then
    has_value ores => ores |
    val (PINST nm1 attr1 lf1 in1 out1 int1 sckt1) = spec in
    val (PINST nm2 attr2 lf2 in2 out2 int2 sckt2) = p in
    length out1 != length out2 => NONE |
    let spec' = spec in
    let p'    = p in
    val (oorder1, iorder1) = get_io_order spec' then
    val (oorder2, iorder2) = get_io_order p' then
    let ovsub = (map (\(sv,st). sv, (rev_assoc st oorder2)) oorder1) catch [] in
    ovsub = [] => NONE |
    let osub =
	flatmap (\(sv,pv).zip (md_expand_vector sv) (md_expand_vector pv)) ovsub
    then
    let iorder1' = 
	let tr (vinp, paths) =
	    let rename_termination path = (assoc (hd path) ovsub):(tl path) in
	    (vinp, (qsort lcmp (map rename_termination paths)))
	in
	map tr iorder1
    then
    let iorder2' =
	let tr (vinp, paths) = (vinp, (qsort lcmp paths)) in
	map tr iorder2
    then
    let get_info (v,sig) = (md_size v,sig) in
    (set_neq (map get_info iorder1') (map get_info iorder2')) => NONE |
    let mk_sub (spec_v,spec_sig) =
	let p_v = rev_assoc spec_sig iorder2' in
	zip (md_expand_vector spec_v) (md_expand_vector p_v)
    in
    let isub = flatmap mk_sub iorder1' then
    let spec'' = pexlif_ifc_substitute (osub@isub) spec then
    NOT (check_eq_by_sim spec'' p') => NONE |
    let imp' = pexlif_ifc_substitute (osub@isub) imp then
    SOME imp'
;


let do_replace_first parent spec imp =
    val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (cp:cps))) = parent in
    let o_imp' = get_specialized_imp spec imp cp then
    NOT (has_value o_imp') =>
	eprintf "Transformation spec not an exact match in replace\n"
    |
    let new = get_value o_imp' then
    let p' = PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (new:cps)) then
    unfold_pexlif p' 1
;

let replace_all parent spec imp =
    let raw_matches = isomatch spec parent then
    let matches = map (\l. map (\(si,(ii,_)). si,ii) l) raw_matches then
    let groups = map (map snd) matches then
    let nbr_groups = length groups then
    let lbl = "_#*&_&*#_" in
    let parent' = foldn_pexlif_anon parent groups lbl then
    let children' = pexlif_get_children parent' then
    let to_be_replaced = firstn nbr_groups children' then
    let remain = butfirstn nbr_groups children' then
    let repl1 p =
	let imp' = get_specialized_imp spec imp p then
	has_value imp' => pexlif_rename (get_value imp') lbl | p
    in
    let replacements = map repl1 to_be_replaced then
    let children' = replacements @ remain then
    val (PINST n attrs lf fa_inps fa_outs ints (P_HIER children)) = parent' then
    let tmp = PINST n attrs lf fa_inps fa_outs ints (P_HIER children') then
    unfold_all_labeled tmp lbl
;

let do_replace_everywhere repeat parent spec imp =
    NOT repeat => replace_all parent spec imp |
    letrec do_replace cnt p =
	cnt > 1000 =>
	    (fprintf stdinfo "Reached max replace limit. Stopped replacing")
	    fseq
	    p
	|
	let p' = replace_all p spec imp then
	p == p' => p | do_replace (cnt+1) p'
    in
    do_replace 1 parent
;

let fl_do_replacement canvas =
  (
    let vfsm = w2vfsm canvas then
    let w = vfsm2id vfsm then
    let il = get_selected_pinsts canvas then
    let parent = get_idv_current_pexlif canvas then
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif parent il "_TMP_" then
    val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (p:ps))) = p' in
    let signature = pexlif_get_FP p then
    let dbs = (deref cur_idv_rw_transform_db)@
	      (deref cur_idv_readonly_transform_dbs)
    then
    let get_alts db =
	let tbl = db_tbl db then
	NOT (tbl_member tbl signature) => [] |
	map (\t. (db,t)) (tbl_get tbl signature)
    then
    let alts = flatmap get_alts dbs then
    let tr_names = map (\(db,(TRANSFORM name _ _ _)). name) alts then
    let pre = sprintf "idv:select_replacement %s {" canvas in
    let cmd = list2str T pre " " "}" id tr_names then
    val [op, sidx] = tcl2list (tcl_eval [cmd]) then
    op = "Cancel" => () |
    let idx = (sscanf "%d" sidx)+1 then
    val (db,tr) = el idx alts then
    val (TRANSFORM name sha_spec sha_imp just) = tr then
    let spec = idv_load_pexlif (db_sname db) sha_spec then
    let imp  = idv_load_pexlif (db_sname db) sha_imp then
    op = "ApplyOnce" =>
	let p'' = do_replace_first p' spec imp then
	(add_transform canvas p'' (REPLACE il tr)) fseq
	let cmd = sprintf "replace vis %s \"%s\";"
		      (list2str T "[" "," "]" int2str il) name
	in
	(refresh_idv_canvas canvas cmd)
    |
    op = "ApplyEverywhere" =>
	let res = do_replace_everywhere F parent spec imp then
	(add_transform canvas res (REPLACE_ALL F tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str il) name
	in
	(refresh_idv_canvas canvas cmd)
    |
    op = "RepeatApplyEverywhere" =>
	let res = do_replace_everywhere T parent spec imp then
	(add_transform canvas res (REPLACE_ALL T tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str il) name
	in
	(refresh_idv_canvas canvas cmd)
    |
    eprintf "Illegal operation '%s'\n" op
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_replacement;

let IDV_replace_selected il tr tr_sequence =
    let db = get_rw_db () then
    val (TRANSFORM p_name p_sha_spec p_sha_imp p_just) = tr_sequence then
    let p_imp  = idv_load_pexlif (db_sname db) p_sha_imp then
    let p_imp' = fold_pexlif p_imp il "_TMP_" then
    val (TRANSFORM e_name e_sha_spec e_sha_imp e_just) = tr then
    let spec = idv_load_pexlif (db_sname db) e_sha_spec then
    let imp  = idv_load_pexlif (db_sname db) e_sha_imp then
    let p_imp'' = do_replace_first p_imp' spec imp then
    let just = REPLACE il tr then
    TRANSFORM p_name p_sha_spec (idv_save_pexlif p_imp'') (p_just@[just])
;

let IDV_pattern_replace repeat tr tr_sequence =
    let db = get_rw_db () then
    val (TRANSFORM p_name p_sha_spec p_sha_imp p_just) = tr_sequence then
    let p_imp  = idv_load_pexlif (db_sname db) p_sha_imp then
    val (TRANSFORM e_name e_sha_spec e_sha_imp e_just) = tr then
    let spec = idv_load_pexlif (db_sname db) e_sha_spec then
    let imp  = idv_load_pexlif (db_sname db) e_sha_imp then
    let p_imp' = do_replace_everywhere repeat p_imp spec imp then
    let just = REPLACE_ALL repeat tr then
    TRANSFORM p_name p_sha_spec (idv_save_pexlif p_imp') (p_just@[just])
;


// Invoked from fl_remove_active_sch_tab_window in draw_sch.fl
let idv_finish_transformation canvas =
    val (parent,inside, sell) = get_idv_parent_info canvas then
    let vfsm = w2vfsm canvas in
    let trfs = get_idv_info canvas then
    let just = map (\(p,ckt,j).j) (butlast trfs) then
    just = [] => T |
    let imp = fst (hd trfs) in
    let spec = fst (last trfs) in
    let spec_sig = pexlif_get_FP spec then
    let tr_name = find_next_anon_transform_name spec_sig "trfs" then
    let model_name = find_next_anon_name () then
    let cmd = sprintf "idv:name_transform_and_use %s %s %s %s"
		       (inside => "1" | "0") canvas tr_name model_name
    then
    let resl = tcl2list (tcl_eval [cmd]) then
    let op = el 1 resl in
    let transform_name = el 2 resl in
    let model_name = el 3 resl in
    op = "Cancel" => F |
    op = "Discard" => T |
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    // Name the implementation pexlif
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    (add_model_in_rw_db F model_name imp_sha) fseq
    // Now save the transformation
    let tr = TRANSFORM transform_name spec_sha imp_sha just then
    (record_transformation spec_sig tr) fseq
    op = "Save" => T |
    op = "SaveAndApplyOnce" =>
	inside =>
	    let pp = get_idv_current_pexlif parent then
	    val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (cs))) = pp in
	    length sell != 1 =>
		error "FATAL: inside does not have single selection (%d)"
		      (length sell)
	    |
	    let sel = hd sell then
	    let cs' = (firstn (sel-1) cs)@[imp]@(butfirstn sel cs) then
	    let p' = PINST nm attrs leaf fa_inps fa_outs ints (P_HIER cs') then
	    (add_transform parent p' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	    in
	    (refresh_idv_canvas parent cmd) fseq T
	|
	let pp = get_idv_current_pexlif parent then
	let pp' = fold_pexlif pp sell "_TMP_" then
	val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (c:cs))) = pp' in
	c == spec =>
	(
	    let p' = PINST nm attrs leaf fa_inps fa_outs ints
			    (P_HIER (imp:cs))
	    then
	    let p'' = unfold_pexlif p' 1 then
	    (add_transform parent p'' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	    in
	    (refresh_idv_canvas parent cmd) fseq T
	)
	|
	eprintf "Parent circuit has changed. Cannot apply the transformation"
    |
    op = "SaveAndApplyEverywhere" =>
	let pp = get_idv_current_pexlif parent then
	let matches = isomatch spec pp then
	let groups = map (map (fst # snd)) matches then
	let nbr_groups = length groups then
	let lbl = "_#*&_&*#_" in
	let pp' = foldn_pexlif_anon pp groups lbl then
	let imps =
	    letrec do_sub (cp:cps) (m:ms) =
		let matches = map (snd # snd) m then
		let subs = map get_match_sub  matches then
		let opt_cp_sub = actualize_hier subs imp cp then
		let cp' =
		    has_value opt_cp_sub =>
			let cp_sub = get_value opt_cp_sub then
			rename_name (pex_subst_actuals imp cp_sub) lbl
		    |
			rename_name cp lbl
		then
		cp' : (do_sub cps ms)
	     /\   do_sub [] [] = []
	    in
	    do_sub (firstn nbr_groups (pexlif_get_children pp')) matches
	then
	val (PINST n attrs lf fa_inps fa_outs ints (P_HIER children)) = pp' then
	let children' = imps@(butfirstn nbr_groups children) then
	let tmp = PINST n attrs lf fa_inps fa_outs ints (P_HIER children') then
	let res = unfold_all_labeled tmp lbl then
	(add_transform parent res (REPLACE sell tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	in
	(refresh_idv_canvas parent cmd) fseq T
    |
    eprintf "Illegal operation '%s'\n" op
;

let make_theorem transform_name spec imp =
    spec fseq imp fseq
    let signature = pexlif_get_FP spec then
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    let tr = TRANSFORM transform_name spec_sha imp_sha [MK_THM] then
    (record_transformation signature tr)
;

;

let fl_save_verilog canvas name file only_netlist =
  (
    let vfsm = w2vfsm canvas in
    let p = get_idv_current_pexlif canvas then
    let netlist = only_netlist = "1" then
    let p' = netlist => p | make_anon_names name p then
    let fp = fopen file "w" then
    (pexlif2verilog netlist fp p') fseq
    (fclose fp)
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_save_verilog;

let fl_save_pexlif canvas file =
    let p = get_idv_current_pexlif canvas then
    write_pexlif file p
;
export_to_tcl fl_save_pexlif;

let fl_write_pexlif canvas file =
  (
    let p = get_idv_current_pexlif canvas then
    Emit_ASCII_pexlif file p
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_write_pexlif;

let has_phase_delay_inside p =
    letrec check (PINST _ _ _ _ _ _ (P_HIER chs)) =
	let idx = find_first0 check chs in
	idx != 0
     /\ check (PINST _ _ _ _ _ _ (P_LEAF fns)) =
	let is_phase_del (W_PHASE_DELAY l r) = T
	 /\ is_phase_del other = F
	in
	let idx = find_first0 is_phase_del fns in
	idx != 0
    in
    check p
;

let has_unmapped p =
    letrec check (PINST nm _ _ _ _ _ (P_HIER chs)) =
	str_is_substr "draw_stdcell" nm => F |
	let idx = find_first0 check chs in
	idx != 0
     /\ check (PINST _ _ _ _ _ _ (P_LEAF fns)) = T
    in
    check p
;

let fl_do_selection_command canvas cmd =
  (
    let vfsm = w2vfsm canvas then
    let rselection = vfsm2selection_r vfsm then
    let p = get_idv_current_pexlif canvas then
    val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p then
    let new_selection =
	cmd = "all" =>
	    md_extract_vectors ((map fst (fa_inps @ fa_outs))@ints)
	|
	cmd = "combinational" => 
	    val (seqs, comb) = split has_phase_delay_inside chs in
	    md_extract_vectors (flatmap pexlif_get_outs_actuals comb)
	|
	cmd = "stateholding" => 
	    val (seqs, comb) = split has_phase_delay_inside chs in
	    md_extract_vectors (flatmap pexlif_get_outs_actuals seqs)
	|
	cmd = "mapped" =>
	    val (unmapped,mapped) = split has_unmapped chs in
	    md_extract_vectors (flatmap pexlif_get_outs_actuals mapped)
	|
	cmd = "unmapped" =>
	    val (unmapped,mapped) = split has_unmapped chs in
	    md_extract_vectors (flatmap pexlif_get_outs_actuals unmapped)
	|
	cmd = "private_fanin" =>
	    let io = buid_io_tbl p then
	    let current_wires = deref rselection then
	    let current_insts = wires2drivers io current_wires then
	    let new_insts = inst_fanin_dfs io T 100 (\n.F) current_insts then
	    md_extract_vectors (insts2wires io new_insts)
	|
	cmd = "invert" =>
	    let all = md_expand_vectors ((map fst (fa_inps @ fa_outs))@ints) in
	    let cur = md_expand_vectors (deref rselection) in
	    md_extract_vectors (all subtract cur)
	|
	eprintf "Unknown selection command (%s)\n" cmd
    then
    set_selection canvas "SET_SELECTION" new_selection
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_selection_command;

letrec has_state (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) =
    (find_first0 has_state cs) != 0
 /\ has_state (PINST name attrs lf fa_inps fa_outs ints (P_LEAF fs)) =
    let is_state (W_PHASE_DELAY lhs rhs) = T
     /\ is_state _ = F
    in
    (find_first0 is_state fs) != 0
;

let get_type_and_clock NONE = "",""
 /\ get_type_and_clock (SOME (type,base,p,clk, d, q, other)) = type,clk
;

let replace_signal fa_list f as =
    val (sel,other) = split (\p. fst p = f) fa_list then
    let res = (f,as):other then
    res
;

let do_retime_fwd p ill =
    NOT (pexlif_is_hier p) => error "retime_fwd on a leaf instance" |
    ill = [] => p |
    let p' = fold_pexlif p ill "_TMP_" then
    val (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) = p' in
    // This code relies on fold_pexlif putting the new instance first!!!!
    let idx = 1 in
    let block = el idx cs then
    has_state block =>
	eprintf "Selection contains state in retiming operation"
    |
    let io = buid_io_tbl p' then
    let name_db = build_name_db p' then
    has_output_fanout io idx =>
	eprintf "Selection has a fanout to an output pin"
    |
    let fanouts = inst_fanout io idx then
    let ff_info = map (\i. extract_re_ff (el i cs)) fanouts then
    let tp_clks = setify (map get_type_and_clock ff_info) then
    length tp_clks != 1 =>
	let tps = setify (map fst tp_clks) in
	let clks = setify (map snd tp_clks) in
	length tps != 1 => eprintf "Different types of ffs in fanout" |
	length clks != 1 => eprintf "Different clocks to ffs in fanout" |
	eprintf "What??"
    |
    val [(type,clk)] = tp_clks in
    type = "" => eprintf "Not a flip-flop in fanout" |
    // Do the retiming
    let out_sub =
	let find_io (SOME (tp,base,fp,clk,d,q,other)) = vec_zip d q in
	flatmap find_io ff_info
    then
    let inps  = md_extract_vectors (pexlif_get_inps_actuals block) then
    let inps' = map (get_unique_name name_db) inps then
    let inp_sub = vec_zip inps inps' then
    val (SOME (tp,base,_,clk,d,q,other)) = hd ff_info then
    let new_ffs =
	let mk inp inp' =
	    let sz = md_size inp then
	    let ff = resize_pexlif sz base then
	    val (PINST ffnm ffattrs fflf ffinps ffouts ffints ffbody) = ff then
	    let ffinps' = replace_signal ffinps (mk_name sz "d") [inp]  then
	    let ffouts' = replace_signal ffouts (mk_name sz "q") [inp']  then
	    PINST ffnm ffattrs fflf ffinps' ffouts' ffints ffbody
	in
	map2 mk inps inps'
    then
    let block' = 
	val (PINST bname battrs blf bfa_inps bfa_outs bints bbody) = block in
	let bfa_inps' =
	    let tr (f,as) =
		f, (flatmap (\a. vec_assoc a inp_sub) as)
	    in
	    map tr bfa_inps
	in
	let bfa_outs' =
	    let tr (f,as) =
		f, (flatmap (\a. vec_assoc a out_sub) as)
	    in
	    map tr bfa_outs
	in
	PINST bname battrs blf bfa_inps' bfa_outs' bints bbody
    then
    let unchanged = gather cs ((1 upto length cs) subtract (idx:fanouts)) then
    let cs' = block':(new_ffs@unchanged) then
    let ints' = inps' @ (ints vec_subtract (map fst out_sub)) then
    unfold_pexlif (PINST name attrs lf fa_inps fa_outs ints' (P_HIER cs')) 1
;


let fl_do_retime_fwd canvas =
  (
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let p = get_idv_current_pexlif canvas then
    let p' =  do_retime_fwd p il then
    (add_transform canvas p' (RETIME_FWD il)) fseq
    let cmd =
	sprintf "retime_fwd vis %s;" (list2str T "[" "," "]" int2str il)
    in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_retime_fwd;


let do_wire2buffer wire p =
    NOT (pexlif_is_hier p) => error "wire2buffer on a leaf instance" |
    let sz = md_size wire in
    let io = buid_io_tbl p then
    let name_db = build_name_db p then
    val (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) = p in
    // First fanout to instances
    val (ints', cs') =
	let fanouts = wire2driven io wire then
	let cnt = length fanouts in
	let w_wire = W_EXPLICIT_VAR sz wire in
	let mk_buf out = resize_pexlif sz ((W_EXPLICIT_VAR sz out) <- w_wire) in
	let new_outs = map (get_unique_name name_db) (replicate cnt wire) then
	let buf_pexlifs = map mk_buf new_outs then
	let remain = gather cs ((1 upto length cs) subtract fanouts) then
	let update_inp new idx =
	    let sp = el idx cs in
	    val (PINST sname sattrs slf sfa_inps sfa_outs sints sbody) = sp in
	    let sub = vec_zip [wire] [new] in
	    let rename (f,as) =
		let tr a = (hd (vec_assoc a sub)) catch a in
		f, (map tr as)
	    in
	    let sfa_inps' = map rename sfa_inps then
	    PINST sname sattrs slf sfa_inps' sfa_outs sints sbody
	in
	let modified = map2 update_inp new_outs fanouts then
	let cs' = buf_pexlifs @ modified @ remain then
	let ints' = new_outs@ints then
	(ints', cs')
    in
    // Then fanouts to top-level outputs
    val (fa_outs', new_ints, new_insts) = 
	let outs = wire2outputs io wire then
	outs = [] => (fa_outs, [], []) |
	let new_out = get_unique_name name_db wire then
	let sub = vec_zip [wire] [new_out] then
	let rename (f,as) =
	    let f' = (hd (vec_assoc f sub)) catch f then
	    (f',as)
	in
	let fa_outs' = map rename fa_outs then
	let w_wire = W_EXPLICIT_VAR sz wire in
	let inst = resize_pexlif sz ((W_EXPLICIT_VAR sz new_out) <- w_wire) in
	(fa_outs', [wire], [inst])
    in
    let cs'' = new_insts @ cs' in
    let ints'' = setify (ints' @ new_ints) then
    PINST name attrs lf fa_inps fa_outs' ints'' (P_HIER cs'')
;

let fl_do_wire2buffer canvas =
  (
    let vfsm = w2vfsm canvas in
    let p = get_idv_current_pexlif canvas then
    let selected_wires = md_extract_vectors (get_selected_wires vfsm) then
    selected_wires = [] => () |
    let p' = itlist do_wire2buffer selected_wires p then
    (add_transform canvas p' (WIRE2BUFFER selected_wires)) fseq
    let cmd =
	sprintf "wire2buffer vis %s;"
		(list2str T "[" "," "]" (sprintf "\"%s\"") selected_wires)
    then
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_wire2buffer;


let remove_wire p il =
    il = [] => p |
    NOT (pexlif_is_hier p) => error "remove_wire on a leaf instance" |
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif p il "_TMP_" then
    val (PINST name attrs lf fa_inps fa_outs ints (P_HIER cs)) = p' in
    let top_inps = md_expand_vectors (map fst fa_inps) then
    let block = wrap_pexlif (hd cs) then
    let remain = tl cs then
    has_state block => eprintf "Selection is not all wires" |
    let inps = pexlif_get_inps_actuals block in
    let outs = pexlif_get_outs_actuals block in
    let ckt = pexlif2fsm block then
    let ant = map (\n.T,n,variable n, 0, 1) (setify (md_expand_vectors inps)) in
    let ste = STE "-e" ckt [] ant [] [] then
    let mk_sub o =
	val (H,L) = get_trace_val ste o 0 then
	NOT (H == NOT L) => eprintf "Node %s is not a wire (non binary)" o |
	let dep = depends H in
	length dep != 1 => eprintf "Node %s is not a wire (function)" o |
	let v = hd dep in
	NOT (H == (variable v)) =>
	    eprintf "Node %s is not a wire (inverted)" o
	|
	(o, v)
    in
    let sub = map mk_sub (md_expand_vectors outs) then
    let rename1 (PINST sname sattrs slf sfa_inps sfa_outs sints sbody) =
	let rename_act (f,as) =
	    let eas = map (\a. (assoc a sub) catch a) (md_expand_vectors as) in
	    let as' = md_merge_vectors eas then
	    (f, as')
	in
	let sfa_inps' = map rename_act sfa_inps then
	(PINST sname sattrs slf sfa_inps' sfa_outs sints sbody)
    in
    let remain' = ref (map rename1 remain) then
    let fa_outs' =
	let rename_formal (f,as) =
	    let fs = md_expand_vector f in
	    let fs' = map (\f. (assoc f sub) catch f) fs in
	    fs' == fs => [(f,as)] |
	    let f' = md_merge_vectors fs' then
	    (fs' intersect top_inps) != [] =>
		// Not allowed to have primary inputs to primary outputs
		// Must insert a buffer
		let sz = length fs' in
		let fa_inps = [((mk_name sz "i"),f')] in
		let fa_outs = [((mk_name sz "o"), [f])] in
		let lfs = [(W_UPDATE_FN (W_VAR sz "o") (W_VAR sz "i"))] in
		let buf =
		    PINST "draw_buffer" [] T fa_inps fa_outs [] (P_LEAF lfs)
		then
		(remain' := (buf:(deref remain'))) fseq
		[(f,as)]
	    |
	    length f' = 1 => [((hd f'),as)] |
	    let eas = md_expand_vectors as in
	    let fa = zip fs' eas then
	    letrec pr (f:fs) eas =
		let sz = md_size f in
		let as = firstn sz eas then
		(f,md_merge_vectors as):
		pr fs (butfirstn sz eas)
	     /\   pr [] [] = []
	     /\   pr [] _ = eprintf "f/a length mismatch!"
	    in
	    pr f' eas
	in
	flatmap rename_formal fa_outs
    then
    (PINST name attrs lf fa_inps fa_outs' ints (P_HIER (deref remain')))
;

let fl_do_remove_wires canvas =
  (
    let vfsm = w2vfsm canvas in
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let p = get_idv_current_pexlif canvas then
    let p' =  remove_wire p il then
    (add_transform canvas p' (REMOVE_WIRES il)) fseq
    let cmd =
	sprintf "remove_wires vis %s;" (list2str T "[" "," "]" int2str il)
    in
    refresh_idv_canvas canvas cmd
  ) gen_catch (\msg. window_ok canvas (clean_error_message msg))
;
export_to_tcl fl_do_remove_wires;

let extract_pexlif p il =
    let p' = fold_pexlif p il "_TMP_" then
    val (PINST _ _ _ _ _ _ (P_HIER (c:cs))) = p' then
    c
;

let get_current_selection {dummy :: void} =
    get_selected_pinsts (get_current_canvas dummy)
;
non_lazy get_current_selection;


let IDV_get_spec tr_sequence =
    let db = get_rw_db () then
    val (TRANSFORM name sha_spec sha_imp just) = tr_sequence then
    idv_load_pexlif (db_sname db) sha_spec
;   
    
let IDV_get_imp tr_sequence =
    let db = get_rw_db () then
    val (TRANSFORM name sha_spec sha_imp just) = tr_sequence then
    idv_load_pexlif (db_sname db) sha_imp
;   

let IDV_show_pexlif p =
    let w = get_new_idv_window () then
    let rw_database = db_sname (hd (deref cur_idv_rw_transform_db)) then
    (tcl_eval [sprintf "idv:create_idv_gui %s %s 1" w rw_database]) fseq
    let vfsm = IDV_ENV w (ref []) (ref []) (ref []) (ref []) (ref []) in
    (cur_vfsm := (vfsm:(deref cur_vfsm))) fseq
    (register_vfsm vfsm w) fseq
    (cur_transf_windowsr := ((w,vfsm):(deref cur_transf_windowsr))) fseq
    start_new_transform p w
;
    
    
let IDV_show_spec tr_sequence =
    IDV_show_pexlif (IDV_get_spec tr_sequence)
;

let IDV_show_imp tr_sequence =
    IDV_show_pexlif (IDV_get_imp tr_sequence)
;


