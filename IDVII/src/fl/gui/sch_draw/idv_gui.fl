//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------
let Init_idv_gui = (tcl_eval [sprintf "source %sidv_gui.tcl" DIR]) fseq ();
Init_idv_gui;

let EDIT_cmd file =
    let cmd = "/usr/bin/X11/xterm -sb -sl 20000 -j -rw -ls -bg white "^
	      "-fg black -fn 7x14 -geometry 80x40 -e /usr/bin/vi "
    in
    sprintf "%s %s" cmd file
;

let idv_gui_cnt_ref = ref 0;
let mk_idv_gui_window {dummy::void} =
    let idx = deref idv_gui_cnt_ref + 1 then
    (idv_gui_cnt_ref := idx) fseq
    sprintf ".idv_gui_%d" idx
;
non_lazy mk_idv_gui_window;

lettype idv_trfm_info =
    IDV_TRANSFORM_INFO
	{model_names :: (bool#string#string) list}// (top#name#sha256_sig) list
	{trfms :: ((int#transform list) list)}	// signature#(transform list)
;

lettype idv_rw_db =
    IDV_RW_DB
	    {sname:: string}		// Database short name
	    {fname:: string}		// Database full path name
		// Model names: [(spec # nm # sha_name)]
	    {mnames::(bool#string#string) list}
	    ({int,transform list} tbl)	// Transform table
;

let cur_idv_rw_transform_db = ref {[]:: idv_rw_db list};
let cur_idv_readonly_transform_dbs = ref {[]:: idv_rw_db list};

let db_sname (IDV_RW_DB sname fname mnames tbl) = sname;

let db_fname (IDV_RW_DB sname fname mnames tbl) = fname;

let db_mnames (IDV_RW_DB sname fname mnames tbl) = mnames;

let db_tbl (IDV_RW_DB sname fname mnames tbl) = tbl;

let DBG_get_tbl_entries {dummy::void} =
    tbl2list (db_tbl (hd (deref cur_idv_rw_transform_db)))
;
non_lazy DBG_get_tbl_entries;

let get_idv_db name =
    let dbs = (deref cur_idv_rw_transform_db)@
	      (deref cur_idv_readonly_transform_dbs)
    then
    let alts = filter (\db. db_sname db = name) dbs then
    alts = [] => eprintf "Cannot find a DB named %s" name |
    length alts > 1 => eprintf "More than one DB named %s" name |
    hd alts
;

let CHECK_FOR_RW_DB {dummy::void} =
    (deref cur_idv_rw_transform_db) != [] => () |
    eprintf "No IDV r/w database open."
;

let model_present model_name =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    (find_first0 (\(top,mname,sha). mname = model_name) mnames) != 0
;

let add_model_in_rw_db top_level model_name sha_name =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    model_present model_name =>
	eprintf "A model named %s already exists" model_name
    |
    let same_sha (top,mname,sha) = sha = sha_name in
    let idx = find_first0 same_sha mnames then
    idx != 0 =>
	val (top,mname,sha) = el idx mnames then
	fprintf stdinfo "This circuit is alrady named %s. Saving ignored" mname
    |
    let mnames' = (top_level, model_name, sha_name):mnames then
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames' tbl)])
;

let sha2model db sha_name =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    let same_sha (top,mname,sha) = sha = sha_name in
    let name (top,mname,sha) = mname in
    map name (filter same_sha mnames)
;

let model2sha db model_name =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    let same_model (top,mname,sha) = mname = model_name in
    let get_sha (top,mname,sha) = sha in
    let cands = map get_sha (filter same_model mnames) then
    cands = [] => eprintf "Cannot find model %s" model_name |
    length cands > 1 => eprintf "More than one model named %s" model_name |
    hd cands
;


let delete_model_in_rw_db model_name =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    let mnames' = filter (\(top,mname,sname). mname != model_name) mnames then
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames' tbl)])
;

let get_transform_tbl db =
    val (IDV_RW_DB sname fname mnames tbl) = db in
    tbl
;

let update_rw_transform_tbl tbl' =
    (CHECK_FOR_RW_DB ()) fseq
    val (IDV_RW_DB sname fname mnames tbl) =
	hd (deref cur_idv_rw_transform_db)
    in
    (cur_idv_rw_transform_db := [(IDV_RW_DB sname fname mnames tbl')])
;
non_lazy update_rw_transform_tbl;

let get_rw_db {dummy::void} =
    let cur_tbls = deref cur_idv_rw_transform_db then
    (cur_tbls = []) => eprintf "No IDV r/w database open." |
    (length cur_tbls > 1) => eprintf "More than one IDV r/w table open???" |
    hd cur_tbls
;
non_lazy get_rw_db;


let get_selected_wires vfsm =
    let selection = qsort node_name_cmp (deref (vfsm2selection_r vfsm)) then
    setify (md_expand_vectors selection)
;

let find_next_anon_name {dummy::void} =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let get_mname (top,mname,sha_name) = mname in
    let anons =
	map get_mname (filter (\p. str_is_prefix "anon_" (get_mname p)) mnames)
    in
    let next = 
	anons = [] => 1 |
	let indices = qsort (defix -) (map (sscanf "anon_%d") anons) in
	(last indices) + 1
    in
    sprintf "anon_%d" next
;
non_lazy find_next_anon_name;

let find_next_anon_transform_name signature =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let cur = tbl_member tbl signature => tbl_get tbl signature | [] then
    let in_use = map get_transform_name cur then
    let anons = filter (str_is_prefix "tr_") in_use then
    let next = 
	anons = [] => 1 |
	let indices = qsort (defix -) (map (sscanf "tr_%d") anons) in
	(last indices) + 1
    in
    sprintf "tr_%d" next
;
non_lazy find_next_anon_transform_name;

//
// Much too simplistic and (fatally) not guaranteed to be valid!
//
letrec equal_pexlif (PINST nm1 attr1 lf1 in1 out1 int1 (P_HIER ch1))
		    (PINST nm2 attr2 lf2 in2 out2 int2 (P_HIER ch2)) =
    (find_signature attr1 == find_signature attr2) => T |
    (find_fingerprint attr1 != find_fingerprint attr2) => F |
    (length ch1) != (length ch2) => F |
    (length in1) != (length in2) => F |
    (length out1) != (length out2) => F |
    (length int1) != (length int2) => F |
    let mk_sub sp1 sp2 =
	val (PINST snm1 sattr1 slf1 sin1 sout1 sint1 sbody1) = sp1 in
	val (PINST snm2 sattr2 slf2 sin2 sout2 sint2 sbody2) = sp2 in
	NOT (equal_pexlif sp1 sp2) => (F,[]) |
	let ainp1 = md_expand_vectors (flatmap snd sin1) in
	let ainp2 = md_expand_vectors (flatmap snd sin2) in
	let aout1 = md_expand_vectors (flatmap snd sout1) in
	let aout2 = md_expand_vectors (flatmap snd sout2) in
	let sub = setify ((zip ainp1 ainp2)@(zip aout1 aout2)) then
	let idx = find_first0 (\l. length l > 1) (partition fst sub) in
	idx = 0 => (T,sub) | (F,[])
    in
    let subs = map2 mk_sub ch1 ch2 then
    let idx = find_first (\p. NOT (fst p)) subs in
    idx != 0 => F |
    let sub = setify (flatmap snd subs) then
    let idx = find_first0 (\l. length l > 1) (partition fst sub) in
    idx = 0
 /\    equal_pexlif _ _ = F
;


let get_idv_candidates p =
    let signature = pexlif_get_FP p then
    let get_cand db =
	let tbl = get_transform_tbl db in
	tbl_member tbl signature => [(db,(tbl_get tbl signature))] | []
    in
    let pots = flatmap get_cand ((deref cur_idv_rw_transform_db)@
				 (deref cur_idv_readonly_transform_dbs))
    then
    let check (db,alts) =
	let same_spec (TRANSFORM name spec imp just) =
	    let ps = read_pexlif spec then
	    equal_pexlif p ps
	in
	let alts' = filter same_spec alts then
	alts' = [] => [] | [(db,alts')]
    in
    flatmap check pots
;


let record_transformation signature tr =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let old = tbl_member tbl signature => tbl_get tbl signature | [] then
    let new = tr:old then
    let tbl' = tbl_member tbl signature => tbl_delete tbl signature | tbl then
    let tbl'' = tbl_insert tbl' signature new then
    update_rw_transform_tbl tbl''
;

let load_idv_db sname fname =
    let db_file = sprintf "%s/transform_db" fname then
    NOT (file_exists db_file) => IDV_RW_DB sname fname [] (list2tbl []) |
    val (IDV_TRANSFORM_INFO mnames sig_trfs) = read_idv_trfm_info db_file then
    IDV_RW_DB sname fname mnames (list2tbl sig_trfs)
;

let fl_save_idv_db {cmd::string} =
    let dbl = deref cur_idv_rw_transform_db then
    dbl = [] => () |
    val (IDV_RW_DB sname fname mnames tbl) = hd dbl then
    let sig_transf_list = tbl2list tbl then
    let data = IDV_TRANSFORM_INFO mnames sig_transf_list then
    let db_file = sprintf "%s/transform_db" fname then
    (NOT (file_exists db_file) => () |
	system (sprintf "/bin/mv -f %s %s.bkp" db_file db_file) fseq ()
    ) fseq
    (write_idv_trfm_info db_file data) fseq 
    cmd != "exit" => () |
    // If exit, remove lock file and clean up
    let cmd = sprintf "/bin/rm -f %s/lock" fname in
    (system cmd) fseq
    (cur_idv_rw_transform_db := [])
;
export_to_tcl fl_save_idv_db;

let open_idv_db dir readonly =
    NOT readonly AND ((deref cur_idv_rw_transform_db) != []) =>
	eprintf "Only one r/w IDV database can be open at the same time"
    |
    let do_cmd cmd =
	let status = system cmd then
	status = 0 => () |
	eprintf "FAILURE: %s\n" cmd
    in
    let full_name = tcl_eval ["file normalize "^dir] then
    let my_host = hd (snd (exec "hostname")) then
    let my_pid  = pid then
    NOT (file_exists full_name) =>
	readonly => eprintf "%s is not a readable IDV database" dir |
	(do_cmd (sprintf "mkdir %s" dir)) fseq
	(do_cmd (sprintf "mkdir %s/code" dir)) fseq
	(do_cmd (sprintf "mkdir %s/pexlifs" dir)) fseq
	let fp = fopen (sprintf "%s/lock" full_name) "w" then
	(fprintf fp "%s|%d" my_host my_pid) fseq
	(fclose fp) fseq
	cur_idv_rw_transform_db :=
	    [(IDV_RW_DB dir full_name [] (tbl_create 100))]
    |
    // Check that the DB looks ok
    let check_file file =
	file_exists (sprintf "%s/%s" full_name file) => () |
	eprintf "IDV database corrupted. Missing %s\n" file
    in
    (check_file "pexlifs") fseq
    (check_file "code") fseq
    readonly =>
	let db_info = load_idv_db dir full_name then 
	let cur_dbs = deref cur_idv_readonly_transform_dbs then
	(cur_idv_readonly_transform_dbs := (db_info:cur_dbs))
    |
    // For read/write data bases, check that no active lock exists
    let lockfile = sprintf "%s/lock" full_name then
    // Make sure DB isn't locked by a running process
    (NOT (file_exists lockfile) => () |
	let fp = fopen lockfile "r" then
	let line = fgets fp then
	let parts = str_split line "|" then
	(fclose fp) fseq
	length parts != 2 => eprintf "Corrupted lockfile (%s)" line |
	val [lhost,lpid] = parts in
	let lpid_alive =
	    (snd (exec (sprintf "ps --no-headers --pid %s" lpid))) != []
	then
	lhost == my_host AND lpid_alive =>
	    eprintf "IDV_DB %s is owned by running process %s" full_name lpid
	| 
	(fprintf stdinfo "-I-: removing lockfile since owner no longer alive\n")
	fseq
	(do_cmd (sprintf "/bin/rm -f %s" lockfile)) 
    ) fseq
    // Write lockfile
    let fp = fopen (sprintf "%s/lock" full_name) "w" then
    (fprintf fp "%s|%d" my_host my_pid) fseq
    (fclose fp) fseq
    let db_info = load_idv_db dir full_name then 
    (cur_idv_rw_transform_db := [db_info])
;

let get_idv_db_dir {dummy::void} =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    fname
;
non_lazy get_idv_db_dir;

let is_rw_db db_name =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    db_name == sname
;

let get_db_info db_name =
    let pot_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let idx = find_first0 (\t. (db_sname t) = db_name) pot_dbs in
    idx = 0 =>
	eprintf "Cannot find %s in %S" db_name (map db_sname pot_dbs)
    |
    el idx pot_dbs
;

let get_db_dir db_name = db_fname (get_db_info db_name);

let get_models db_name toplevel_only = 
    let get_model (top,model,sha) = model in
    let raw = db_mnames (get_db_info db_name) then
    let relevant = toplevel_only => filter fst raw | raw then
    map get_model relevant
;

let get_sha_for_mode db model =
    let is_sel_model (top,mname,sha) = mname = model in
    let alts = filter is_sel_model (db_mnames (get_db_info db)) then
    alts = [] => eprintf "Cannot find model %s" model |
    length alts > 1 => eprintf "More than model named %s" model |
    val [(top,mname,sha)] = alts in
    sha
;


//let get_db_mnames db_name =
//    val (sname,fname,mnames,tbl) = get_db_info db_name then
//    mnames
//;

let get_db_transf_tbl db_name =
    val (IDV_RW_DB sname fname mnames tbl) = get_db_info db_name then
    tbl
;

let idv_save_pexlif p =
    let sha = pexlif_get_SHA p then
    let db_dir = get_idv_db_dir () then
    let file = sprintf "%s/pexlifs/%s" db_dir sha in
    file_exists file => sha |
    ((write_pexlif file p) fseq sha)
;


let idv_load_pexlif db p_sha =
    let db_dir = get_db_dir db then
    let file = sprintf "%s/pexlifs/%s" db_dir p_sha in
    file_exists file => read_pexlif file |
    eprintf "Failed to load %s. IDV database corrupted?" file
;


let cur_transf_windowsr = ref {[]:: (string#vfsm) list};

let get_new_idv_window {dummy :: void} =
    let l = length (deref cur_transf_windowsr) then
    sprintf ".idv_%d" l
;
non_lazy get_new_idv_window;

let get_number_of_children (PINST _ _ _ _ _ _ (P_HIER chs)) =
    length chs
 /\ get_number_of_children other = 0
;

let refresh_idv_canvas canvas cmd =
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent sell rvis rtrf) = evis then
    let trf = get_idv_info canvas then
    val (p,ckt,_) = hd trf in
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    (rvis := vis) fseq
    (rtrf := trf) fseq
    (add_command vfsm cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas
              ]) fseq
    ()
;


let accurate_toplevel_pexlif2fsm p =
    let old = update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" "TRUE" then
    let res = toplevel_pexlif2fsm p then
    (update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" old) fseq
    res
;

let start_new_transform p start_new w =
    let p = start_new => remove_wrappers p | p then
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    //
    let vfsm = w2vfsm w then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" then
    let cmd = "DUMMY" in
    let evis = TR_SEQ "" [] (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c
	      ]
    ) fseq
    ()
;

let IDV rw_database read_only_dbs =
    // Open the databases
    (open_idv_db rw_database F) fseq
    (foreach (\db. open_idv_db db T) read_only_dbs) fseq
    // Start GUI
    let w = get_new_idv_window () then
    (tcl_eval [sprintf "idv:create_idv_gui %s %s" w rw_database]) fseq
    let vfsm = IDV_ENV w (ref []) (ref []) (ref []) (ref []) (ref []) in
    (cur_vfsm := (vfsm:(deref cur_vfsm))) fseq
    (register_vfsm vfsm w) fseq
    (cur_transf_windowsr := ((w,vfsm):(deref cur_transf_windowsr))) fseq
    ()
;

let add_transform canvas p tr =
    let vfsm = w2vfsm canvas in
    let ckt = accurate_toplevel_pexlif2fsm p then
    let trfsr = get_idv_info_r canvas then
    (trfsr := ((p,ckt,tr):(deref trfsr))) fseq
    ()
;
non_lazy add_transform;

let fl_is_toplevel_transform canvas =
    val (parent,sell) = get_idv_parent_info canvas then
    parent == ""
;
export_to_tcl fl_is_toplevel_transform;


let unfold_all_labeled p lbl =
    letrec do1 p =
	val (PINST nm attrs lf fa_inps fa_outs ints (P_HIER chs)) = p in
	let idx = find_first0 (\p. pexlif_get_name p = lbl) chs in
	idx = 0 => p |
	let p' = unfold_pexlif p idx then
	do1 p'
    in
    do1 p
;

let rename_name (PINST _ attrs lf fa_inps fa_outs ints body) new_name =
    PINST new_name attrs lf fa_inps fa_outs ints body
;

let idv_finish_transformation canvas =
    let vfsm = w2vfsm canvas in
    let trfs = get_idv_info canvas then
    let just = map (\(p,ckt,j).j) (butlast trfs) then
    just = [] => T |
    let imp = fst (hd trfs) in
    let spec = fst (last trfs) in
    let spec_sig = pexlif_get_FP spec then
    let tr_name = find_next_anon_transform_name spec_sig then
    let model_name = find_next_anon_name () then
    let cmd = sprintf "idv:name_transform_and_use %s %s %s"
		       canvas tr_name model_name
    then
    let resl = tcl2list (tcl_eval [cmd]) then
    let op = el 1 resl in
    let transform_name = el 2 resl in
    let model_name = el 3 resl in
    op = "Cancel" => F |
    op = "Discard" => T |
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    // Name the implementation pexlif
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    (add_model_in_rw_db F model_name imp_sha) fseq
    // Now save the transformation
    let tr = TRANSFORM transform_name spec_sha imp_sha just then
    (record_transformation spec_sig tr) fseq
    op = "Save" => T |
    op = "SaveAndApplyOnce" =>
	val (parent,sell) = get_idv_parent_info canvas then
	let pp = get_idv_current_pexlif parent then
	let pp' = fold_pexlif pp sell "_TMP_" then
	val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (c:cs))) = pp' in
	c == spec =>
	(
	    let p' = PINST nm attrs leaf fa_inps fa_outs ints
			    (P_HIER (imp:cs))
	    then
	    let p'' = unfold_pexlif p' 1 then
	    (add_transform parent p'' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	    in
	    (refresh_idv_canvas parent cmd) fseq T
	)
	|
	eprintf "Parent circuit has changed. Cannot apply the transformation"
    |
    op = "SaveAndApplyEverywhere" =>
	val (parent,sell) = get_idv_parent_info canvas then
	let pp = get_idv_current_pexlif parent then
	let matches = isomatch spec pp then
	let groups = map (map (fst # snd)) matches then
	let nbr_groups = length groups then
	let lbl = "_#*&_&*#_" in
	let pp' = foldn_pexlif pp groups lbl then
	let imps =
	    letrec do_sub (cp:cps) (m:ms) =
		let matches = map (snd # snd) m then
		let subs = map get_match_sub  matches then
		let opt_cp_sub = actualize_hier subs imp cp then
		let cp' =
		    has_value opt_cp_sub =>
			let cp_sub = get_value opt_cp_sub then
			rename_name (pex_subst_actuals imp cp_sub) lbl
		    |
			rename_name cp lbl
		then
		cp' : (do_sub cps ms)
	     /\   do_sub [] [] = []
	    in
	    do_sub (firstn nbr_groups (pexlif_get_children pp')) matches
	then
	val (PINST n attrs lf fa_inps fa_outs ints (P_HIER children)) = pp' then
	let children' = imps@(butfirstn nbr_groups children) then
	let tmp = PINST n attrs lf fa_inps fa_outs ints (P_HIER children') then
	let res = unfold_all_labeled tmp lbl then
	(add_transform parent res (REPLACE sell tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	in
	(refresh_idv_canvas parent cmd) fseq T
    |
    eprintf "Illegal operation '%s'\n" op
;

let get_selected_pinsts canvas =
    let vfsm = w2vfsm canvas in
    let selection = deref (vfsm2selection_r vfsm) then
    let all_sels = md_expand_vectors selection in
    let ckt = get_idv_current_fsm canvas then
    let nd2pinst n = [(get_visualization_pinst_cnt ckt n 0)] catch [] in
    setify (flatmap nd2pinst all_sels)
;


let fl_do_fold canvas name =
    let name' = "draw_hier "^name then
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let p = get_idv_current_pexlif canvas then
    let p' = fold_pexlif p il name' then
    (add_transform canvas p' (FOLD il name')) fseq
    let cmd = sprintf "fold vis %s \"%s\";"
		      (list2str T "[" "," "]" int2str il) name
    in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_fold;

let fl_do_unfold canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    length il > 1 => 
	report_error "Can only unfold one instance at a time"
    |
    let p = get_idv_current_pexlif canvas then
    let p' = unfold_pexlif p (hd il) then
    (add_transform canvas p' (UNFOLD (hd il))) fseq
    let cmd = sprintf "unfold vis %d;" (hd il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_unfold;

let fl_do_flatten canvas =
    let vfsm = w2vfsm canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = flatten_pexlif p then
    (add_transform canvas p' FLATTEN) fseq
    let cmd = sprintf "flatten vis;" in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_flatten;

let fl_do_idv_undo canvas =
    let vfsm = w2vfsm canvas then
    let trfsr = get_idv_info_r canvas then
    let trfs = deref trfsr then
    length trfs <= 1 => () |
    let trfs' = tl trfs then
    (trfsr := trfs') fseq
    val (p,ckt,_) = hd trfs' in
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent sell rvis rtrf) = evis then
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    (rvis := vis) fseq
    (rtrf := trfs') fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas
              ]) fseq
    ()
;
;
export_to_tcl fl_do_idv_undo;




let duplicate_instance p id =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
    let cur_nds = ref
        (setify (md_expand_vectors ((map fst fa_inps)@(map fst fa_outs)@ints)))
    in
    let selected = el id chs in
    val (PINST dname dattrs dleaf dfa_inps dfa_outs dints dcont) = selected in
    let driven_nds = md_expand_vectors (flatmap snd dfa_outs) in 
    let driven_vecs = md_extract_vectors driven_nds in
    let copies = ref [] in
    let new_ints = ref [] in
    let try_assoc key l = (assoc key l) catch key in
    let rename sub as =
        md_merge_vectors (map (\a.try_assoc a sub) (md_expand_vectors as))
    in
    letrec get_next_names cnt =
	cnt = 0 => (copies := (selected:(deref copies))) fseq [] |
	let test = map (sprintf "#%d_%s" cnt) driven_nds in
	(test intersect (deref cur_nds)) != [] => get_next_names (cnt+1) |
	(cur_nds := (test @ (deref cur_nds))) fseq
	let sub = zip driven_nds test in
	let new_int = md_extract_vectors test then
	(new_ints := (new_int@(deref new_ints))) fseq
	let dfa_outs' = map (\(f,as). f, rename sub as) dfa_outs in
	let copy = PINST dname dattrs dleaf dfa_inps dfa_outs' dints dcont then
	(copies := (copy:(deref copies))) fseq
        sub
    in
    let process sp =
        val (PINST lname lattrs lleaf lfa_inps lfa_louts lints lcontent) = sp in
        let depend_nds = md_expand_vectors (flatmap snd lfa_inps) then
        let overlap = depend_nds intersect driven_nds in
        overlap = [] => sp |
        let sub = get_next_names (length (deref copies)) then
        let lfa_inps' = map (\(f,as). f, rename sub as) lfa_inps then
        (PINST lname lattrs lleaf lfa_inps' lfa_louts lints lcontent)
    in
    let chs' = map process chs then
    let all_chs = (deref copies)@chs' then
    let ints' = ints@(deref new_ints) then
    PINST name attrs leaf fa_inps fa_outs ints' (P_HIER all_chs)
;       


let fl_do_duplicate canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    length il > 1 => 
	report_error "Can only duplicate one instance at a time"
    |
    let p = get_idv_current_pexlif canvas then
    let p' = duplicate_instance p (hd il) then
    (add_transform canvas p' (DUPLICATE (hd il))) fseq
    let cmd = sprintf "duplicate vis %d;" (hd il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_duplicate;




let mk_buf inps outs =
    let vinps = md_merge_vectors inps in
    let vouts = md_merge_vectors outs in
    let sz = md_sizes vinps in
    md_sizes vouts != sz => error "Length mismatch in mk_buf" |
    let p = (W_VAR sz "o") <- (W_VAR sz "i") in
    val (PINST name attrs leaf [(fi,_)] [(fo,_)] ints body) = p in
    PINST name attrs leaf [(fi,vinps)] [(fo,vouts)] ints body
;

let merge_instances p ids =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
    let sels = map (\i. el i chs) ids in
    length sels <= 1 => p |
    let remain = chs subtract sels in
    let master = hd sels in
    let victims = tl sels in
    // Make sure all victims are the same as the master
    let not_identical_pexlif p1 p2 =
	pexlif_get_SHA p1 != pexlif_get_SHA p2 => T |
	val (PINST _ _ _ fa_inps1 fa_outs1 _ _) = p1 in
	val (PINST _ _ _ fa_inps2 fa_outs2 _ _) = p2 in
	let cmp (f1,as1) (f2,as2) = strcmp f1 f2 in
	let i1 = qsort cmp fa_inps1 in
	let i2 = qsort cmp fa_inps2 in
	i1 != i2
    in
    let idx = find_first0 (not_identical_pexlif master) victims then
    idx != 0 => 
	report_error "Not all selected instances are identical" fseq p
    |
    let get_fa_out (PINST _ _ _ _ fa_outs _ _) = fa_outs in
    let master_sub = get_fa_out master in
    let mk_sub vp =
	let v_fa_outs = get_fa_out vp then
	let mk (vf,vas) =
	    let mas = assoc vf master_sub in
	    zip (md_expand_vectors vas) (md_expand_vectors mas) 
	in
	flatmap mk v_fa_outs
    in
    let subs = flatmap mk_sub victims then
    let rename a = (assoc a subs) catch a in
    let rename_fa fa =
	let rename1 (f,as) =
	    f, (md_merge_vectors (map rename (md_expand_vectors as)))
	in
	map rename1 fa
    in
    let rename_pexlif (PINST name attrs leaf fa_inps fa_outs ints body) =
	let fa_inps' = rename_fa fa_inps in
	let fa_outs' = rename_fa fa_outs in
	(PINST name attrs leaf fa_inps' fa_outs' ints body)
    in
    // Build new pexlif
    let chs = map rename_pexlif (master:remain) in
    let mk_wire (f,as) =
	let nds = md_expand_vector f in
	let nds' = map rename nds in
	nds' = nds => [] |
	// Must add a buffer since multiple outputs are now driven
	// by the same signal
	[mk_buf nds' nds]
    in
    let buffers = flatmap mk_wire (fa_outs) then
    let chs' = buffers@chs then
    // TODO: Clean up "ints"
    (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs'))
;


let fl_do_merge canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = merge_instances p il then
    (add_transform canvas p' (MERGE il)) fseq
    let cmd = sprintf "merge vis %s;" (list2str T "[" "," "]" int2str il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_merge;

let fl_do_new_tranf canvas =
    let vfsm = w2vfsm canvas then
    let w = vfsm2id vfsm then
    let il = get_selected_pinsts canvas then
    let parent = get_idv_current_pexlif canvas then
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif parent il "_TMP_" then
    val (PINST _ _ _ _ _ _ (P_HIER chs)) = p' in
    let p = el 1 chs then
    //
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" then
    let cmd =
	let tab = canvas2tab c then
	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") outs in
	sprintf "OBSOLETE: let %s = draw_fanin vis (%d) %d %s;\n%s;"
		 tab 0 100 svecs tab
    in
    let evis = TR_SEQ canvas il (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c
	      ]) fseq
    ()
;
export_to_tcl fl_do_new_tranf;

let fl_model_name_used name =
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let idx = find_first0 (\(top,mname,sha). mname = name) mnames then
    idx != 0
;
export_to_tcl fl_model_name_used;

let fl_do_name_model canvas name version =
    model_present name => eprintf "Model %s already exists" name |
    let trfs = get_idv_info canvas then
    let p = fst (version = "specification" => (last trfs) | (hd trfs)) then
    let p_sha  = idv_save_pexlif p then
    add_model_in_rw_db F name p_sha
;
export_to_tcl fl_do_name_model;

let fl_idv_get_db_names {canvas::string} =
    map db_sname ((deref cur_idv_rw_transform_db)@
		      (deref cur_idv_readonly_transform_dbs))
;
export_to_tcl fl_idv_get_db_names;

let fl_get_idv_models {canvas::string} db visible pat =
    let relevant = 
	visible = "All" => get_models db F |
	visible = "User given" =>
	    let user_given n = NOT (str_is_prefix "anon_" n) in
	    filter user_given (get_models db F) |
	visible  = "Imported" => get_models db T |
	eprintf "Unknwn visible argument (%s)" visible
    then
    filter (str_match pat) relevant
;
export_to_tcl fl_get_idv_models;

let get_transform_fanout p =
    let p_fp = pexlif_get_FP p then
    let p_SHA = pexlif_get_SHA p then
    let all_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let get_fanout db =
	val (IDV_RW_DB sname fname mnames tbl) = db in
	let get_info (TRANSFORM name sha_spec sha_imp just) =
	    p_SHA != sha_spec => [] |
	    let id = sprintf " %s:%s" sname name in
	    let dest = sha2model db sha_imp in
	    dest = [] => [] |
	    [(id, hd dest, (idv_load_pexlif sname sha_imp))]
	in
	flatmap get_info (tbl_member tbl p_fp => tbl_get tbl p_fp | [])
    in
    flatmap get_fanout all_dbs
;

let fl_do_new_toplevel_transf {w::string} db name =
    (CHECK_FOR_RW_DB ()) fseq
    let p_sha = get_sha_for_mode db name then
    let p = idv_load_pexlif db p_sha then
    (start_new_transform p F w) fseq
    (tcl_eval ["update"]) fseq
    is_rw_db db => () |
    (tcl_eval [sprintf "idv:name_and_save_model %s specification %s" w name])
    fseq ()
;
export_to_tcl fl_do_new_toplevel_transf;


let fl_display_transform_tree canvas dbname name =
    let db = get_idv_db dbname then
    let p_sha = model2sha db name then
    let p = idv_load_pexlif dbname p_sha then
    let done = ref [] in
    let vertices = ref [] in
    let edges = ref [] in
    let vertex_map = ref [] in
    let edge_map = ref [] in
    letrec fanout_rec name p =
	let idx = find_first0 (\pp. fst pp == p) (deref done) then
	idx != 0 => snd (el idx (deref done)) |
	let vertex_name = sprintf "n%d" (length (deref done)) then
	let ext_name = sprintf "%s:%s" dbname name in
	(vertex_map := ((vertex_name,ext_name):(deref vertex_map))) fseq
	let sz = float2str (int2float (1+strlen ext_name)*0.1) then
	let dc = sprintf
      "%s [shape=box, width=%s, height=0.10, fixedsize=shape, label = \"%s\"]\n"
			vertex_name sz vertex_name
	then
	(vertices := (dc:(deref vertices))) fseq
	(done := ((deref done)@[(p,vertex_name)])) fseq
	let next_states = get_transform_fanout p then
	let mk_edge (trans_name, dest_name, p_dest) =
	    let dest = fanout_rec dest_name p_dest then
	    let edge_name = sprintf "e%d" (length (deref edges)) then
	    (edge_map := ((edge_name, trans_name):(deref edge_map))) fseq
	    let edge = sprintf "%s -> %s [ label = \"%s\" ];\n"
			       vertex_name dest edge_name
	    then
	    (edges := (edge:(deref edges)))
	in
	(foreach mk_edge next_states) fseq
	vertex_name
    in
    let res = fanout_rec name p then
    //
    let fp = mktemp "transform_draw" then
    let file = stream2filename fp then
    (fprintf fp "digraph transform_tree {\n") fseq
    (fprintf fp "rankdir=TB;\n") fseq
    (fprintf fp "size=\"8,5\"\n") fseq
    (foreach (fprintf fp "%s") (deref vertices)) fseq
    (foreach (fprintf fp "%s") (deref edges)) fseq
    (fprintf fp "}\n") fseq
    (fclose fp) fseq
    //
    (tcl_eval ["catch {unset ::idv_transf_node_map}"]) fseq
    let mk_ndmap (n,nn) =
	let cmd = sprintf "set ::idv_transf_node_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_ndmap (deref vertex_map)) fseq
    //
    (tcl_eval ["catch {unset ::idv_transf_edge_map}"]) fseq
    let mk_ndmap (n,nn) =
	let cmd = sprintf "set ::idv_transf_edge_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_ndmap (deref edge_map)) fseq
    //
    (tcl_eval [sprintf "idv:show_transformations %s %s" file canvas]) fseq
    ()
;
export_to_tcl fl_display_transform_tree;

letrec convert_to_idv_format p =
    letrec cnv (PINST nm attrs lf fa_inps fa_outs ints (P_HIER ps)) =
	PINST nm attrs lf fa_inps fa_outs ints (P_HIER (map cnv ps))
     /\    cnv (PINST nm attrs lf fa_inps fa_outs ints leaf) =
	PINST nm attrs lf fa_inps fa_outs ints leaf
    in
    cnv p
;

let fl_import_model w filename =
    let p = convert_to_idv_format (remove_wrappers (read_pexlif filename)) then
    let tent_name = pexlif_get_name p then
    let name = 
	NOT (fl_model_name_used tent_name) => tent_name |
	tcl_eval ["idv:ask_for_model_name "^w]
    then
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    let p_sha  = idv_save_pexlif p then
    (add_model_in_rw_db T name p_sha) fseq
    (tcl_eval ["idv:update_idv_list"]) fseq
    ()
;
export_to_tcl fl_import_model;

let clean_name s =
    let tr c =
	c = " " => "_" |
	c = "{" => "_" |
	c = "}" => "_" | c
    in
    implode (map tr (explode s))
;

let generate_hfl_template fp p basename pexlif_file =
    val (PINST name attrs lf fa_inps fa_outs ints body) = p in
    (fprintf fp "load \"ste.fl\";\n") fseq
    let name' = clean_name basename then
    let inps = map fst fa_inps in
    let outs = map fst fa_outs in
    let ios = inps @ outs in
    let szs = qsort (defix -) (setify (map md_size ios)) in
    let declare sz = 
	sz = 1 => () |
	fprintf fp "TYPE \"bv%d\" %d;\n" sz sz
    in
    (foreach declare szs) fseq
    (fprintf fp "\nlet %s =\n" name') fseq
    let rcnt = ref 1 in
    let emit_io io v =
	let sz = md_size v in
	let type = sz = 1 => "bit" | sprintf "bv%d" sz in
	let idx = deref rcnt then
	(rcnt := idx+1) fseq
	let base = sprintf "%s%d" (io = "input" => "i" | "o") idx then
	(fprintf fp "    %s_%s   %s.  // %s\n" type io base v)
    in
    (foreach (emit_io "input") inps) fseq
    (rcnt := 1) fseq
    (foreach (emit_io "output") outs) fseq
    (fprintf fp "    CELL \"%s\" [\n\n    // Your code\n\n];\n" basename) fseq
    (fprintf fp "\n\nlet p = %s" name') fseq
    let emit_tv v =
	let sz = md_size v in
	let type = sz = 1 => "bit" | sprintf "bv%d" sz in
	(fprintf fp "\n\t\t{(_s2_var \"%s\")::%s}" v type)
    in
    (foreach emit_tv (ios)) fseq
    (fprintf fp "\n;\np fseq ();\n") fseq
    (fprintf fp "write_pexlif \"%s\" p;\n" pexlif_file) fseq
    (fprintf fp "\"===SuCcEsS===\";\n") fseq
    (fprintf fp "quit;\n")
;


let fl_make_template canvas type file basename create =
    let vfsm = w2vfsm canvas then
    let pexlif_file = sprintf "%s/pexlifs/%s.pexlif"
			      (get_idv_db_dir ()) (clean_name basename)
    then
    let p = get_idv_current_pexlif canvas then
    let load_file =
	type = "hfl" =>
	    (create = 0 => () |
		let fp = fopen file "w" then
		(generate_hfl_template fp p basename pexlif_file) fseq
		(fclose fp)
	    ) fseq
	    file
	|
	type = "verilog" =>
	    val (PINST nm attrs lf fa_inps fa_outs ints body) = p in
	    let fp = mktemp "verilog_reader" then 
	    let load_file = stream2filename fp then
	    (fprintf fp "load \"ste.fl\";\n") fseq
	    (fprintf fp "let p = verilog2pexlif F -I. \"%s\" [\"%s\"] [];\n"
			nm file) fseq
	    (fprintf fp "p fseq (write_pexlif \"%s\" p);\n" pexlif_file) fseq
	    (fprintf fp "\"===SuCcEsS===\";\n") fseq
	    (fprintf fp "quit;\n") fseq
	    (fclose fp) fseq
	    (create = 0 => () |
		let p' = PINST nm attrs lf fa_inps fa_outs [] (P_HIER []) in
		let fp = fopen file "w" then
		(pexlif2verilog fp p') fseq
		(fclose fp)
	    ) fseq
	    load_file
	|
	eprintf "Unknown template type (%s)" type
    then
    [pexlif_file, load_file]
;
export_to_tcl fl_make_template;

let fl_bdd_var_order {canvas::string} {file::string} =
    ()
;
export_to_tcl fl_bdd_var_order;


let fl_do_verify canvas {file::string} {type::string} =
    (
	let vfsm = w2vfsm canvas then
	let spec = get_idv_current_pexlif canvas then
	let imp =
	    convert_to_idv_format (remove_wrappers (read_pexlif file))
	then
	let ok = type = "BDD" => ((BDD_comb_EQ spec imp) == T) |
		 type = "SAT" => ((SAT_comb_EQ spec imp) == bT) |
		 eprintf "Unknown engine (%s)" type
	then
	NOT ok => "cex" |
	let just = FEV type [] in
	(add_transform canvas imp just) fseq
	let signature = pexlif_get_FP spec then
	let transform_name = find_next_anon_transform_name signature then
	let imp_sha  = idv_save_pexlif imp then
	let spec_sha = idv_save_pexlif spec then
	let tr = TRANSFORM transform_name spec_sha imp_sha [just] then
	(record_transformation signature tr) fseq
	let cmd = sprintf "flatten vis;" in
	(refresh_idv_canvas canvas cmd) fseq
	"ok"
    ) gen_catch (\msg. msg)
;
export_to_tcl fl_do_verify;

let compress_formals fas =
    let sub = 
	let mk1 (f, as) = zip (md_expand_vector f) (md_expand_vectors as) in
	flatmap mk1 fas
    then
    let fs = merge_vectors (map fst fas) in
    let mk f =
	let fs = md_expand_vector f in
	let as = map (\f. assoc f sub) fs then
	f, (merge_vectors as)
    in
    map mk fs
;
    

letrec rename_pexlif_wires
	    sub
	    (PINST name attrs lf fa_inps fa_outs ints (P_HIER children))
    = 
    let in_use = md_expand_vectors ((map fst (fa_inps @ fa_outs))@ints) in
    let from = map fst sub then
    let to   = map snd sub then
    (length to != length (setify to)) => eprintf "Duplicate new names" |
    ((in_use subtract from) intersect to) != [] =>
	eprintf "Name clash(es) in renaming wires (%S)"
		((in_use subtract from) intersect to)
    |
    let trf (f,as) =
	let fnds = md_expand_vector f then
	let fnds' = map (\f. (assoc f sub) catch f) fnds then
	let f' = md_merge_vectors fnds' then
	length f' = 1 => [((hd f'),as)] |
	letrec mk (f:fs) as =
	    let len = md_size f in
	    let p_as = firstn len as in
	    (f,md_merge_vectors p_as):
	    (mk fs (butfirstn len as))
	 /\    mk [] as = 
	    as != [] => error "WHAT???" |
	    []
	in
	mk f' (md_expand_vectors as)
    in
    let fa_inps' = compress_formals (flatmap trf fa_inps) in
    let fa_outs' = compress_formals (flatmap trf fa_outs) in
    let ints' = md_extract_vectors (map (\n.(assoc n sub) catch n)
					(md_expand_vectors ints))
    then
    let tra (f,as) =
	let as' = md_merge_vectors (map (\n.(assoc n sub) catch n)
					(md_expand_vectors as))
	then
	(f,as')
    in
    let mk_sub (f,as) =
	let fs = md_expand_vector f then
	let as = md_expand_vectors as then
	let tr f a =
	    (
		let new = assoc a sub then
		[(f,new)]
	    ) catch []
	in
	flat (map2 tr fs as)
    in
    let process_child (PINST cn ca cl cfa_inps cfa_outs cints cbody) =
	let cfa_inps' = map tra cfa_inps then
	let cfa_outs' = map tra cfa_outs then
	let cp = PINST cn ca cl cfa_inps' cfa_outs' cints cbody then
	let sub' = flatmap mk_sub (cfa_inps@cfa_outs) then
	(rename_pexlif_wires sub' cp) catch cp
    in
    let children' = map process_child children then
    PINST name attrs lf fa_inps' fa_outs' ints' (P_HIER children')
 /\    rename_pexlif_wires sub other = other
;


let fl_rename_wires canvas =
    let vfsm = w2vfsm canvas in
    let p = get_idv_current_pexlif canvas then
    let selected_wires = get_selected_wires vfsm then
    let mlen = itlist (\s.\m. max m (strlen s)) selected_wires 0 then
    let fp = mktemp "rename_wires" then
    let filename = stream2filename fp then
    (foreach (fprintf fp "%-*s -> \n" mlen) selected_wires) fseq
    (fclose fp) fseq
    letrec try dummy =
	let pid = tcl_eval [sprintf "exec %s &" (EDIT_cmd filename)] then
	(tcl_eval ["set ::done_edit 0",
		   sprintf "util:watch_process %s 50 {set ::done_edit 1}"
			    pid]) fseq
	(tcl_eval ["tkwait variable ::done_edit"]) fseq
	let fp = fopen filename "r" then
	letrec read fp =
	    let line = fgets fp then
	    line = "" => [] |
	    (string_butlast line):(read fp)
	in
	let lines = read fp then
	let mk_sub i l =
	    let sl = str_split l "->" then
	    length sl != 2 =>
		let msg = sprintf "Syntax error around line %d\n``%s''\n" i l in
		(report_error msg) fseq
		error "FAIL"
	    |
	    val [raw_old,raw_new] = sl then
	    let old = trim raw_old then
	    let new = trim raw_new then
	    (old,new)
	in
	let sub = (map2 mk_sub (1 upto (length lines)) lines) catch [] in
	sub == [] => (try ()) |
	(sub,(rename_pexlif_wires sub p)) gen_catch
	(\msg. (report_error msg) fseq (try ()))
    in
    val (sub, p') = try () then
    (add_transform canvas p' (RENAME_WIRES sub)) fseq
    let cmd = sprintf "rename_wires vis ...;"  in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_rename_wires;



let fl_do_new_tranf canvas =
    let vfsm = w2vfsm canvas in
    let trfs = get_idv_info canvas then
    let just = map (\(p,ckt,j).j) (butlast trfs) then
    just = [] => T |
    let imp = fst (hd trfs) in
    let spec = fst (last trfs) in
    let spec_sig = pexlif_get_FP spec then
    let tr_name = find_next_anon_transform_name spec_sig then
    let model_name = find_next_anon_name () then
    let cmd = sprintf "idv:name_transform_and_use %s %s %s"
		       canvas tr_name model_name
    then
    let resl = tcl2list (tcl_eval [cmd]) then
    let op = el 1 resl in
    let transform_name = el 2 resl in
    let model_name = el 3 resl in
    op = "Cancel" => F |
    op = "Discard" => T |
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    // Name the implementation pexlif
    val (IDV_RW_DB sname fname mnames tbl) = get_rw_db () then
    (add_model_in_rw_db F model_name imp_sha) fseq
    // Now save the transformation
    let tr = TRANSFORM transform_name spec_sha imp_sha just then
    (record_transformation spec_sig tr) fseq
    op = "Save" => T |
    op = "SaveAndApplyOnce" =>
	val (parent,sell) = get_idv_parent_info canvas then
	let pp = get_idv_current_pexlif parent then
	let pp' = fold_pexlif pp sell "_TMP_" then
	val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (c:cs))) = pp' in
	c == spec =>
	(
	    let p' = PINST nm attrs leaf fa_inps fa_outs ints
			    (P_HIER (imp:cs))
	    then
	    let p'' = unfold_pexlif p' 1 then
	    (add_transform parent p'' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	    in
	    (refresh_idv_canvas parent cmd) fseq T
	)
	|
	eprintf "Parent circuit has changed. Cannot apply the transformation"
    |
    op = "SaveAndApplyEverywhere" =>
	val (parent,sell) = get_idv_parent_info canvas then
	let pp = get_idv_current_pexlif parent then
	let matches = isomatch spec pp then
	let groups = map (map (fst # snd)) matches then
	let nbr_groups = length groups then
	let lbl = "_#*&_&*#_" in
	let pp' = foldn_pexlif pp groups lbl then
	let imps =
	    letrec do_sub (cp:cps) (m:ms) =
		let matches = map (snd # snd) m then
		let subs = map get_match_sub  matches then
		let opt_cp_sub = actualize_hier subs imp cp then
		let cp' =
		    has_value opt_cp_sub =>
			let cp_sub = get_value opt_cp_sub then
			rename_name (pex_subst_actuals imp cp_sub) lbl
		    |
			rename_name cp lbl
		then
		cp' : (do_sub cps ms)
	     /\   do_sub [] [] = []
	    in
	    do_sub (firstn nbr_groups (pexlif_get_children pp')) matches
	then
	val (PINST n attrs lf fa_inps fa_outs ints (P_HIER children)) = pp' then
	let children' = imps@(butfirstn nbr_groups children) then
	let tmp = PINST n attrs lf fa_inps fa_outs ints (P_HIER children') then
	let res = unfold_all_labeled tmp lbl then
	(add_transform parent res (REPLACE sell tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	in
	(refresh_idv_canvas parent cmd) fseq T
    |
    eprintf "Illegal operation '%s'\n" op
;

let get_input_order p =
    let MAX_DEPTH = 100 in
    let ckt = toplevel_pexlif2fsm (flatten_pexlif p) then
    let vinps = inputs ckt in
    let inps = md_expand_vectors vinps in
    let res = ref [] then
    letrec tr depth path nd =
	mem nd inps => (res := ((nd,path):(deref res))) |
	depth > MAX_DEPTH => () |
	let pfn = get_visualization_pfn ckt nd 0 in
	let vfanins = get_visualization_fanins ckt nd 0 in
	let id_vfanins = zip (1 upto length vfanins) vfanins in
	let do (i,(vfi,nds)) =
	    let do1 fi = tr (depth+1) ((int2str i):pfn:path) fi in
	    foreach do1 nds
	in
	foreach do id_vfanins
    in
    let id_vouts =
	let vouts = outputs ckt in
	zip (1 upto length vouts) vouts
    in
    let do (i,vo) =
	let do1 o = tr 1 [(sprintf "o%d" i)] o in
	foreach do1 (md_expand_vector vo)
    in
    (foreach do id_vouts) fseq
    let do l = (fst (hd l)), (setify (map snd l)) in
    let inps = map do (partition fst (deref res)) then
    let sel l =
	let vs = md_extract_vectors (map fst l) then
	let sig = snd (hd l) in
	map (\v. v, sig) vs
    in
    flatmap sel (partition snd inps)
;

let set_equal s1 s2 =
    ((s1 subtract s2) = []) AND ((s2 subtract s1) = [])
;

let check_eq_by_sim p1 p2 =
    let ckt1 = pexlif2fsm (wrap_pexlif p1) then
    let ckt2 = pexlif2fsm (wrap_pexlif p2) then
    let inps1 = md_expand_vectors (inputs ckt1) in
    let inps2 = md_expand_vectors (inputs ckt2) in
    let outs1 = md_expand_vectors (outputs ckt1) in
    let outs2 = md_expand_vectors (outputs ckt2) in
    NOT (set_equal inps1 inps2) => F |
    NOT (set_equal outs1 outs2) => F |
    let ant = map (\n.bT,n, bvariable n, 0, 1) inps1 then
    let trl = map (\n.n,0,1) outs1 then
    let ste1 = bSTE "-s" ckt1 [] ant [] trl then
    let ste2 = bSTE "-s" ckt2 [] ant [] trl then
    let tst n r = 
	r AND ((bget_trace_val ste1 n 0) == (bget_trace_val ste2 n 0))
    in
    itlist tst outs1 T
;

// Try by simply swapping actuals.
let simple_get_specialized_imp spec imp p =
    val (PINST nm1 attr1 lf1 in1 out1 int1 sckt1) = spec in
    val (PINST nm2 attr2 lf2 in2 out2 int2 sckt2) = p in
    length in1 != length in2 => NONE |
    length out1 != length out2 => NONE |
    let in1'  = map2 (\(f1,_).\(f2,a2). f1,a2) in1 in2 then
    let out1' = map2 (\(f1,_).\(f2,a2). f1,a2) out1 out2 then
    let p1' = PINST nm1 attr1 lf1 in1' out1' int1 sckt1 then
    let ok = check_eq_by_sim p p1' then
    NOT ok => NONE |
    val (PINST nm attr lf fa_inps fa_outs ints sckt) = imp in
    let imp' = PINST nm attr lf in1' out1' ints sckt then
    SOME imp'
;

// Find a substitution that makes spec == p.
// If such is found, return imp after applying the same substitution.
let get_specialized_imp spec imp p =
    let ores = simple_get_specialized_imp spec imp p then
    has_value ores => ores |
    val (PINST nm1 attr1 lf1 in1 out1 int1 sckt1) = spec in
    val (PINST nm2 attr2 lf2 in2 out2 int2 sckt2) = p in
    length out1 != length out2 => NONE |
    let spec' = wrap_pexlif spec in
    let p'    = wrap_pexlif p in
    let iorder1 = get_input_order spec' then
    let iorder2 = get_input_order p' then
    let get_info (v,sig) = (md_size v,sig) in
    NOT (set_equal (map get_info iorder1) (map get_info iorder2)) => NONE |
    let mk_sub (spec_v,spec_sig) =
	let p_v = rev_assoc spec_sig iorder2 in
	zip (md_expand_vector spec_v) (md_expand_vector p_v)
    in
    let name_sub = flatmap mk_sub iorder1 then
    let translate (f,as) =
	let as' = map (\n. assoc n name_sub) (md_expand_vectors as) then
	f, (md_extract_vectors as')
    in
    let in1'  = map translate in1 in
    let out1' = map2 (\(f1,_).\(f2,a2). f1,a2) out1 out2 then
    let spec'' = PINST nm1 attr1 lf1 in1' out1' int1 sckt1 then
    NOT (check_eq_by_sim spec'' p') => NONE |
    val (PINST nm attr lf fa_inps fa_outs ints sckt) = imp in
    let fa_inps' = map translate fa_inps in
    let fa_outs' = map2 (\(f1,_).\(f2,a2). f1,a2) out1 out2 then
    let imp' = (PINST nm attr lf fa_inps' fa_outs' ints sckt) then
    SOME imp'
;

let replace_all parent spec imp =
    let raw_matches = internal_isomatch spec parent T then
    // Adjust for incorrect base...
    let matches = map (map (\(i,j).i+1,j+1)) raw_matches then
    let groups = map (map snd) matches then
    let nbr_groups = length groups then
    let lbl = "_#*&_&*#_" in
    let parent' = foldn_pexlif parent groups lbl then
    let children' = pexlif_get_children parent' then
    let to_be_replaced = firstn nbr_groups children' then
    let remain = butfirstn nbr_groups children' then
    let repl1 p =
	let imp' = get_specialized_imp spec imp p then
	has_value imp' => pexlif_rename (get_value imp') lbl | p
    in
    let replacements = map repl1 to_be_replaced then
    let children' = replacements @ remain then
    val (PINST n attrs lf fa_inps fa_outs ints (P_HIER children)) = parent' then
    let tmp = PINST n attrs lf fa_inps fa_outs ints (P_HIER children') then
    unfold_all_labeled tmp lbl
;

let dbg_spec = ref {(error "N/A") :: pexlif};
let dbg_imp = ref {(error "N/A") :: pexlif};
let dbg_parent = ref {(error "N/A") :: pexlif};

let fl_do_replacement canvas =
    let vfsm = w2vfsm canvas then
    let w = vfsm2id vfsm then
    let sell = get_selected_pinsts canvas then
    let parent = get_idv_current_pexlif canvas then
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif parent sell "_TMP_" then
    val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (p:ps))) = p' in
    let signature = pexlif_get_FP p then
    let dbs = (deref cur_idv_rw_transform_db)@
	      (deref cur_idv_readonly_transform_dbs)
    then
    let get_alts db =
	let tbl = db_tbl db then
	NOT (tbl_member tbl signature) => [] |
	map (\t. (db,t)) (tbl_get tbl signature)
    then
    let alts = flatmap get_alts dbs then
    let tr_names = map (\(db,(TRANSFORM name _ _ _)). name) alts then
    let pre = sprintf "idv:select_replacement %s {" canvas in
    let cmd = list2str T pre " " "}" id tr_names then
    val [op, sidx] = tcl2list (tcl_eval [cmd]) then
    op = "Cancel" => () |
    let idx = (sscanf "%d" sidx)+1 then
    val (db,tr) = el idx alts then
    val (TRANSFORM name sha_spec sha_imp just) = tr then
    let spec = idv_load_pexlif (db_sname db) sha_spec then
    let imp  = idv_load_pexlif (db_sname db) sha_imp then
    op = "ApplyOnce" =>
	let o_imp' = get_specialized_imp spec imp p then
	has_value o_imp' =>
	(
	    let imp' = get_value o_imp' then
	    let p' =
		PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (imp' : ps))
	    then
	    let p'' = unfold_pexlif p' 1 then
	    (add_transform canvas p'' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) name
	    in
	    (refresh_idv_canvas canvas cmd)
	)
	|
	eprintf "Transformation spec not an exact match in %s" op
    |
    op = "ApplyEverywhere" =>
(dbg_imp := imp) fseq
(dbg_spec := spec) fseq
(dbg_parent := parent) fseq
	let res = replace_all parent spec imp then
	(add_transform canvas res (REPLACE_ALL tr)) fseq
	let cmd = sprintf "replace_all vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) name
	in
	(refresh_idv_canvas canvas cmd)
    |
    eprintf "Illegal operation '%s'\n" op
;
export_to_tcl fl_do_replacement;

let make_theorem transform_name spec imp =
    spec fseq imp fseq
    let signature = pexlif_get_FP spec then
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    let tr = TRANSFORM transform_name spec_sha imp_sha [MK_THM] then
    (record_transformation signature tr)
;

