//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------
let Init_idv_gui = tcl_eval [sprintf "source %sidv.tcl" DIR];
Init_idv_gui;

let idv_gui_cnt_ref = ref 0;
let mk_idv_gui_window {dummy::void} =
    let idx = deref idv_gui_cnt_ref + 1 then
    (idv_gui_cnt_ref := idx) fseq
    sprintf ".idv_gui_%d" idx
;
non_lazy mk_idv_gui_window;

lettype idv_trfm_info =
    IDV_TRANSFORM_INFO
	{model_names :: (string#string) list}	// (name#sha256_sig) list
	{trfms :: ((int#transform list) list)}	// signature#(transform list)
;

let cur_idv_rw_transform_db =
    // (sname, fname, mnames, transform_tbl)
    ref {[]::(string#
	      string#
	      ((string#string) list)#
	      ({int,transform list} tbl)
	     ) list}
;

let CHECK_FOR_RW_DB {dummy::void} =
    (deref cur_idv_rw_transform_db) != [] => () |
    eprintf "No IDV r/w database open."
;

let get_rw_db {dummy::void} =
    let cur_tbls = deref cur_idv_rw_transform_db then
    (cur_tbls = []) => eprintf "No IDV r/w database open." |
    (length cur_tbls > 1) => eprintf "More than one IDV r/w table open???" |
    hd cur_tbls
;
non_lazy get_rw_db;


let cur_idv_readonly_transform_dbs =
    // [(sname, fname, transform_tbl)] 
    ref {[]::(string#
	      string#
	      ((string#string) list)#
	      ({int,transform list} tbl)
	     ) list}
;


//
// Much too simplistic and (fatally) not guaranteed to be valid!
//
letrec equal_pexlif (PINST nm1 attr1 lf1 in1 out1 int1 (P_HIER ch1))
		    (PINST nm2 attr2 lf2 in2 out2 int2 (P_HIER ch2)) =
    (find_signature attr1 == find_signature attr2) => T |
    (find_fingerprint attr1 != find_fingerprint attr2) => F |
    (length ch1) != (length ch2) => F |
    (length in1) != (length in2) => F |
    (length out1) != (length out2) => F |
    (length int1) != (length int2) => F |
    let mk_sub sp1 sp2 =
	val (PINST snm1 sattr1 slf1 sin1 sout1 sint1 sbody1) = sp1 in
	val (PINST snm2 sattr2 slf2 sin2 sout2 sint2 sbody2) = sp2 in
	NOT (equal_pexlif sp1 sp2) => (F,[]) |
	let ainp1 = md_expand_vectors (flatmap snd sin1) in
	let ainp2 = md_expand_vectors (flatmap snd sin2) in
	let aout1 = md_expand_vectors (flatmap snd sout1) in
	let aout2 = md_expand_vectors (flatmap snd sout2) in
	let sub = setify ((zip ainp1 ainp2)@(zip aout1 aout2)) then
	let idx = find_first0 (\l. length l > 1) (partition fst sub) in
	idx = 0 => (T,sub) | (F,[])
    in
    let subs = map2 mk_sub ch1 ch2 then
    let idx = find_first (\p. NOT (fst p)) subs in
    idx != 0 => F |
    let sub = setify (flatmap snd subs) then
    let idx = find_first0 (\l. length l > 1) (partition fst sub) in
    idx = 0
 /\    equal_pexlif _ _ = F
;


let get_idv_candidates p =
    let signature = pexlif_get_FP p then
    let get_cand (db,_,_,tbl) =
	tbl_member tbl signature => [(db,(tbl_get tbl signature))] | []
    in
    let pots = flatmap get_cand ((deref cur_idv_rw_transform_db)@
				 (deref cur_idv_readonly_transform_dbs))
    then
    let check (db,alts) =
	let same_spec (TRANSFORM name spec imp just) =
	    let ps = read_pexlif spec then
	    equal_pexlif p ps
	in
	let alts' = filter same_spec alts then
	alts' = [] => [] | [(db,alts')]
    in
    flatmap check pots
;


let record_transformation signature tr =
    val (sname,fname,mnames,tbl) = get_rw_db () then
    let old = tbl_member tbl signature => tbl_get tbl signature | [] then
    let new = tr:old then
    let tbl' = tbl_member tbl signature => tbl_delete tbl signature | tbl then
    let tbl'' = tbl_insert tbl' signature new then
    (cur_idv_rw_transform_db := [(sname,fname,mnames,tbl'')])
;

let load_idv_db sname fname =
    let db_file = sprintf "%s/transform_db" fname then
    NOT (file_exists db_file) => (sname,fname,[], list2tbl []) |
    val (IDV_TRANSFORM_INFO mnames sig_trfs) = read_idv_trfm_info db_file then
    (sname, fname, mnames, list2tbl sig_trfs)
;

let fl_save_idv_db {w::string} =
    let dbl = deref cur_idv_rw_transform_db then
    dbl = [] => () |
    val (sname,fname,mnames, tbl) = hd dbl then
    let sig_transf_list = tbl2list tbl then
    let data = IDV_TRANSFORM_INFO mnames sig_transf_list then
    let db_file = sprintf "%s/transform_db" fname then
    (NOT (file_exists db_file) => () |
	system (sprintf "/bin/mv -f %s %s.bkp" db_file db_file) fseq ()
    ) fseq
    (write_idv_trfm_info db_file data) fseq 
    // Remove lock file
    let cmd = sprintf "/bin/rm -f %s/lock" fname in
    (system cmd) fseq
    (cur_idv_rw_transform_db := [])
;
export_to_tcl fl_save_idv_db;

let open_idv_db dir readonly =
    NOT readonly AND ((deref cur_idv_rw_transform_db) != []) =>
	eprintf "Only one r/w IDV database can be open at the same time"
    |
    let do_cmd cmd =
	let status = system cmd then
	status = 0 => () |
	eprintf "FAILURE: %s\n" cmd
    in
    let full_name = tcl_eval ["file normalize "^dir] then
    let my_host = hd (snd (exec "hostname")) then
    let my_pid  = pid then
    NOT (file_exists full_name) =>
	readonly => eprintf "%s is not a readable IDV database" dir |
	(do_cmd (sprintf "mkdir %s" dir)) fseq
	(do_cmd (sprintf "mkdir %s/pexlifs" dir)) fseq
	let fp = fopen (sprintf "%s/lock" full_name) "w" then
	(fprintf fp "%s|%d" my_host my_pid) fseq
	(fclose fp) fseq
	(cur_idv_rw_transform_db := [(dir,full_name,[],(tbl_create 100))])
    |
    // Check that the DB looks ok
    let check_file file =
	file_exists (sprintf "%s/%s" full_name file) => () |
	eprintf "IDV database corrupted. Missing %s\n" file
    in
    (check_file "pexlifs") fseq
    readonly =>
	let db_info = load_idv_db dir full_name then 
	let cur_dbs = deref cur_idv_readonly_transform_dbs then
	(cur_idv_readonly_transform_dbs := (db_info:cur_dbs))
    |
    // For read/write data bases, check that no active lock exists
    let lockfile = sprintf "%s/lock" full_name then
    // Make sure DB isn't locked by a running process
    (NOT (file_exists lockfile) => () |
	let fp = fopen lockfile "r" then
	let line = fgets fp then
	let parts = str_split line "|" then
	(fclose fp) fseq
	length parts != 2 => eprintf "Corrupted lockfile (%s)" line |
	val [lhost,lpid] = parts in
	let lpid_alive =
	    (snd (exec (sprintf "ps --no-headers --pid %s" lpid))) != []
	then
	lhost == my_host AND lpid_alive =>
	    eprintf "IDV_DB %s is owned by running process %s" full_name lpid
	| 
	(fprintf stdout "-I-: removing lockfile since owner no longer alive\n")
	fseq
	(do_cmd (sprintf "/bin/rm -f %s" lockfile)) 
    ) fseq
    // Write lockfile
    let fp = fopen (sprintf "%s/lock" full_name) "w" then
    (fprintf fp "%s|%d" my_host my_pid) fseq
    (fclose fp) fseq
    let db_info = load_idv_db dir full_name then 
    (cur_idv_rw_transform_db := [db_info])
;

let get_idv_db_dir {dummy::void} =
    val (sname,fname,mnames,trfs_tbl) = get_rw_db () then
    fname
;
non_lazy get_idv_db_dir;

let is_rw_db db_name =
    val (sname,fname,mnames,tbl) = get_rw_db () then
    db_name == sname
;

let get_db_info db_name =
    let pot_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let idx = find_first0 (\t. fst t = db_name) pot_dbs in
    idx = 0 => eprintf "Cannot find %s in %S" db_name (map fst pot_dbs) |
    el idx pot_dbs
;

let get_db_dir db_name =
    val (sname,fname,mnames,tbl) = get_db_info db_name then
    fname
;

let get_db_mnames db_name =
    val (sname,fname,mnames,tbl) = get_db_info db_name then
    mnames
;

let get_db_transf_tbl db_name =
    val (sname,fname,mnames,tbl) = get_db_info db_name then
    tbl
;

let idv_save_pexlif p =
    let sha = pexlif_get_SHA p then
    let db_dir = get_idv_db_dir () then
    let file = sprintf "%s/pexlifs/%s" db_dir sha in
    file_exists file => sha |
    (write_pexlif file p fseq sha)
;


let idv_load_pexlif db p_sha =
    let db_dir = get_db_dir db then
    let file = sprintf "%s/pexlifs/%s" db_dir p_sha in
    file_exists file => read_pexlif file |
    eprintf "Failed to load %s. IDV database corrupted?" file
;


let cur_transf_windowsr = ref {[]:: (string#vfsm) list};

let get_new_idv_window {dummy :: void} =
    let l = length (deref cur_transf_windowsr) then
    sprintf ".idv_%d" l
;
non_lazy get_new_idv_window;

let get_number_of_children (PINST _ _ _ _ _ _ (P_HIER chs)) =
    length chs
 /\ get_number_of_children other = 0
;

let refresh_idv_canvas canvas cmd =
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent sell rvis rtrf) = evis then
    let trf = get_idv_info canvas then
    val (p,ckt,_) = hd trf in
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    (rvis := vis) fseq
    (rtrf := trf) fseq
    (add_command vfsm cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas
              ]) fseq
    ()
;


let accurate_toplevel_pexlif2fsm p =
    let old = update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" "TRUE" then
    let res = toplevel_pexlif2fsm p then
    (update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" old) fseq
    res
;

let start_new_transform p start_new w =
    let p = start_new => remove_wrappers p | p then
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    //
    let vfsm = w2vfsm w then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" then
    let cmd = "DUMMY" in
    let evis = TR_SEQ "" [] (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c
	      ]
    ) fseq
    ()
;

let IDV rw_database read_only_dbs =
    // Open the databases
    (open_idv_db rw_database F) fseq
    (foreach (\db. open_idv_db db T) read_only_dbs) fseq
    // Start GUI
    let w = get_new_idv_window () then
    (tcl_eval [sprintf "idv:create_idv_gui %s" w]) fseq
    let vfsm = IDV_ENV w (ref []) (ref []) (ref []) (ref []) (ref []) in
    (cur_vfsm := (vfsm:(deref cur_vfsm))) fseq
    (register_vfsm vfsm w) fseq
    (cur_transf_windowsr := ((w,vfsm):(deref cur_transf_windowsr))) fseq
    ()
;




let add_transform canvas p tr =
    let vfsm = w2vfsm canvas in
    let ckt = accurate_toplevel_pexlif2fsm p then
    let trfsr = get_idv_info_r canvas then
    (trfsr := ((p,ckt,tr):(deref trfsr))) fseq
    ()
;
non_lazy add_transform;

let fl_is_toplevel_transform canvas =
    val (parent,sell) = get_idv_parent_info canvas then
    parent == ""
;
export_to_tcl fl_is_toplevel_transform;


let idv_finish_transformation canvas =
    let vfsm = w2vfsm canvas in
    let trfs = get_idv_info canvas then
    let just = map (\(p,ckt,j).j) (butlast trfs) then
    just = [] => () |
    let resl = tcl2list (tcl_eval ["idv:name_transform_and_use "^canvas]) then
    let op = el 1 resl in
    let transform_name = el 2 resl in
    let model_name = el 3 resl in
    op = "Cancel" => () |
    let imp = fst (hd trfs) in
    let spec = fst (last trfs) in
    let imp_sha  = idv_save_pexlif imp then
    let spec_sha = idv_save_pexlif spec then
    let spec_fp = pexlif_get_FP spec then
    let tr = TRANSFORM transform_name spec_sha imp_sha just then
    (record_transformation spec_fp tr) fseq
    op = "Save" => () |
    op = "SaveAndApplyOnce" =>
	val (parent,sell) = get_idv_parent_info canvas then
	let tab = tcl_eval [sprintf "nb:c2tab %s %s" (vfsm2id vfsm) parent] then
	let pp = get_idv_current_pexlif parent then
	let pp' = fold_pexlif pp sell "_TMP_" then
	val (PINST nm attrs leaf fa_inps fa_outs ints (P_HIER (c:cs))) = pp' in
	c == spec =>
	    let p' = PINST nm attrs leaf fa_inps fa_outs ints
			    (P_HIER (imp:cs))
	    then
	    let p'' = unfold_pexlif p' 1 then
	    (add_transform parent p'' (REPLACE sell tr)) fseq
	    let cmd = sprintf "replace vis %s \"%s\";"
			  (list2str T "[" "," "]" int2str sell) transform_name
	    in
	    refresh_idv_canvas parent cmd
	|
	eprintf "Parent circuit has changed. Cannot apply the transformation"
    |
    op = "SaveAndApplyEverywhere" =>
	(fprintf stderr "Save & Apply Everywhere\n")
    |
    eprintf "Illegal operation '%s'\n" op
;

let get_selected_pinsts canvas =
    let vfsm = w2vfsm canvas in
    let selection = deref (vfsm2selection_r vfsm) then
    let all_sels = md_expand_vectors selection in
    let ckt = get_idv_current_fsm canvas then
    let nd2pinst n = [(get_visualization_pinst_cnt ckt n 0)] catch [] in
    setify (flatmap nd2pinst all_sels)
;


let fl_do_fold canvas name =
    let name' = "draw_hier "^name then
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    let p = get_idv_current_pexlif canvas then
    let p' = fold_pexlif p il name' then
    (add_transform canvas p' (FOLD il name')) fseq
    let cmd = sprintf "fold vis %s \"%s\";"
		      (list2str T "[" "," "]" int2str il) name
    in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_fold;

let fl_do_unfold canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    length il > 1 => 
	report_error "Can only unfold one instance at a time"
    |
    let p = get_idv_current_pexlif canvas then
    let p' = unfold_pexlif p (hd il) then
    (add_transform canvas p' (UNFOLD (hd il))) fseq
    let cmd = sprintf "unfold vis %d;" (hd il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_unfold;

let fl_do_flatten canvas =
    let vfsm = w2vfsm canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = flatten_pexlif p then
    (add_transform canvas p' FLATTEN) fseq
    let cmd = sprintf "flatten vis;" in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_flatten;

let fl_do_idv_undo canvas =
    let vfsm = w2vfsm canvas then
    let trfsr = get_idv_info_r canvas then
    let trfs = deref trfsr then
    length trfs <= 1 => () |
    let trfs' = tl trfs then
    (trfsr := trfs') fseq
    val (p,ckt,_) = hd trfs' in
    let vfsm = w2vfsm canvas then
    let canvas_list = deref (vfsm2canvases_r vfsm) then
    let evis = snd (find (\p. fst p = canvas) canvas_list) then
    val (TR_SEQ parent sell rvis rtrf) = evis then
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    (rvis := vis) fseq
    (rtrf := trfs') fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "set old_zoom $::cur_zoom_factor(%s)" canvas,
		sprintf "set_zoom_factor %s 100.0" canvas,
                sprintf "%s delete all" canvas,
                sprintf "draw_network %s $%s" canvas final_res,
                "update",
		sprintf "set_zoom_factor %s $old_zoom" canvas,
                sprintf "set_scrollregion %s" canvas
              ]) fseq
    ()
;
;
export_to_tcl fl_do_idv_undo;




let duplicate_instance p id =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
    let cur_nds = ref
        (setify (md_expand_vectors ((map fst fa_inps)@(map fst fa_outs)@ints)))
    in
    let selected = el id chs in
    val (PINST dname dattrs dleaf dfa_inps dfa_outs dints dcont) = selected in
    let driven_nds = md_expand_vectors (flatmap snd dfa_outs) in 
    let driven_vecs = md_extract_vectors driven_nds in
    let copies = ref [] in
    let new_ints = ref [] in
    let try_assoc key l = (assoc key l) catch key in
    let rename sub as =
        md_merge_vectors (map (\a.try_assoc a sub) (md_expand_vectors as))
    in
    letrec get_next_names cnt =
	cnt = 0 => (copies := (selected:(deref copies))) fseq [] |
	let test = map (sprintf "#%d_%s" cnt) driven_nds in
	(test intersect (deref cur_nds)) != [] => get_next_names (cnt+1) |
	(cur_nds := (test @ (deref cur_nds))) fseq
	let sub = zip driven_nds test in
	let new_int = md_extract_vectors test then
	(new_ints := (new_int@(deref new_ints))) fseq
	let dfa_outs' = map (\(f,as). f, rename sub as) dfa_outs in
	let copy = PINST dname dattrs dleaf dfa_inps dfa_outs' dints dcont then
	(copies := (copy:(deref copies))) fseq
        sub
    in
    let process sp =
        val (PINST lname lattrs lleaf lfa_inps lfa_louts lints lcontent) = sp in
        let depend_nds = md_expand_vectors (flatmap snd lfa_inps) then
        let overlap = depend_nds intersect driven_nds in
        overlap = [] => sp |
        let sub = get_next_names (length (deref copies)) then
        let lfa_inps' = map (\(f,as). f, rename sub as) lfa_inps then
        (PINST lname lattrs lleaf lfa_inps' lfa_louts lints lcontent)
    in
    let chs' = map process chs then
    let all_chs = (deref copies)@chs' then
    let ints' = ints@(deref new_ints) then
    PINST name attrs leaf fa_inps fa_outs ints' (P_HIER all_chs)
;       


let fl_do_duplicate canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    il = [] => () |
    length il > 1 => 
	report_error "Can only duplicate one instance at a time"
    |
    let p = get_idv_current_pexlif canvas then
    let p' = duplicate_instance p (hd il) then
    (add_transform canvas p' (DUPLICATE (hd il))) fseq
    let cmd = sprintf "duplicate vis %d;" (hd il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_duplicate;




let mk_buf inps outs =
    let vinps = md_merge_vectors inps in
    let vouts = md_merge_vectors outs in
    let sz = md_sizes vinps in
    md_sizes vouts != sz => error "Length mismatch in mk_buf" |
    let p = (W_VAR sz "o") <- (W_VAR sz "i") in
    val (PINST name attrs leaf [(fi,_)] [(fo,_)] ints body) = p in
    PINST name attrs leaf [(fi,vinps)] [(fo,vouts)] ints body
;

let merge_instances p ids =
    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs)) = p in
    let sels = map (\i. el i chs) ids in
    length sels <= 1 => p |
    let remain = chs subtract sels in
    let master = hd sels in
    let victims = tl sels in
    // Make sure all victims are the same as the master
    let not_identical_pexlif p1 p2 =
	pexlif_get_SHA p1 != pexlif_get_SHA p2 => T |
	val (PINST _ _ _ fa_inps1 fa_outs1 _ _) = p1 in
	val (PINST _ _ _ fa_inps2 fa_outs2 _ _) = p2 in
	let cmp (f1,as1) (f2,as2) = strcmp f1 f2 in
	let i1 = qsort cmp fa_inps1 in
	let i2 = qsort cmp fa_inps2 in
	i1 != i2
    in
    let idx = find_first0 (not_identical_pexlif master) victims then
    idx != 0 => 
	report_error "Not all selected instances are identical" fseq p
    |
    let get_fa_out (PINST _ _ _ _ fa_outs _ _) = fa_outs in
    let master_sub = get_fa_out master in
    let mk_sub vp =
	let v_fa_outs = get_fa_out vp then
	let mk (vf,vas) =
	    let mas = assoc vf master_sub in
	    zip (md_expand_vectors vas) (md_expand_vectors mas) 
	in
	flatmap mk v_fa_outs
    in
    let subs = flatmap mk_sub victims then
    let rename a = (assoc a subs) catch a in
    let rename_fa fa =
	let rename1 (f,as) =
	    f, (md_merge_vectors (map rename (md_expand_vectors as)))
	in
	map rename1 fa
    in
    let rename_pexlif (PINST name attrs leaf fa_inps fa_outs ints body) =
	let fa_inps' = rename_fa fa_inps in
	let fa_outs' = rename_fa fa_outs in
	(PINST name attrs leaf fa_inps' fa_outs' ints body)
    in
    // Build new pexlif
    let chs = map rename_pexlif (master:remain) in
    let mk_wire (f,as) =
	let nds = md_expand_vector f in
	let nds' = map rename nds in
	nds' = nds => [] |
	// Must add a buffer since multiple outputs are now driven
	// by the same signal
	[mk_buf nds' nds]
    in
    let buffers = flatmap mk_wire (fa_outs) then
    let chs' = buffers@chs then
    // TODO: Clean up "ints"
    (PINST name attrs leaf fa_inps fa_outs ints (P_HIER chs'))
;


let fl_do_merge canvas =
    let vfsm = w2vfsm canvas then
    let il = get_selected_pinsts canvas then
    let p = get_idv_current_pexlif canvas then
    let p' = merge_instances p il then
    (add_transform canvas p' (MERGE il)) fseq
    let cmd = sprintf "merge vis %s;" (list2str T "[" "," "]" int2str il) in
    refresh_idv_canvas canvas cmd
;
export_to_tcl fl_do_merge;

let fl_do_new_tranf canvas =
    let vfsm = w2vfsm canvas then
    let w = vfsm2id vfsm then
    let il = get_selected_pinsts canvas then
    let parent = get_idv_current_pexlif canvas then
    // This code relies on fold_pexlif putting the new instance first!!!!
    let p' = fold_pexlif parent il "_TMP_" then
    val (PINST _ _ _ _ _ _ (P_HIER chs)) = p' in
    let p = el 1 chs then
    //
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    let vis = visualize_fanin ckt [] [] 100 outs 0 then
    val (tab_window, c) = get_new_sch_canvas w 0 "" then
    let cmd =
	let tab = canvas2tab c then
	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") outs in
	sprintf "OBSOLETE: let %s = draw_fanin vis (%d) %d %s;\n%s;"
		 tab 0 100 svecs tab
    in
    let evis = TR_SEQ canvas il (ref vis) (ref [(p,ckt,SPEC)]) then
    (add_active_sch_tab_window vfsm c evis cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
		sprintf "%s delete all" c,
		sprintf "draw_network %s $%s" c final_res,
		"update",
		sprintf "set_scrollregion %s" c
	      ]) fseq
    ()
;
export_to_tcl fl_do_new_tranf;

let find_next_anon_name mnames =
    let anons = map fst (filter (\p. str_is_prefix "anon_" (fst p)) mnames) in
    let next = 
	anons = [] => 1 |
	let indices = qsort (defix -) (map (sscanf "anon_%d") anons) in
	(last indices) + 1
    in
    sprintf "anon_%d" next
;

let fl_model_name_used name =
    val (sname,fname,mnames,tbl) = get_rw_db () then
    let idx = find_first0 (\p. fst p = name) mnames then
    idx != 0
;
export_to_tcl fl_model_name_used;

let fl_do_name_model canvas name version =
    val (sname,fname,mnames,tbl) = get_rw_db () then
    let idx = find_first0 (\p. fst p = name) mnames then
    (idx != 0) => eprintf "Model %s already exists" name |
    let name = (name != ".") => name | find_next_anon_name mnames then
    let trfs = get_idv_info canvas then
    let p = fst (version = "specification" => (last trfs) | (hd trfs)) then
    let p_sha  = idv_save_pexlif p then
    let mnames' = (name,p_sha):mnames then
    (cur_idv_rw_transform_db := [(sname,fname,mnames', tbl)]) fseq
    ()
;
export_to_tcl fl_do_name_model;

let fl_idv_get_db_names {canvas::string} =
    map fst ((deref cur_idv_rw_transform_db)@
	     (deref cur_idv_readonly_transform_dbs))
;
export_to_tcl fl_idv_get_db_names;

let fl_get_idv_models {canvas::string} db pat =
    let mnames = get_db_mnames db then
    let matches =  filter (\p. str_match pat (fst p)) mnames then 
    map fst matches
;
export_to_tcl fl_get_idv_models;

let get_transform_fanout p =
    let p_fp = pexlif_get_FP p then
    let all_dbs = (deref cur_idv_rw_transform_db)@
		  (deref cur_idv_readonly_transform_dbs)
    then
    let get_fanout (sname,fname,mnames,tbl) =
	let get_info (TRANSFORM name sha_spec sha_imp just) =
	    let id = sprintf "  %s:%s" sname name in
	    let dest = (rev_assoc sha_imp mnames) catch "-" in
	    (id, dest, (idv_load_pexlif sname sha_imp))
	in
	map get_info (tbl_member tbl p_fp => tbl_get tbl p_fp | [])
    in
    flatmap get_fanout all_dbs
;


let fl_do_new_toplevel_tranf {w::string} db name =
    (CHECK_FOR_RW_DB ()) fseq
    let mnames = get_db_mnames db then
    let p_sha = assoc name mnames then
    let p = idv_load_pexlif db p_sha then
    (start_new_transform p F w) fseq
    (tcl_eval ["update"]) fseq
    is_rw_db db => () |
    (tcl_eval [sprintf "idv:name_and_save_model %s specification %s" w name])
    fseq ()
;
export_to_tcl fl_do_new_toplevel_tranf;


let fl_display_transform_tree canvas db name =
    let mnames = get_db_mnames db then
    let p_sha = assoc name mnames then
    let p = idv_load_pexlif db p_sha then
    let done = ref [] in
    let vertices = ref [] in
    let edges = ref [] in
    let vertex_map = ref [] in
    let edge_map = ref [] in
    letrec fanout_rec name p =
	let idx = find_first0 (\pp. fst pp == p) (deref done) then
	idx != 0 => snd (el idx (deref done)) |
	let vertex_name = sprintf "n%d" (length (deref done)) then
	(vertex_map := ((vertex_name,name):(deref vertex_map))) fseq
	let dc = sprintf "%s [shape=box, width=0.10, height=0.10, fillcolor=yellow, fixedsize=shape, label = \"%s\"]\n"
			vertex_name vertex_name
	then
	(vertices := (dc:(deref vertices))) fseq
	(done := ((deref done)@[(p,vertex_name)])) fseq
	let next_states = get_transform_fanout p then
	let mk_edge (trans_name, dest_name, p_dest) =
	    let dest = fanout_rec dest_name p_dest then
	    let edge_name = sprintf "e%d" (length (deref edges)) then
	    (edge_map := ((edge_name, trans_name):(deref edge_map))) fseq
	    let edge = sprintf "%s -> %s [ label = \"%s\" ];\n"
			       vertex_name dest edge_name
	    then
	    (edges := (edge:(deref edges)))
	in
	(foreach mk_edge next_states) fseq
	vertex_name
    in
    let res = fanout_rec name p then
    //
    let fp = mktemp "transform_draw" then
    let file = stream2filename fp then
    (fprintf fp "digraph transform_tree {\n") fseq
    (fprintf fp "rankdir=TB;\n") fseq
    (fprintf fp "size=\"8,5\"\n") fseq
    (foreach (fprintf fp "%s") (deref vertices)) fseq
    (foreach (fprintf fp "%s") (deref edges)) fseq
    (fprintf fp "}\n") fseq
    (fclose fp) fseq
    //
    (tcl_eval ["catch {unset ::idv_transf_node_map}"]) fseq
    let mk_ndmap (n,nn) =
	let cmd = sprintf "set ::idv_transf_node_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_ndmap (deref vertex_map)) fseq
    //
    (tcl_eval ["catch {unset ::idv_transf_edge_map}"]) fseq
    let mk_ndmap (n,nn) =
	let cmd = sprintf "set ::idv_transf_edge_map(%s) {%s}" n nn in
	(tcl_eval [cmd]) fseq ()
    in
    (foreach mk_ndmap (deref edge_map)) fseq
    //
    (tcl_eval [sprintf "idv:show_transformations %s %s" file canvas]) fseq
    ()
;
export_to_tcl fl_display_transform_tree;

//let fl_do_replacement canvas =
//    let vfsm = w2vfsm canvas then
//    let w = vfsm2id vfsm then
//    let il = get_selected_pinsts canvas then
//    let parent = get_idv_current_pexlif canvas then
//    // This code relies on fold_pexlif putting the new instance first!!!!
//    let p' = fold_pexlif parent il "_TMP_" then
//    val (PINST name attrs leaf fa_inps fa_outs ints (P_HIER (p:ps))) = p' in
//    let signature = pexlif_get_FP p then
//    
//
//
//
//
//
//
//    //
//    let old = update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" "TRUE" then
//    let ckt = toplevel_pexlif2fsm p then
//    (update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" old) fseq
//    let outs = outputs ckt then
//    let vis = visualize_fanin ckt [] [] 100 outs 0 then
//    val (tab_window, c) = get_new_sch_canvas w 0 "" then
//    let cmd =
//	let tab = canvas2tab c then
//	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") outs in
//	sprintf "OBSOLETE: let %s = draw_fanin vis (%d) %d %s;\n%s;"
//		 tab 0 100 svecs tab
//    in
//    let evis = TR_SEQ canvas il (ref vis) (ref [(p,ckt,SPEC)]) then
//    (add_active_sch_tab_window vfsm c evis cmd) fseq
//    val (final_res, cmds) = visualisation2tcl vis then
//    (big_tcl_eval ("create_sch":cmds)) fseq
//    (tcl_eval [
//		sprintf "%s delete all" c,
//		sprintf "draw_network %s $%s" c final_res,
//		"update",
//		sprintf "set_scrollregion %s" c
//	      ]) fseq
//    ()
//;
//export_to_tcl fl_do_new_tranf;
