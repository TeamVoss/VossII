//-------------------------------------------------------------------
// Copyright 2020 Carl-Johan Seger
// SPDX-License-Identifier: Apache-2.0
//-------------------------------------------------------------------

let DBG_timing = F;

//let visualize_fanin ckt l1 l2 i1 l3 i2 =
//    DBG_timing => 
//	(fprintf stderr "start visualize_fanin\n") fseq
//	val (res,t) = wtime (visualize_fanin ckt l1 l2 i1 l3 i2) then
//	(fprintf stderr "visualize_fanin: %s\n" t) fseq
//	res
//    |
//	visualize_fanin ckt l1 l2 i1 l3 i2
//;

clet accurate_toplevel_pexlif2fsm p =
    let old1 = update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" "TRUE" then
    let old2 = update_vossrc "VERBOSE-TOPLEVEL-FA-MISMATCH" "FALSE" then
    let res = toplevel_pexlif2fsm p then
    (update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" old1) fseq
    (update_vossrc "VERBOSE-TOPLEVEL-FA-MISMATCH" old2) fseq
    res
;

let accurate_pexlif2fsm p =
    let old1 = update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" "TRUE" then
    let old2 = update_vossrc "VERBOSE-TOPLEVEL-FA-MISMATCH" "FALSE" then
    let res = pexlif2fsm p then
    (update_vossrc "ACCURATE-HIERARCHY-VISUALIZATION" old1) fseq
    (update_vossrc "VERBOSE-TOPLEVEL-FA-MISMATCH" old2) fseq
    res
;

let idv_visualize_fanin p =
    let ckt = accurate_toplevel_pexlif2fsm p then
    let outs = outputs ckt then
    let props = assertions ckt then
    visualize_fanin ckt [] [] 100 (outs@props) 0
;

let visualisation2tcl vis =
    DBG_timing => 
	(fprintf stderr "start visualisation2tcl\n") fseq
	val (res,t) = wtime (visualisation2tcl vis) then
	(fprintf stderr "visualisation2tcl: %s\n" t) fseq
	res
    |
	visualisation2tcl vis
;

let tcl_eval l =
    DBG_timing =>
	val (res,t) = wtime (tcl_eval l) then
	(fprintf stderr "tcl_eval program of length %d: %s\n" (length l) t) fseq
	((sscanf "%d" t) < 10 => () | (fprintf stderr "tcl_pgm\n%S\n" l)) fseq
	res
    |
	tcl_eval l
;
non_lazy tcl_eval;


let Init_sch_draw =
  (tcl_eval [
   sprintf "set ::imagedir %s%s" DIR "images",
   sprintf
     "load %s../../../../schematic_draw_module.so"
     DIR,
   sprintf "source %s/draw_sch.tcl" DIR,
   sprintf "source %s/waveform.tcl" DIR
  ]) fseq ()
;
NOT noX => Init_sch_draw | ();

let dbg_tcl_eval l =
    (fprintf stderr "CMDS:\n") fseq
    (foreach (fprintf stderr "%s\n") l) fseq
    (tcl_eval l)
;
non_lazy dbg_tcl_eval;

let big_tcl_eval l =
    length l < 10 => tcl_eval l |
    let fp = mktemp "tcl_eval" then
    (foreach (fprintf fp "%s\n") l) fseq
    let filename = stream2filename fp then
//    (fprintf fp "exec /bin/rm -f %s\n" filename) fseq
    (fclose fp) fseq
    let cmd = tcl_eval [sprintf "source %s" filename] in
    DBG_timing =>
	val (res,t) = wtime cmd then
	(fprintf stderr "big_tcl_eval for %d lines: %s\n" (length l) t) fseq
	res
    |
    cmd
;
non_lazy big_tcl_eval;

let Create_Dummy_Placement =
    (tcl_eval ["catch {destroy .c9999999}",
          "frame .c9999999",
          "frame .c9999999.cc",
          "set ::dummy_canvas [canvas .c9999999.cc.c]",
          "set cur_zoom_factor(.c9999999.cc.c) 100.0",
          "set ::sc(.c9999999.cc.c) $::base_sc",
          "set ::tfont(.c9999999.cc.c) $::base_tfont",
          "set ::mfont(.c9999999.cc.c) $::base_mfont",
          "set ::sfont(.c9999999.cc.c) $::base_sfont",
	  "set ::avg_char_width [get_accurate_text_width .c9999999.cc.c x]"
         ]) fseq
    ()
;
NOT noX => Create_Dummy_Placement | ();

// -------------------------------------------------------------

let cur_canvas = ref "";

let get_current_canvas {dummy::void} = (deref cur_canvas);
non_lazy get_current_canvas;

let fl_set_current_tab_selected {w::string} {c::string} =
    let cc = c^".cc.c" then
    (cur_canvas := cc)
;
export_to_tcl fl_set_current_tab_selected;

let w2root w = "."^(el 2 (str_split w "."));


let cur_vfsm = ref {[]:: vfsm list};

let w2vfsm_ref = ref {[]:: (string#vfsm) list};

let register_vfsm vfsm canvas =
    let w = w2root canvas then
    let old = filter (\p. fst p != w) (deref w2vfsm_ref) then
    (w2vfsm_ref := ((w,vfsm):old))
;
non_lazy register_vfsm;

let dassoc cmd key al =
    (assoc key al) catch
    (eprintf "Cannot find %s in %S when doing %s\n" key (map fst al) cmd)
;

let w2vfsm canvas =
    let root = w2root canvas then
    dassoc "w2vfsm" root (deref w2vfsm_ref)
;
non_lazy w2vfsm;

let fl_is_IDV_ENV canvas =
    let vfsm = w2vfsm canvas then
    is_IDV_ENV vfsm
;
export_to_tcl fl_is_IDV_ENV;

let get_idv_info_r canvas =
    let vfsm = w2vfsm canvas in
    NOT (is_IDV_ENV vfsm) => error "get_idv_info on STE_ENV" |
    let trfs = deref (vfsm2canvases_r vfsm) in
    val (TR_SEQ parent inside sell vr trfsr) =
	    dassoc "canvas2trfs" canvas trfs
    then
    trfsr
;

let get_idv_info canvas = deref (get_idv_info_r canvas);


let get_idv_current_pexlif canvas = fst (hd (get_idv_info canvas));

let get_idv_parent_info canvas =
    let vfsm = w2vfsm canvas in
    NOT (is_IDV_ENV vfsm) => error "get_idv_info on STE_ENV" |
    let trfs = deref (vfsm2canvases_r vfsm) in
    val (TR_SEQ parent inside sell vr trfsr) =
	    dassoc "canvas2trfs" canvas trfs
    then
    (parent, inside, sell)
;


let canvas2ste canvas = deref (vfsm2ste_r (w2vfsm canvas));
let canvas2current_time_r canvas = vfsm2cur_time_r (w2vfsm canvas);
let canvas2waveform canvas = deref (vfsm2wvr (w2vfsm canvas));
let canvas2stop_list_r canvas = vfsm2stop_list_r (w2vfsm canvas);
let canvas2selection_r canvas = vfsm2selection_r (w2vfsm canvas);
let canvas2hll_r canvas = vfsm2hll_r (w2vfsm canvas);
let canvas2canvases_r canvas = vfsm2canvases_r (w2vfsm canvas);

let canvas2vis canvas =
    let cs = deref (canvas2canvases_r canvas) then
    dassoc "canvas2vis" canvas cs
;

let fl_c2w canvas = canvas2waveform canvas;
export_to_tcl fl_c2w;

let ste_debug_cnt_ref = ref 0;
let mk_ste_debug_window {dummy::void} =
    let idx = deref ste_debug_cnt_ref + 1 then
    (ste_debug_cnt_ref := idx) fseq
    sprintf ".ste_debug_%d" idx
;
non_lazy mk_ste_debug_window;

let STE_debug fsm =
    fsm fseq
    let w = mk_ste_debug_window () then
    (tcl_eval [sprintf "create_ste_debugger %s" w]) fseq
    let ste0 = STE "" fsm [] [] [] [] then
    let cmd = sprintf "let vis = get_current_vis ();" in
    let res = STEV_ENV
		      w
		      fsm
		      (ref ste0)
		      (ref "")
		      (ref 0)
		      (ref [])
		      (ref [])
		      (ref [])
		      (ref [])
		      (ref [])
		      (ref [cmd])
    then
    (cur_vfsm := (res:(deref cur_vfsm))) fseq
    (register_vfsm res w) fseq
    let wvf = tcl_eval ["nb:create_mandatory_tabs "^w] then
    ((vfsm2wvr res) := wvf) fseq
    (tcl_eval [
	"update",
         sprintf "bind %s.nb <Destroy> [list fl_destroy_vfsm %s]" w w
    ]) fseq
    res
;

let VIS fl_function_name =
    let p = flfun2pexlif_core fl_function_name then
    let ckt = pexlif2fsm p then
    STE_debug ckt
;
free_binder VIS;

let fl_destroy_vfsm w =
    let raw = deref cur_vfsm then
    let rem = filter (\vfsm. vfsm2id vfsm != w) raw then
    (cur_vfsm := rem)
;
export_to_tcl fl_destroy_vfsm;

// Perform symbolic trajectory evaluation on circuit ckt.
// Returns an ste object that can be queried for traces, results, etc.
//
// The options argument is a string that can contain a combination of the
// following flags:
//
//    -a     Abort the STE at the first error.
//
//    -e     Compute and trace the value for every node in the circuit.
//           The default is to only compute nodes in the transitive fanin
//           cone of nodes in the consequent or trace list.
//
//    -m t   Abort the STE run after t phases has been simulated.
//
//    -w n   Limit the size of any BDD to n. If the value of a node
//           exceeds this limit, abstract the node (make it more X).
//
//    -ifw   Do the weakening by introducing new (fresh) variables.
//           The translation from the abstracted BDD to the true expression
//           can be obtained by repeated substitutions from the expression
//           map obtained from get_weak_expressions.
//
// The weak_list (wl) is a list of 4-tuples of the form (w,nd,f,t) to be
// read as: when w holds, weaken the excitation function of node nd from
// time f up to, but not including, time t.
//
// Both the antecedent (ant) and consequent (cons) lists are lists of
// 5-tuples of the form (w,nd,v,f,t) to be read as:
// when w holds, impose the constraint that the node nd should take on
// at least the value v from time f up to, but not including, time t.
//
// The trace_list (trl) is a list of triples of the form (n,f,t) and should
// be read as: trace node nd from time f up to, but not including, time t.
//
// NOTE: If the STE run aborts for some reason (interrupt, timeout,
//       "-a" flag, etc.), all traces are terminated with an X value at
//       the time it aborted.  This means that if STE aborts due to an
//       antecedent failure, for example, the trace will no longer have
//       the values (at that time).  This will make debugging a bit
//       more difficult (but not impossible) but makes it safer since
//       possibly erroneous trace values are eliminated.
//
let bool_STE opts ckt wl ant cons trl =
    noX => (STE opts ckt wl ant cons trl) | busy (STE opts ckt wl ant cons trl);


// Perform symbolic trajectory evaluation on the circuit displayed in vfsm.
// Returns an ste object that can be queried for traces, results, etc.
//
// The options argument is a string that can contain a combination of the
// following flags:
//
//    -a     Abort the STE at the first error.
//
//    -e     Compute and trace the value for every node in the circuit.
//           The default is to only compute nodes in the transitive fanin
//           cone of nodes in the consequent or trace list.
//
//    -m t   Abort the STE run after t phases has been simulated.
//
//    -w n   Limit the size of any BDD to n. If the value of a node
//           exceeds this limit, abstract the node (make it more X).
//
//    -ifw   Do the weakening by introducing new (fresh) variables.
//           The translation from the abstracted BDD to the true expression
//           can be obtained by repeated substitutions from the expression
//           map obtained from get_weak_expressions.
//
// The weak_list (wl) is a list of 4-tuples of the form (w,nd,f,t) to be
// read as: when w holds, weaken the excitation function of node nd from
// time f up to, but not including, time t.
//
// Both the antecedent (ant) and consequent (cons) lists are lists of
// 5-tuples of the form (w,nd,v,f,t) to be read as:
// when w holds, impose the constraint that the node nd should take on
// at least the value v from time f up to, but not including, time t.
//
// The trace_list (trl) is a list of triples of the form (n,f,t) and should
// be read as: trace node nd from time f up to, but not including, time t.
//
// NOTE: If the STE run aborts for some reason (interrupt, timeout,
//       "-a" flag, etc.), all traces are terminated with an X value at
//       the time it aborted.  This means that if STE aborts due to an
//       antecedent failure, for example, the trace will no longer have
//       the values (at that time).  This will make debugging a bit
//       more difficult (but not impossible) but makes it safer since
//       possibly erroneous trace values are eliminated.
//
let vfsm_STE opts vfsm wl ant cons trl =
    let fsm = vfsm2fsm vfsm then
    let w = vfsm2id vfsm then
    (tcl_eval [sprintf "set ::active_gui %s" w]) fseq
    let ste = busy (STE opts fsm wl ant cons trl) then
    (tcl_eval [sprintf "unset ::active_gui"]) fseq
    ((vfsm2ste_r vfsm) := ste) fseq
    ((deref (vfsm2wvr vfsm)) = "" => error "Missing waveform canvas!" | ()) fseq
    (tcl_eval [sprintf "wv:set_new_max_time %s 1" (deref (vfsm2wvr vfsm))]) fseq
    let cur_time = deref (vfsm2cur_time_r vfsm) then 
    (tcl_eval [sprintf "set ::vstatus(time,%s) %d" w cur_time]) fseq
    ste
;
overload STE bool_STE vfsm_STE;

let bvfsm_STE opts vfsm wl ant cons trl =
    let fsm = vfsm2fsm vfsm then
    let ste = bSTE opts fsm wl ant cons trl then
    ((vfsm2ste_r vfsm) := ste) fseq
    ste
;
overload bSTE bSTE bvfsm_STE;

let fl_add_fsm root_window fsm_window vec =
    let vfsm = w2vfsm root_window then
    let rfsms = vfsm2fsms_r vfsm then
    let old = filter (\(c,_). c != fsm_window) (deref rfsms) then
    (rfsms := ((fsm_window,vec):old))
;
export_to_tcl fl_add_fsm;

let fl_remove_fsm root_window fsm_window =
    let vfsm = w2vfsm root_window then
    let rfsms = vfsm2fsms_r vfsm then
    let old = filter (\(c,_). c != fsm_window) (deref rfsms) then
    (rfsms := old)
;
export_to_tcl fl_remove_fsm;

let fl_get_active_fsms root_window =
    let vfsm = w2vfsm root_window then
    let rfsms = vfsm2fsms_r vfsm then
    deref rfsms
;
export_to_tcl fl_get_active_fsms;

let add_command vfsm cmd =
    let w = vfsm2id vfsm then
    let cmds_r = vfsm2cmds_r vfsm then
    (cmds_r := ((deref cmds_r) @ [cmd])) fseq
    (tcl_eval [sprintf "cmd:update_cmds %s" w]) fseq
    ()
;

let add_active_sch_tab_window vfsm canvas vis cmd =
    let rcanvas_list = vfsm2canvases_r vfsm then
    let old = filter (\(c,_). c != canvas) (deref rcanvas_list) then
    (rcanvas_list := ((canvas,vis):old))  fseq
    (add_command vfsm cmd)
;

forward_declare {idv_finish_transformation:: string->bool};

let fl_remove_active_sch_tab_window canvas =
    let vfsm = w2vfsm canvas then
    let commit = is_STE_ENV vfsm => T | idv_finish_transformation canvas then
    NOT commit => F |
    let rcanvas_list = vfsm2canvases_r vfsm then
    let new = filter (\(c,_). c != canvas) (deref rcanvas_list) then
    (rcanvas_list := new) fseq
    T
;
export_to_tcl fl_remove_active_sch_tab_window;

let fl_get_active_sch_tab_windows canvas =
    let vfsm = w2vfsm canvas then
    let rcanvas_list = vfsm2canvases_r vfsm then
    map fst (deref rcanvas_list)
;
export_to_tcl fl_get_active_sch_tab_windows;

let fl_record_waveform_addition w vec =
    let vfsm = w2vfsm w then
    let cmd = sprintf "add_waveform vis [\"%s\"];" vec in
    add_command vfsm cmd
;
export_to_tcl fl_record_waveform_addition;

let fl_record_waveform_deletion w idx =
    let vfsm = w2vfsm w then
    let cmd = sprintf "delete_waveform vis %d;" idx in
    add_command vfsm cmd
;
export_to_tcl fl_record_waveform_deletion;

let fl_record_waveform_movement w idx dir =
    let vfsm = w2vfsm w then
    let cmd = sprintf "move_waveform vis %d %d;" idx dir in
    add_command vfsm cmd
;
export_to_tcl fl_record_waveform_movement;

let tw_c_r = ref ("","");
let fl_update_tw_c tab_w c =
    (tw_c_r := (tab_w, c))
;
export_to_tcl fl_update_tw_c;

let get_new_sch_canvas w draw_level name instance_hier =
    let rname = name = "" => "-" | sprintf "{%s}" name in
    (
	tcl_eval [sprintf "sc:get_new_sch_canvas %s %d {%s} %s" w draw_level
			  instance_hier rname]
    ) fseq
    deref tw_c_r
;

let canvas2tab c =
    (sprintf "tab_%s" (string_tl (el 4 (str_split c "."))))
    gen_catch (\msg. (fprintf stderr "canvas2tab: %s fails\n" c) seq error msg)
;

let start_draw_op c = tcl_eval [sprintf "sc:prepare_draw_info %s" c];
non_lazy start_draw_op;

let gen_draw_fanin vfsm draw_level levels vecs =
    let stop_list = deref (vfsm2stop_list_r vfsm) then
    let fsm = vfsm2fsm vfsm then 
    let w = vfsm2id vfsm then
    let vis = visualize_fanin fsm stop_list [] levels vecs draw_level then
    val (tab_window, c) = get_new_sch_canvas w draw_level "" "" then
    (start_draw_op c) fseq
    let cmd =	
	let tab = canvas2tab c then
	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") vecs in
	sprintf "let %s = draw_fanin vis (%d) %d %s;\n%s;"
		 tab draw_level levels svecs tab
    in
    (add_active_sch_tab_window vfsm c (BASE_VIS vis) cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
                sprintf "%s delete all" c,
                sprintf "draw_network %s $%s" c final_res,
                "update",
		sprintf "bind %s <Map> {fl_update_colors %s}"  c c,
		sprintf "fl_update_colors %s"  c,
                sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
              ]) fseq
    c
;

//let create_instance_model hier p =
//    val (PINST name attrs lf fa_inps fa_outs ints (P_HIER chs)) = p in
//    let top_rename (f,as) = (hier^f), as in
//    let fa_inps' = map top_rename fa_inps then
//    let fa_outs' = map top_rename fa_outs then
//    let ints' = map (\v. hier^v) ints then
//    let child_rename (PINST cnm cattrs clf cfa_inps cfa_outs cints cbody) =
//	let rename v = str_is_prefix "0" v => v | hier^v in
//	let ch_rename (f,as) = (f, (map rename as)) in
//	let cfa_inps' = map ch_rename cfa_inps then
//	let cfa_outs' = map ch_rename cfa_outs then
//	PINST cnm cattrs clf cfa_inps' cfa_outs' cints cbody
//    in
//    let chs' = map child_rename chs then
//    (PINST name attrs lf fa_inps' fa_outs' ints'(P_HIER chs'))
//;

let gen_draw_inside vfsm canvas cur_draw_level vecs inst_nbr =
    let w = vfsm2id vfsm then
    is_IDV_ENV vfsm =>
	let parent = get_idv_current_pexlif canvas then
	let phier =
	    tcl_eval [sprintf "set ::sch_info(instance_hier,%s)" canvas]
	then
	let hier = sprintf "%si%d/" phier inst_nbr then
	let p = el inst_nbr (pexlif_get_children parent) then
	let vis = idv_visualize_fanin p then
	val (tab_window, c) = get_new_sch_canvas w 0 "" hier then
	(start_draw_op c) fseq
	let cmd = "OBSOLETE" in
	let evis =
	    TR_SEQ canvas T [inst_nbr] (ref vis) (ref [(p,SPEC)])
	then
	(add_active_sch_tab_window vfsm c evis cmd) fseq
	val (final_res, cmds) = visualisation2tcl vis then
	(big_tcl_eval ("create_sch":cmds)) fseq
	(tcl_eval [
		    sprintf "%s delete all" c,
		    sprintf "draw_network %s $%s" c final_res,
		    "update",
		    sprintf "set_scrollregion %s" c,
		    sprintf "sc:remove_draw_info %s" c
		  ]) fseq
	c
    |
    // STE_ENV
    let fsm = vfsm2fsm vfsm then 
    let nds = md_expand_vectors vecs then
    let stop_list = deref (vfsm2stop_list_r vfsm) then
    let ifc_list =
	(flatmap snd (get_visualization_fanins fsm (hd nds) cur_draw_level))
	subtract nds
    then
    let phier= tcl_eval [sprintf "set ::sch_info(instance_hier,%s)" canvas] then
    let hier = sprintf "%si%d/" phier inst_nbr then
    let name =
	let pfn = get_visualization_pfn fsm (hd nds) cur_draw_level then
	str_is_prefix "draw_fub" pfn =>
	    let cmd = "extract_name_"^pfn then
	    tcl_eval [cmd]
	|
	str_is_prefix "draw_hfl_code" pfn =>
	    let cmd = "extract_name_"^pfn then
	    tcl_eval [cmd]
	| 
	"N/A"
    then
    let draw_level = cur_draw_level+1 in
    let vis = visualize_fanin fsm stop_list ifc_list 100 vecs draw_level then
    val (tab_window, c) = get_new_sch_canvas w draw_level hier hier then
    (start_draw_op c) fseq
    let cmd =	
	let tab = canvas2tab c then
	let svecs = list2str T "[" "," "]" (sprintf "\"%s\"") vecs in
	sprintf "let %s = draw_inside vis %d %s;\n%s;" 
		tab (cur_draw_level+1) svecs tab
    in
    (add_active_sch_tab_window vfsm c (BASE_VIS vis) cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
                sprintf "%s delete all" c,
                sprintf "draw_network %s $%s" c final_res,
                "update",
		sprintf "bind %s <Map> {fl_update_colors %s}"  c c,
		sprintf "fl_update_colors %s"  c,
		sprintf "draw_hier_boundingbox %s {%s}" c name,
                sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
              ]) fseq
    c
;


// =====================================================================
// Callback functions
// =====================================================================

let fl_tag2vec canvas tag =
    let vis = evis2vis (canvas2vis canvas) then
    visualization_anon2real vis tag
;
export_to_tcl fl_tag2vec;

let fl_vecs2tags canvas vecs =
    str_is_prefix ".c9999999" canvas => ["_"] |
    let vis = evis2vis (canvas2vis canvas) then
    val (fpots,ppots) = visualization_vecs2tags vis T vecs then
    let is_vecs an = (visualization_anon2real vis an) = vecs in
    let res = filter is_vecs fpots then
    res
;
export_to_tcl fl_vecs2tags;


let fl_draw_fanin_by_name canvas draw_level levels vecs =
    let vfsm = w2vfsm canvas then
    busy (gen_draw_fanin vfsm draw_level levels vecs)
;
export_to_tcl fl_draw_fanin_by_name;

let fl_draw_inside canvas cur_draw_level tag inst_nbr =
    let vfsm = w2vfsm canvas then
    let vecs = fl_tag2vec canvas tag then
    busy (gen_draw_inside vfsm canvas cur_draw_level vecs inst_nbr)
;
export_to_tcl fl_draw_inside;

let fl_show_info canvas inst_nbr =
    let parent = get_idv_current_pexlif canvas then
    let p = el inst_nbr (pexlif_get_children parent) then
    let sha = pexlif_get_SHA p then
    let sig = pexlif_get_FP p then
    val (PINST name attrs lf fa_inps fa_outs ints body) = p in
    let get_children (P_HIER cs) = length cs
     /\ get_children other = -1
    in
    let child_info =
        let cnt = get_children body in
        cnt < 0 => "Leaf" | sprintf "Hierarchy with %d children" cnt
    in
    let inps = map fst fa_inps in
    let nbr_inps = length inps in
    let inp_szs = map md_size inps in
    let outs = map fst fa_outs in
    let nbr_outs = length outs in
    let out_szs = map md_size outs in
    let nbr_ints = length ints in
    let int_szs = map md_size ints in
    let msg = sprintf "Pexlif information for instance %d" inst_nbr in
    let details = list2str T "" "\n" "\n" id [
        (sprintf "Name: %s" name),
        (sprintf "Type: %s" child_info),
        (sprintf "SHA signature: %s" sha),
        (sprintf "FP signature: %d" sig),
        (sprintf "Inputs: %d %S" nbr_inps (map int2str inp_szs)),
        (sprintf "Outputs: %d %S" nbr_outs (map int2str out_szs)),
        (sprintf "Internal: %d %S" nbr_ints (map int2str int_szs))
        ]
    then
    (report_result0 msg details [("Ok","1")]) fseq ()
;
export_to_tcl fl_show_info;


let fl_draw_fanin_by_tag canvas draw_level levels tag =
    let vfsm = w2vfsm canvas then
    let vec = fl_tag2vec canvas tag then
    let c = gen_draw_fanin vfsm draw_level levels vec then
    busy c
;
export_to_tcl fl_draw_fanin_by_tag;

let fl_show_rtl canvas dlev tag =
    let vfsm = w2vfsm canvas then
    let fsm = vfsm2fsm vfsm then 
    let vecs = fl_tag2vec canvas tag then
    let get_src v = (
	let src = assoc "src" (get_visualization_attributes fsm v dlev) then
	let src = last (str_split src "|") then
	val [file,range] = str_split src ":" then
	val [start_loc, end_loc] = str_split range "-" then
	val [start_line, start_col] = str_split start_loc "." then
	val [end_line, end_col] = str_split end_loc "." then
	[(file, start_line, start_col, end_line, end_col)]
	) catch []
    in
    let srcs = setify (flatmap get_src vecs) then
    srcs = [] => fprintf stderr "No RTL annotation avaiable for %S:\n" vecs |
    let show (file, start_line, start_col, end_line, end_col) = 
	tcl_eval [sprintf "rtl:visualize %s %s %s %s %s"
			   file start_line start_col end_line end_col] fseq
	()
    in
    foreach show srcs
;
export_to_tcl fl_show_rtl;


let fl_is_vector_name name = md_size name > 1;
export_to_tcl fl_is_vector_name;

let fl_is_vector canvas tag =
    str_is_prefix ".c9999999" canvas => F |
    let vecs = fl_tag2vec canvas tag in
    vecs = [] =>
	(fprintf stderr "Cannot map %s in %s\n" tag canvas) seq F
    |
    length vecs > 1 => T |
    md_size (hd vecs) > 1
;               
export_to_tcl fl_is_vector;

let fl_get_global_time canvas = deref (canvas2current_time_r canvas);
export_to_tcl fl_get_global_time;


lettype observer =
    OBSERVER {vis::vfsm} {callback_fun::(ste->int->void)}
;

let observer_list_r = ref {[]:: observer list};

let add_observer vfsm call_back_function =
    let observer = OBSERVER vfsm call_back_function then
    (observer_list_r := (observer:(deref observer_list_r))) fseq
    observer
;

let delete_observer observer =
    observer_list_r := (filter (\m. m != observer) (deref observer_list_r))
;

let process_observers vfsm time =
    let ste = deref (vfsm2ste_r vfsm) then
    let do (OBSERVER vis fn) = vis != vfsm => () | ((fn ste time) catch ()) in
    foreach do (deref observer_list_r)
; 

let fl_set_global_time canvas t =
    let vfsm = w2vfsm canvas then
    let cmd = sprintf "draw_set_time vis %d;" t then
    (add_command vfsm cmd) fseq
    let rtime = canvas2current_time_r canvas in
    (rtime := t) fseq
    (process_observers vfsm t)
;
export_to_tcl fl_set_global_time;

let fl_record_minmax_update canvas t_min t_max =
    let vfsm = w2vfsm canvas then
    let cmd = sprintf "draw_set_minmax vis %d %d;" t_min t_max then
    (add_command vfsm cmd)
;
export_to_tcl fl_record_minmax_update;


let fl_inform_show_value_change c show =
    let tab = canvas2tab c then
    let vfsm = w2vfsm c then
    let show = show = "1" => "T" | "F" in
    let cmd = sprintf "draw_show_values vis %s %s;" tab show then
    (add_command vfsm cmd)
;
export_to_tcl fl_inform_show_value_change;


let pretty_printers_ref = ref {[]::(string#(int->string)) list};


let add_pretty_printer vec fn =
    let old = filter (\p. fst p != vec) (deref pretty_printers_ref) then
    let new = (vec,fn):old then
    (pretty_printers_ref := new)
;

let rm_pretty_printer vec =
    let new = filter (\p. fst p != vec) (deref pretty_printers_ref) then
    (pretty_printers_ref := new)
;

let find_pretty_printer vec i =
    let fn = assoc vec (deref pretty_printers_ref) then
    fn i
;

let compress l =
    letrec compr cnt cur (v:vs) =
	v == cur => compr (cnt+1) cur vs |
	cnt < 3 => (replicate cnt cur)@(compr 1 v vs) |
	(sprintf "%s^%d" cur cnt):(compr 1 v vs)
     /\    compr cnt cur [] =
	cnt < 3 => (replicate cnt cur) |
	[(sprintf "%s^%d" cur cnt)]
    in
    compr 1 (hd l) (tl l)
;

let my_bool2str f =
    let s = bool2str 5 f in
    let l = str_split s " " in
    let s' = list2str T "" "" "" id l in
    let ll = str_split s' "+" in
    list2str T "" "+\n" "" id ll
;

let fl_get_ste_maxtime w =
    let ste = canvas2ste w then
    get_ste_maxtime ste
;
export_to_tcl fl_get_ste_maxtime;

let merge_traces trls =
    let cmp a b = b-a in
    let time_points = qsort cmp (setify (map fst (flat trls))) then
    letrec mk (ct:cts) trl =
        let getv ((t,HL):rem) = ct = t => (HL,rem) | (HL,((t,HL):rem)) in
        val (resl,rem_trl) = unzip (map getv trl) then
        (ct, resl):(mk cts rem_trl)
      /\   mk [] trl = []
    in
    mk time_points trls
;

let fl_wv_get_short w vec t =
    let ste = canvas2ste w then
    let type = get_ste_type ste then
    let nds = md_expand_vector vec in
    length nds > 128 => "..." |
    let opt_states = node2value_list (ste2fsm ste) (hd nds) in
    type = "bdd" =>
	let get_val nd = (T,(get_trace_val ste nd t)) catch (F,(T,T)) in
	let vals = map get_val nds then
	let val2s (is_traced,HL) =
	    NOT is_traced => "_" |
	    HL == (T,F) => "1" |
	    HL == (F,T) => "0" |
	    HL == (T,T) => "X" |
	    HL == (F,F) => "OVERCONSTRAINED" |
	    val (H,L) = HL in
	    (H == NOT L) => "S" |
	    (NOT L AND NOT H) == F =>
	       H == T => "0X" | 
	       L == T => "X1" | 
	       "0X1"
	    |
	    "OVERCONSTRAINED"
	in
	let vs = map val2s vals then
	let alts = setify vs then
	(alts subtract ["0","1"]) = [] =>
	    let s = implode vs then
	    opt_states != [] =>
		// An ENUM (e.g. state machine)
		let i = sscanf "%b" s in
		(assoc i opt_states) catch (sprintf "?0x%x?" i)
	    |
	    let i = sscanf "%b" s in
	    let res =
		let txt = length nds >= 4 => sprintf "0x%x" i | s in
		(find_pretty_printer vec i) catch txt
	    then
	    strlen res > 30 => "..." | res
	|
	length alts = 1 => hd alts |
	let res = list2str T "{" "," "}" id (compress vs) then
	strlen res > 30 => "..." | res
    |
    type = "bexpr" =>
	let definitely_unsat f = ((bget_model [f] 10) = []) catch F in
	let definitely_sat f = ((bget_model [f] 10) != []) catch F in
	let bget_val nd = (T,(bget_trace_val ste nd t)) catch (F,(bT,bT)) in
	let val2s nd =
	    val (is_traced,HL) = bget_val nd then
	    NOT is_traced => "_" |
	    HL == (bT,bF) => "1" |
	    HL == (bF,bT) => "0" |
	    HL == (bT,bT) => "X" |
	    HL == (bF,bF) => "OVERCONSTRAINED" |
	    val (H,L) = HL in
	    definitely_unsat (H bXNOR L) => "S" |
	    definitely_sat ((bNOT H) bAND (bNOT L)) => "OVERCONSTRAINED" |
	    definitely_unsat (bNOT H) => "0X" |
	    definitely_unsat (bNOT L) => "X1"
				       | "0X1"
	in
	let vs = map val2s nds then
	let alts = setify vs then
	(alts subtract ["0","1"]) = [] =>
	    let s = implode vs then
	    length nds >= 4 => sprintf "0x%x" (sscanf "%b" s) | (implode vs)
	|
	length alts = 1 =>
	    let res = hd alts then
	    strlen res > 30 => "..." | res
	|
	let res = list2str T "{" "," "}" id (compress vs) then
	strlen res > 30 => "..." | res
    |
    "_"
;
export_to_tcl fl_wv_get_short;

let info_leq l1 l2 =
    letrec leq ((v1,(H1,L1)):r1) ((v2,(H2,L2)):r2) =
	v1 AND v2 AND (NOT H2 OR H1) AND (NOT L2 OR L1) AND (leq r1 r2)
     /\    leq [] [] = T
    in
    leq l1 l2
;

let fl_get_short_value w vecs compute_alternatives =
    let vfsm = w2vfsm w then
    let ste = deref (vfsm2ste_r vfsm) then
    let type = get_ste_type ste then
    let fsm = ste2fsm ste then
    let t = deref (vfsm2cur_time_r vfsm) then
    let nds = md_expand_vectors vecs in
    length nds > 128 => "..." |
    let opt_states = node2value_list fsm (hd nds) in
    type = "bdd" =>
	let get_val nd = (T,(get_trace_val ste nd t)) catch (F,(T,T)) in
	let vals = map get_val nds then
	let val2s (is_traced,HL) =
	    NOT is_traced => "_" |
	    HL == (T,F) => "1" |
	    HL == (F,T) => "0" |
	    HL == (T,T) => "X" |
	    HL == (F,F) => "OVERCONSTRAINED" |
	    val (H,L) = HL in
	    (H == NOT L) => "S" |
	    (NOT L AND NOT H) == F =>
	       H == T => "0X" | 
	       L == T => "X1" | 
	       "0X1"
	    |
	    "OVERCONSTRAINED"
	in
	let vs = map val2s vals then
	let alts = setify vs then
	(alts subtract ["0","1"]) = [] =>
	    let s = implode vs then
	    opt_states != [] =>
		// An ENUM (e.g. state machine)
		let i = sscanf "%b" s in
		(assoc i opt_states) catch (sprintf "?0x%x?" i)
	    |   
	    let i = sscanf "%b" s in
	    let res =
		let txt = length nds >= 4 => sprintf "0x%x" i | (implode vs) in
		((length vecs = 1) => (find_pretty_printer (hd vecs) i) | txt)
		catch txt
	    then
	    strlen res > 30 => "..." | res
	|
	(compute_alternatives AND (opt_states != [])) =>
	    // Compute all alternatives that can match the result
	    let bits = length nds in
	    let tst (idx,name) =
		let es = explode (sprintf "%0*b" bits idx) in
		let cnv b = (T,(b="1" => (T,F) | (F,T))) in
		let pat = map cnv es in
		NOT ((info_leq vals pat) == F)
	    in
	    let alts = filter tst opt_states then
	    list2str T "" "/" "" snd alts
	|
	length alts = 1 => hd alts |
	let res = list2str T "{" "," "}" id (compress vs) then
	strlen res > 30 => "..." | res
    |
    type = "bexpr" =>
	let definitely_unsat f = ((bget_model [f] 10) = []) catch F in
	let definitely_sat f = ((bget_model [f] 10) != []) catch F in
	let bget_val nd = (T,(bget_trace_val ste nd t)) catch (F,(bT,bT)) in
	let val2s nd =
	    val (is_traced,HL) = bget_val nd then
	    NOT is_traced => "_" |
	    HL == (bT,bF) => "1" |
	    HL == (bF,bT) => "0" |
	    HL == (bT,bT) => "X" |
	    HL == (bF,bF) => "OVERCONSTRAINED" |
	    val (H,L) = HL in
	    definitely_unsat (H bXNOR L) => "S" |
	    definitely_sat ((bNOT H) bAND (bNOT L)) => "OVERCONSTRAINED" |
	    definitely_unsat (bNOT H) => "0X" |
	    definitely_unsat (bNOT L) => "X1"
				       | "0X1"
	in
	let vs = map val2s nds then
	let alts = setify vs then
	(alts subtract ["0","1"]) = [] =>
	    let s = implode vs then
	    length nds >= 4 => sprintf "0x%x" (sscanf "%b" s) | (implode vs)
	|
	length alts = 1 =>
	    let res = hd alts then
	    strlen res > 30 => "..." | res
	|
	let res = list2str T "{" "," "}" id (compress vs) then
	strlen res > 30 => "..." | res
    |
    "_"
;
export_to_tcl fl_get_short_value;

let fl_get_short_value_from_aname canvas tag =
    let w = w2root canvas in
    let vecs = fl_tag2vec canvas tag then
    fl_get_short_value w vecs
;
export_to_tcl fl_get_short_value_from_aname;

let fl_get_long_value canvas tag =
    let ste = canvas2ste canvas then
    let type = get_ste_type ste then
    let t = deref (canvas2current_time_r canvas) then
    let vecs = fl_tag2vec canvas tag then
    let nds = md_expand_vectors vecs in
    length nds > 128 => "..." |
    type = "bdd" =>
	let get_val nd = (get_trace_val ste nd t) catch (T,T) in
	let vals = map get_val nds then
	let is_const HL =
	    (HL == (T,F)) OR (HL == (F,T)) OR (HL == (T,T)) OR (HL == (F,F))
	in
	let mk_range cur =
	    let r = rev cur in
	    let vs = merge_vectors (map fst r) then
	    let v = hd vs then
	    let vals = map snd r then
	    let non_binary HL = NOT (HL == (T,F)) AND NOT (HL == (F,T)) in
	    let idx = find_first0 non_binary vals then
	    idx = 0 =>
		let b = implode (map (\(H,L). H=>"1"| "0") vals) then
		let i = sscanf "%b" b in
		let base_txt = length r >= 4 => sprintf "0x%x" i | b in
		let pretty_txt = (" "^(find_pretty_printer v i)) catch "" in
		(v, [base_txt^pretty_txt])
	    |
	    let val2s (HL) =
		HL == (T,F) => "1" |
		HL == (F,T) => "0" |
		HL == (T,T) => "X" |
		"T"
	    in
	    (v, [implode (map val2s vals)])
	in
	letrec group cur (nd:nds) (HL:HLs) =
	    is_const HL => group ((nd,HL):cur) nds HLs |
	    cur != [] => (mk_range cur):(group []  (nd:nds) (HL:HLs)) |
	    let ovc = (HL = (F,F)) in
	    NOT (ovc == F) => (nd,["OVERCONSTRAINED"]):(group [] nds HLs) |
	    let one   = (HL = (T,F)) in
	    let X     = (HL = (T,T)) in
	    X == F => (nd,[bool2str 3 one]):(group [] nds HLs) |
	    let one_s = bool2str 3 one then
	    let X_s   = bool2str 3 X then
	    (nd, [one_s, (sprintf "  + X(%s)" X_s)]):(group [] nds HLs)
	 /\   group cur [] [] =
	    cur = [] => [] |
	    [mk_range cur]
	in
	let raw_res = group [] nds vals then
	length raw_res = 1 => 
	    let res = list2str T "" "\n" "" id (snd (hd raw_res)) then
	    strlen res > 30 => "..." | res
	|
	let slen = (itlist (\p.\m. max (strlen (fst p)) m) raw_res 0)+3 then
	let slen = (slen > 40) => 40 | slen in
	let p_range (vec,exprs) =
	    let sep = sprintf "%*s\n" slen "" then
	    let es = list2str T "" sep "" id exprs then
	    sprintf "%*s: %s" slen vec es
	in
	let res = list2str T "" "\n" "" p_range raw_res then
	strlen res > 30 => "..." | res
    |
    type = "bexpr" =>
	let get_val nd = (bget_trace_val ste nd t) catch (bT,bT) in
	let vals = map get_val nds then
	let definitely_unsat f = ((bget_model [f] 10) = []) catch F in
	let definitely_sat f = ((bget_model [f] 10) != []) catch F in
	let is_const HL =
	    (HL == (bT,bF)) OR (HL == (bF,bT)) OR   
	    (HL == (bT,bT)) OR (HL == (bF,bF))
	in
	let mk_range cur =
	    let r = rev cur in
	    let vs = merge_vectors (map fst r) then
	    let v = hd vs then
	    let vals = map snd r then
	    let non_binary HL = NOT (HL == (bT,bF)) AND NOT (HL == (bF,bT)) in
	    let idx = find_first0 non_binary vals then
	    idx = 0 =>
		let b = implode (map (\(H,L). (H==bT)=>"1"| "0") vals) then
		let d = length r >= 4 => sprintf "0x%x" (sscanf "%b" b) | b in
		(v,[d])
	    |
	    let val2s (HL) =
		HL == (bT,bF) => "1" |
		HL == (bF,bT) => "0" |
		HL == (bT,bT) => "X" |
		"T"
	    in
	    (v, [implode (map val2s vals)])
	in
	letrec group cur (nd:nds) (HL:HLs) =
	    is_const HL => group ((nd,HL):cur) nds HLs |
	    cur != [] => (mk_range cur):(group []  (nd:nds) (HL:HLs)) |
	    val (H,L) = HL in
	    let ovc = (bNOT H) bAND (bNOT L) in
	    definitely_sat ovc => (nd,["OVERCONSTRAINED"]):(group [] nds HLs) |
	    let one   = H bAND (bNOT L) in
	    let X     = H bAND L in
	    definitely_unsat X => 
		(nd,[bexpr2str 3 one]):(group [] nds HLs)
	    |
	    let one_s = bexpr2str 3 one then
	    let X_s   = bexpr2str 3 X then
	    (nd, [one_s, (sprintf "  + X(%s)" X_s)]):(group [] nds HLs)
	 /\   group cur [] [] =
	    cur = [] => [] |
	    [mk_range cur]
	in
	let raw_res = group [] nds vals then
	length raw_res = 1 =>
	    let res = list2str T "" "\n" "" id (snd (hd raw_res)) then
	    strlen res > 30 => "..." | res
	|
	let slen = (itlist (\p.\m. max (strlen (fst p)) m) raw_res 0)+3 then
	let slen = (slen > 40) => 40 | slen in
	let p_range (vec,exprs) =
	    let sep = sprintf "%*s\n" slen "" then
	    let es = list2str T "" sep "" id exprs then
	    sprintf "%*s: %s" slen vec es
	in
	let res = list2str T "" "\n" "" p_range raw_res then
	strlen res > 30 => "..." | res
    |
    "-"
;
export_to_tcl fl_get_long_value;

let split_multi_dim v =
    let parts = str_split v "[" in
    length parts <= 2 => [v] |
    let nds = md_expand_vector v in
    let sep_fn n = butlast (str_split n "[") in
    let svs = partition sep_fn nds then
    flatmap md_extract_vectors svs
;

let HL_is_var (H,L) =
    NOT (H == NOT L) => F |
    val (v,(h,l)) = top_cofactor H in
    h == T AND l == F
;

let trim s =
    let es = explode s in
    letrec trim (" ":" ":r) = trim (" ":r)
     /\    trim (c:cs) = c:trim cs
     /\    trim [] = []
    in
    let es' = trim es in
    let es' = hd es' = " " => tl es' | es' in
    let es' = last es' = " " => butlast es' | es' in
    (implode es')
;


let base_get_complete_value ste vectors t =
    let type = get_ste_type ste then
    let process v =
	let nds = md_expand_vector v in
	type = "bdd" =>
	    let get_val nd = (get_trace_val ste nd t) catch (T,T) in
	    let vals = map get_val nds then
	    let is_const HL =
		(HL == (T,F)) OR (HL == (F,T)) OR (HL == (T,T)) OR (HL == (F,F))
	    in
	    let mk_range cur =
		let r = rev cur in
		let vs = merge_vectors (map fst r) then
		let v = hd vs then
		let vals = map snd r then
		let non_binary HL = NOT (HL == (T,F)) AND NOT (HL == (F,T)) in
		let idx = find_first0 non_binary vals then
		idx = 0 =>
		    let b = implode (map (\(H,L). H=>"1"| "0") vals) then
		    let i = sscanf "%b" b in
		    let base_txt = length r >= 4 => sprintf "0x%x" i | b in
		    let pretty_txt = (" "^(find_pretty_printer v i)) catch "" in
		    (v, [base_txt^pretty_txt])
		|
		let val2s (HL) =
		    HL == (T,F) => "1" |
		    HL == (F,T) => "0" |
		    HL == (T,T) => "X" |
		    HL == (F,F) => "T" |
		    val (v,(h,l)) = top_cofactor (fst HL) in
		    " "^v^" "
		in
		let res = implode (md_merge_vectors (map val2s vals)) in
		(v, [trim res])
	    in
	    letrec group cur (nd:nds) (HL:HLs) =
		is_const HL => group ((nd,HL):cur) nds HLs |
		HL_is_var HL   => group ((nd,HL):cur) nds HLs |
		cur != [] => (mk_range cur):(group []  (nd:nds) (HL:HLs)) |
		let ovc = (HL = (F,F)) in
		NOT (ovc == F) => (nd,["OVERCONSTRAINED"]):(group [] nds HLs) |
		let one   = (HL = (T,F)) in
		let X     = (HL = (T,T)) in
		let deps = list2str T "Depends on: " " " "" id 
				   (md_extract_vectors (depends HL))
		in
		X == F => (nd,[bool2str 3 one,deps]):(group [] nds HLs) |
		let one_s = bool2str 3 one then
		let X_s   = bool2str 3 X then
		(nd, [one_s, (sprintf "  + X(%s)" X_s),deps]):(group [] nds HLs)
	     /\   group cur [] [] =
		cur = [] => [] |
		[mk_range cur]
	    in
	    let raw_res = group [] nds vals then
	    length raw_res = 1 => list2str T "" "\n" "" id (snd (hd raw_res)) |
	    let slen = (itlist (\p.\m. max (strlen (fst p)) m) raw_res 0)+3 then
	    let slen = (slen > 40) => 40 | slen in
	    let p_range (vec,exprs) =
		let sep = sprintf "%*s\n" slen "" then
		let es = list2str T "" sep "" id exprs then
		sprintf "%*s: %s" slen vec es
	    in
	    list2str T "" "\n" "" p_range raw_res
	|
	type = "bexpr" =>
	    let get_val nd = (bget_trace_val ste nd t) catch (bT,bT) in
	    let definitely_unsat f = ((bget_model [f] 10) = []) catch F in
	    let definitely_sat f = ((bget_model [f] 10) != []) catch F in
	    let vals = map get_val nds then
	    let is_const HL =
		(HL == (bT,bF)) OR (HL == (bF,bT)) OR
		(HL == (bT,bT)) OR (HL == (bF,bF))
	    in
	    let mk_range cur =
		let r = rev cur in
		let vs = merge_vectors (map fst r) then
		let v = hd vs then
		let vals = map snd r then
		let non_binary HL =
		    NOT (HL == (bT,bF)) AND NOT (HL == (bF,bT))
		in
		let idx = find_first0 non_binary vals then
		idx = 0 =>
		    let b = implode (map (\(H,L). (H==bT)=>"1"| "0") vals) then
		    let d =
			length r >= 4 => sprintf "0x%x" (sscanf "%b" b) | b
		    in
		    (v,[d])
		|
		let val2s (HL) =
		    HL == (bT,bF) => "1" |
		    HL == (bF,bT) => "0" |
		    HL == (bT,bT) => "X" |
		    "T"
		in
		(v, [implode (map val2s vals)])
	    in
	    letrec group cur (nd:nds) (HL:HLs) =
		is_const HL => group ((nd,HL):cur) nds HLs |
		cur != [] => (mk_range cur):(group []  (nd:nds) (HL:HLs)) |
		val (H,L) = HL in
		let ovc = (bNOT H) bAND (bNOT L) in
		definitely_sat ovc =>
		    (nd,["OVERCONSTRAINED"]):(group [] nds HLs)
		|
		let one   = H bAND (bNOT L) in
		let X     = H bAND L in
		definitely_unsat X => 
		    (nd,[bexpr2str 3 one]):(group [] nds HLs)
		|
		let one_s = bexpr2str 3 one then
		let X_s   = bexpr2str 3 X then
		(nd, [one_s, (sprintf "  + X(%s)" X_s)]):(group [] nds HLs)
	     /\   group cur [] [] =
		cur = [] => [] |
		[mk_range cur]
	    in
	    let raw_res = group [] nds vals then
	    length raw_res = 1 => list2str T "" "\n" "" id (snd (hd raw_res)) |
	    let slen = (itlist (\p.\m. max (strlen (fst p)) m) raw_res 0)+3 then
	    let slen = (slen > 40) => 40 | slen in
	    let p_range (vec,exprs) =
		let sep = sprintf "%*s\n" slen "" then
		let es = list2str T "" sep "" id exprs then
		sprintf "%*s: %s" slen vec es
	    in
	    list2str T "" "\n" "" p_range raw_res
	|
	"-"
    in
    let vecs =
	let raw = flatmap split_multi_dim vectors then
	length raw <= 32 => raw |
	let title =
	    "Too many nodes to display. Consider selecting a subrange."
	in
	let opts = map (\v. ("Vector: ", v)) vectors in
	let new_vectors = prompt_for_inputs title opts then
	new_vectors = [] => [] |  flatmap split_multi_dim new_vectors
    in
    vecs = [] => [""] |
    let len = sitlist (\v.\r. max r (strlen v)) vecs 0 in
    let do1 v =
	let res = process v then
	str_is_substr "\n" res =>
	    sprintf "%-*s:\n%s" len v res
	|
	    sprintf "%-*s: %s" len v res
    in
    map do1 vecs
;

let fl_get_complete_value canvas tag =
    let ste = canvas2ste canvas then
    let t = deref (canvas2current_time_r canvas) then
    let vecs = fl_tag2vec canvas tag then
    base_get_complete_value ste vecs t
;
export_to_tcl fl_get_complete_value;

let fl_wv_get_complete_value w vec t =
    let ste = canvas2ste w then
    base_get_complete_value ste [vec] t
;
export_to_tcl fl_wv_get_complete_value;

let fl_get_vectors canvas source pattern max_cnt =
    let vfsm = w2vfsm canvas then
    let fsm = vfsm2fsm vfsm then 
    let raw_sel =
	source = "Inputs" => (inputs fsm) |
	source = "Outputs" => (outputs fsm) |
	source = "User Given" => (filter is_user_given (vectors fsm)) |
	source = "All" => (vectors fsm) |
	["What???"]
    in
    let res = filter (str_match pattern) raw_sel then
    length res > max_cnt => (firstn max_cnt res)@["..."] | res
;
export_to_tcl fl_get_vectors;

let weaken_color color =
    color = "red" => "pink" |
    color = "blue" => "#7a7aff" |
    color = "DarkOrchid1" => "#e3abff" |
    color = "magenta2" => "#ee94ee" |
    color = "DarkOrange1" => "#eebf91" |
    color = "green" => "#6da16d" |
    color = "gold3" => "#cdc38b" |
    color = "yellow" => "#ffffa8" |
    color = "cyan" => "#a3ffff" |
    color = "purple" => "#805f80" |
    color = "brown" => "#a57575" |
    color
;


let update_colors vfsm =
  (
    let selection = deref (vfsm2selection_r vfsm) then
    let base_highlights = deref (vfsm2hll_r vfsm) then
    let highlights = map hd (partition fst base_highlights) in
    let active_canvases = deref (vfsm2canvases_r vfsm) then
    let do_one_canvas (c,evis) =
	let vis = evis2vis evis in
	let send_cmd color anon =
	    sprintf "cb:prim_set_wire_color %s %s %s" c anon color
	in
	let do_one_col l =
	    l = [] => [] |
	    let color = snd (hd l) in
	    let vecs = md_expand_vectors (map fst l) in
	    val (full_anons, part_anons) =
		visualization_vecs2tags vis T vecs
	    then
	    let cmds1 = map (send_cmd color) full_anons then
	    let wcolor = weaken_color color in
	    let cmds2 = map (send_cmd wcolor) part_anons then
	    (cmds1@cmds2)
	in
	let tcmd1 = sprintf "cb:restore_original_colors %s" c in
	let tcmd2 = flatmap do_one_col (partition snd highlights) then
	// Now do selection since it overrides other colors
	let tcmd3 = do_one_col (map (\v.v,"red") selection) then
	tcmd1:(tcmd2@tcmd3)
    in
    let tcmds = flatmap do_one_canvas active_canvases then
    NOT (is_IDV_ENV vfsm) =>
	// Now update the waveform window too
	let w = deref (vfsm2wvr vfsm) then
	let tcmd1 = sprintf "wv:restore_original_colors %s" w then
	let wv_vecs = tcl2list (tcl_eval ["wv:get_waveform_vectors "^w]) then
	let esel = md_expand_vectors selection then
	let exp1 (v,col) =
	    map (\n. n, col) ((md_expand_vector v) subtract esel)
	in
	let e_selection = map (\n. n, "red") esel then
	let nd_colors = e_selection @ (flatmap exp1 highlights) then
	let do1w wvec =
	    let nds = md_expand_vector wvec in
	    let cols = map (\n. (assoc n nd_colors) catch "") nds then
	    let summary = filter (\n. n != "") (setify cols) in
	    summary == [] =>
		sprintf "wv:prim_set_name_color %s {%s} _OrIgInAlCoLoR_;" w wvec
	    |
	    length summary != 1 => "" |
	    let col = hd summary in
	    sprintf "wv:prim_set_name_color %s {%s} %s;" w wvec col
	in
	let cmds = map do1w wv_vecs then
	big_tcl_eval (tcmds@cmds)
    |
	big_tcl_eval tcmds
 ) gen_catch (\msg. (fprintf stderr "Failure: %s\n" msg) fseq "")
;
non_lazy update_colors;

let set_highlight_color vfsm color vecs =
    let hll_r = vfsm2hll_r vfsm then
    let old = filter (\(v,col). NOT (mem v vecs)) (deref hll_r) then
    let new = map (\v.v,color) vecs in
    (hll_r := (new@old)) fseq
    (update_colors vfsm)
;

let fl_set_wv_highlight_color w color vec =
    let vfsm = w2vfsm w then
    set_highlight_color vfsm color [vec]
;
export_to_tcl fl_set_wv_highlight_color;

    
let fl_set_sch_highlight_color c color tag =
    let vfsm = w2vfsm c then
    let vecs = fl_tag2vec c tag then
    set_highlight_color vfsm color vecs
;
export_to_tcl fl_set_sch_highlight_color;


let get_current_vis {dummy::void} = 
    let cur = deref cur_vfsm then
    cur = [] => error "No active vfsm" |
    hd cur
;
non_lazy get_current_vis;

let get_current_idv_window {dummy::void} =
    let vfsm = get_current_vis () then
    vfsm2id vfsm
;
non_lazy get_current_idv_window;

let fl_update_colors c =
    let vfsm = w2vfsm c then
    update_colors vfsm
;
export_to_tcl fl_update_colors;


// Version 1: Fails often
let bdepends_on exprs cprefix =
    val (check, other) = split (\v. string_hd v = cprefix) (bdepends exprs) then
    check = [] => F |
    let sub = map (\n. n, bvariable ("_##_"^n)) check then
    let exprs' = bsubstitute sub exprs then
    let cmp (H1,L1) (H2,L2) = (H1 bXOR H2) bOR (L1 bXOR L2) in
    let diff = itlist (defix bOR) (map2 cmp exprs exprs') bF then
    ((bget_model [diff] 10) != []) catch T
;

// Version 2: Slow but can often solve the problem
let bdepends_on exprs cprefix =
    let tst1 E v =
	let E0 = bsubstitute [(v,bF)] E then
	let E1 = bsubstitute [(v,bT)] E then
	let diff = E0 bXOR E1 then
	bget_model [diff] 10
    in
    letrec check Es (v:vs) =
        letrec ch1 (e:es) =
            let res = tst1 e v then
            res = [] => ch1 es | T
         /\    ch1 [] = F
        in
        (ch1 Es) => T | (check Es vs)
     /\   check Es [] = F
    in
    let Es = flatmap (\(H,L).[H,L]) exprs then
    let vs = filter (\v. string_hd v = cprefix) (bdepends Es) then
    vs = [] => F |
    check Es vs
;


clet get_dependency_color ste t vecs =
    let nds = md_expand_vectors vecs then
    let type = get_ste_type ste then
    let deps =
	type = "bdd" =>
	    let vs = (map (\n. get_trace_val ste n t) nds) catch [] then
	    setify (map string_hd (get_abstract_depends ste vs))
	|
	type = "bexpr" =>
	    let vs = (map (\n. bget_trace_val ste n t) nds) catch [] then
	    let pots = setify (map string_hd (bdepends vs)) then
	    filter (bdepends_on vs) pots
	|
	eprintf "get_dependency_color on non-binary (%s) STE run" type
    then
    deps = [] => "" |
    deps = ["b"] => "blue" |
    deps = ["r"] => "red" |
    (mem "r" deps) AND (mem "b" deps) => "pink" |
    "yellow"
;


let fl_get_bdd_color c an =
    let vis   = evis2vis (canvas2vis c) then
    let ste   = canvas2ste c then
    let t     = deref (canvas2current_time_r c) then
    let vecs  = visualization_anon2real vis an in
    let col   = get_dependency_color ste t vecs then
    col = "" => "white" | col
;
export_to_tcl fl_get_bdd_color;

let base_get_waveform w vec min_time max_time show_depend =
    let ste = canvas2ste w then
    let type = get_ste_type ste then
    let nds = md_expand_vector vec in
    let opt_states = node2value_list (ste2fsm ste) (hd nds) in
    let max_time = (max_time < 0) => get_ste_maxtime ste | max_time then
    type = "bdd" =>
        let traces =
	    (map (limited_get_trace ste min_time max_time) nds) catch []
	then
        traces = [] => [(max_time,"X", "white"),(0,"-", "white")] |
        let vec_trace = merge_traces traces then
        let mk_tr (time,vals) =
	    let color = 
		NOT show_depend => "-" |
		let col = get_dependency_color ste time [vec] then
		col == "" => "-" | col
	    in
            let val2s HL =
                HL == (T,F) => "1" |
                HL == (F,T) => "0" |
                HL == (T,T) => "X" |
                HL == (F,F) => "*" |
                val (H,L) = HL in
                (H == NOT L) => "S" |
                (NOT L AND NOT H) == F =>
                   H == T => "S0X" |
                   L == T => "SX1" |
                   "S0X1"
                |
                "*"
            in  
            let vs = map val2s vals then
            let alts = setify vs then
            let sv =
                (alts subtract ["0","1"]) = [] =>
                    let s = implode vs then
		    opt_states != [] =>
                        // An ENUM (e.g. state machine)
			let i = sscanf "%b" s in
			(assoc i opt_states) catch "-"
                    |   
		    let i = sscanf "%b" s in
		    let res =
			let txt = length nds >= 4 => sprintf "0x%x" i
					      | (implode vs)
			in
			(find_pretty_printer vec i)
			catch txt
		    then
		    res
                |
                length alts = 1 => hd alts |
                list2str T "{" "," "}" id (compress vs)
            in
            (time, sv, color)
        in
        map mk_tr vec_trace
    |
    eprintf "base_get_waveform not implemented yet for %s" type
;

let _fl_get_waveform_ref = ref [(1,"","")];

let fl_get_waveform_cnt w vec min_time max_time show_depend =
    let res = base_get_waveform w vec min_time max_time show_depend then
    (_fl_get_waveform_ref := res) fseq
    (length res+99)/100
;
export_to_tcl fl_get_waveform_cnt;

let fl_get_waveform_res idx =
    let rem = butfirstn (idx*100) (deref _fl_get_waveform_ref) then
    length rem <= 100 => rem | firstn 100 rem
;
export_to_tcl fl_get_waveform_res;


let selection_list = ref {[] :: string list};

let fl_clear_selection_list {dummy::void} =
    selection_list := []
;
non_lazy fl_clear_selection_list;
export_to_tcl fl_clear_selection_list;

let fl_add_to_selection_list vec =
    (selection_list := (vec : (deref selection_list)))
;
export_to_tcl fl_add_to_selection_list;


let set_selection canvas {op::string} {vecs:: string list} =
    let vfsm = w2vfsm canvas then
    let active_canvases = deref (vfsm2canvases_r vfsm) then
    let rselection = vfsm2selection_r vfsm then
    let old_selection = deref rselection then
    let set_selection vsel =
	(rselection := vsel) fseq
	(fl_update_colors canvas) fseq
	let rnds = extract_vectors vsel then
	let set1 v = sprintf "lappend ::x_selection {%s}" v in
	let cmds = ["selection clear", "catch {unset ::x_selection}"]
		   @ (map set1 rnds)
		   @ ["selection own ."]
	in
	(big_tcl_eval cmds) fseq ()
    in
    op = "SET_SELECTION" =>
	vecs = ["_"] => set_selection [] | set_selection vecs
    |
    op = "MODIFY_SELECTION" =>
	vecs = ["_"] => () |
	let to_remove = old_selection intersect vecs then
	let new_selection = (vecs union old_selection) subtract to_remove then
	set_selection new_selection
    |
    (fprintf stderr "Unknown selection command (%s)\n" op)
;

let fl_set_selection canvas {op::string} =
    let vecs = deref selection_list then
    set_selection canvas op vecs
;
export_to_tcl fl_set_selection;

let fl_get_anon_selected canvas =
    let vfsm = w2vfsm canvas then
    let rselection = vfsm2selection_r vfsm then
    let cur_selection = deref rselection then
    cur_selection
;
export_to_tcl fl_get_anon_selected;


let fl_top_level_add_stop_nd w vec =
    let vfsm = w2vfsm w then
    let stop_list_r = vfsm2stop_list_r vfsm then
    let old = deref stop_list_r then
    (stop_list_r := ([vec] union old))
;
export_to_tcl fl_top_level_add_stop_nd;

let fl_add_stop_nd canvas tag =
    let vfsm = w2vfsm canvas then
    let stop_list_r = vfsm2stop_list_r vfsm then
    let vecs = fl_tag2vec canvas tag then
    let old = deref stop_list_r then
    (stop_list_r := (vecs union old)) fseq
    (visualization_set_stop_nodes (evis2vis (canvas2vis canvas))
				  (deref stop_list_r))
;
export_to_tcl fl_add_stop_nd;

let fl_get_stop_nodes canvas =
    let vfsm = w2vfsm canvas then
    let stop_list_r = vfsm2stop_list_r vfsm then
    let res = qsort node_name_cmp (deref stop_list_r) then
    res
;
export_to_tcl fl_get_stop_nodes;

let fl_delete_stop_nd canvas vec =
    let vfsm = w2vfsm canvas then
    let stop_list_r = vfsm2stop_list_r vfsm then
    let old = deref stop_list_r then
    (stop_list_r := (old subtract [vec])) fseq
    ((visualization_set_stop_nodes (evis2vis (canvas2vis canvas))
				   (deref stop_list_r))
     catch ())
;
export_to_tcl fl_delete_stop_nd;

let fl_expand_fanin c draw_level levels tag =
    (start_draw_op c) fseq
    let vis = evis2vis (canvas2vis c) then
    let vis = visualize_expand_fanin vis tag levels draw_level then
    let cmd =
	let tab = canvas2tab c then
	let vec =
	    let tags = visualization_anon2real vis tag then
	    list2str T "[" "," "]" (sprintf "\"%s\"") tags
	then
	sprintf "expand_fanin vis %s (%d) %d %s;" tab draw_level levels vec
    then
    (add_command (w2vfsm c) cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
                sprintf "draw_network %s $%s" c final_res,
                "update",
                sprintf "bind %s <Map> {fl_update_colors %s}"  c c,
                sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
              ]) fseq
    ()
;
export_to_tcl fl_expand_fanin;

let fl_undo_expansion c =
    (start_draw_op c) fseq
    let vis = evis2vis (canvas2vis c) then
    let vis = visualize_undo vis then
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
                sprintf "draw_network %s $%s" c final_res,
                "update",
                sprintf "bind %s <Map> {fl_update_colors %s}"  c c,
		sprintf "fl_update_colors %s"  c,
                sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
              ]) fseq
    ()
;
export_to_tcl fl_undo_expansion;

let fl_hide_fanin c tag make_it_stop_node =
    (start_draw_op c) fseq
    (make_it_stop_node => (fl_add_stop_nd c tag) | ()) fseq
    let vis = evis2vis (canvas2vis c) then
    let vis = visualize_hide_fanin vis tag (-1) then
    let cmd =
	let v = list2str T "[" ", " "]" (sprintf "\"%s\"") (fl_tag2vec c tag) in
	sprintf "draw_hide vis %s %s %s;" (canvas2tab c) v
					  (make_it_stop_node => "T" | "F")
    in
    (add_command (w2vfsm c) cmd) fseq
    val (final_res, cmds) = visualisation2tcl vis then
    (big_tcl_eval ("create_sch":cmds)) fseq
    (tcl_eval [
                sprintf "draw_network %s $%s" c final_res,
                "update",
                sprintf "bind %s <Map> {fl_update_colors %s}"  c c,
		sprintf "fl_update_colors %s"  c,
                sprintf "set_scrollregion %s" c,
                sprintf "sc:remove_draw_info %s" c
              ]) fseq
    ()
;
export_to_tcl fl_hide_fanin;

let fl_get_sch_commands w =
    let vfsm = w2vfsm w then
    let res = deref (vfsm2cmds_r vfsm) then
    res
;
export_to_tcl fl_get_sch_commands;


// Create random inputs to the circuit and simulate it.
//
//  ckt	    an fsm to simulate
//
//  clks    a list of (name,pat) pairs where name refers to the
//	    clock signal and pat describes the (infinitely) repeating pattern.
//
//  resets  a list of (name,pat) pairs where name refers to the
//	    reset signal and pat describes the first phases to invoke the
//	    reset of the circuit. If the final value of the reset pattern
//	    is -, then the signal will be given random inputs. If the final
//	    value is 0 or 1, this value will be repeated infinitely often.
//
//  cnt	    for how many phases the circuit should be simulated.
//
// Usage:
// random_simulation vis clks resets cnt;
//
let random_simulation_fsm ckt clks resets cnt =
    let s2b s = s = "0" => F | s = "1" => T |
		eprintf "Pattern with non-0/1 value (%s)" s
    in
    // Clocks
    let mk_clk (clk,pat) =
	pat = "" => eprintf "Clk %s not given a pattern" clk |
	let vs = map s2b (explode pat) in
	let len = length vs in
	let all =
	    firstn (cnt+1) (flat (replicate ((cnt+2*len)/len) vs))
	then
	let mk v t = (T,clk,v,t,t+1) in
	map2 mk all (0 upto (length all-1))
    in
    let clk_ant = flatmap mk_clk clks then
    let clk_nds = map fst clks then
    // Resets
    let mk_reset (reset,pat) =
	let ps = explode pat in
	let final = last ps in
	let initial = butlast ps in
	let len = length initial in
	let mk v t = (T,reset,v,t,t+1) in
	let ant0 = map2 mk (map s2b initial) (0 upto (len-1)) in
	final = "-"  =>
	    let mk_random t = (T,reset,(random 0 1)=1,t,t+1) in
	    ant0@(map mk_random (len upto cnt))
	|
	(T,reset,s2b final,len,cnt):ant0
    in
    let reset_ant = flatmap mk_reset resets then
    let reset_nds = map fst resets then
    //
    let raw_inps = md_expand_vectors (inputs ckt) in
    let inps = raw_inps subtract (clk_nds@reset_nds) in
    letrec mk_at_time t (nd:nds) =
        t < 0 => [] |
        let v = (random 0 1) = 1 in
        (T,nd,v,t,t+1):(mk_at_time t nds)
     /\    mk_at_time t [] = mk_at_time (t-1) inps
    in
    let ant_inps = inps = [] => [] | mk_at_time cnt inps then
    //
    let ant = clk_ant@reset_ant@ant_inps in
    STE "-e" ckt [] ant [] []
;

// Create random inputs to the circuit and simulate it.
//
//  vis	    an active STE_debug canvas
//
//  clks    a list of (name,pat) pairs where name refers to the
//	    clock signal and pat describes the (infinitely) repeating pattern.
//
//  resets  a list of (name,pat) pairs where name refers to the
//	    reset signal and pat describes the first phases to invoke the
//	    reset of the circuit. If the final value of the reset pattern
//	    is -, then the signal will be given random inputs. If the final
//	    value is 0 or 1, this value will be repeated infinitely often.
//
//  cnt	    for how many phases the circuit should be simulated.
//
// Usage:
// random_simulation vis clks resets cnt;
//
let random_simulation_vis vis clks resets cnt =
    let ckt = vfsm2fsm vis in
    let s2b s = s = "0" => F | s = "1" => T |
		eprintf "Pattern with non-0/1 value (%s)" s
    in
    // Clocks
    let mk_clk (clk,pat) =
	pat = "" => eprintf "Clk %s not given a pattern" clk |
	let vs = map s2b (explode pat) in
	let len = length vs in
	let all =
	    firstn (cnt+1) (flat (replicate ((cnt+2*len)/len) vs))
	then
	let mk v t = (T,clk,v,t,t+1) in
	map2 mk all (0 upto (length all-1))
    in
    let clk_ant = flatmap mk_clk clks then
    let clk_nds = map fst clks then
    // Resets
    let mk_reset (reset,pat) =
	let ps = explode pat in
	let final = last ps in
	let initial = butlast ps in
	let len = length initial in
	let mk v t = (T,reset,v,t,t+1) in
	let ant0 = map2 mk (map s2b initial) (0 upto (len-1)) in
	final = "-"  =>
	    let mk_random t = (T,reset,(random 0 1)=1,t,t+1) in
	    ant0@(map mk_random (len upto cnt))
	|
	(T,reset,s2b final,len,cnt):ant0
    in
    let reset_ant = flatmap mk_reset resets then
    let reset_nds = map fst resets then
    //
    let raw_inps = md_expand_vectors (inputs ckt) in
    let inps = raw_inps subtract (clk_nds@reset_nds) in
    letrec mk_at_time t (nd:nds) =
        t < 0 => [] |
        let v = (random 0 1) = 1 in
        (T,nd,v,t,t+1):(mk_at_time t nds)
     /\    mk_at_time t [] = mk_at_time (t-1) inps
    in
    let ant_inps = inps = [] => [] | mk_at_time cnt inps then
    //
    let ant = clk_ant@reset_ant@ant_inps in
    STE "-e" vis [] ant [] []
;

overload random_simulation random_simulation_fsm random_simulation_vis;

let fl_load_waveforms file = (load file) fseq ();
export_to_tcl fl_load_waveforms;

// ======================================================================
//  fl API to drawing routine(s)
// ======================================================================

let check_valid_vectors vfsm op vs =
    let ckt = vfsm2fsm vfsm in
    let nds = md_expand_vectors vs in
    let missing = filter (\n. NOT (is_node ckt n)) nds in
    missing = [] => () |
    eprintf "Invalid vector(s) in %s %S\n" op (md_extract_vectors missing)
;

// Draw a fanin cone from the vectors in vecs.
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
//
// hierarchy_level: At which level of drawing hierarchy to draw the fanin
//		    Top-level is 0.
//		    If -1 is given, the drawing will be at a leaf level
//		    (basically all draw_hier will be ignored)
//
// levels:	    How many levels of (user-given) circuits backwards should
//		    be drawn.
//
// vecs:	    The list of vectors to end at (whose fanins to draw)
//
// Returns the name of the canvas for the new fanin drawing.
//
let draw_fanin vfsm hierarchy_level levels vecs =
    (check_valid_vectors vfsm "draw_fanin" vecs) fseq
    (gen_draw_fanin vfsm hierarchy_level levels vecs)
;


// Draw the inside of a block
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
//
// hierarchy_level: At which level of drawing hierarchy shold the visualization
//		    be done at.
//		    It needs to be >= 1.
//
// vecs:	    The list of vectors to end at (whose fanins to draw)
//
// Returns the name of the canvas for the new fanin drawing.
//
let draw_inside vfsm hierarchy_level vecs =
    (check_valid_vectors vfsm "draw_inside" vecs) fseq
    let c = get_current_canvas () then
    gen_draw_inside vfsm c (hierarchy_level-1) vecs 0
;

// Hide a subtree
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
// vecs:	    The vector to hide
// stop:	    Make the node also a global stop node
//
let draw_hide {vfsm::vfsm} tab vecs stop =
    (check_valid_vectors vfsm "draw_hide" vecs) fseq
    let anons = (fl_vecs2tags tab vecs) then
    anons = [] => eprintf "Cannot find anon names for %S in %s\n" vecs tab |
    let anon = hd anons in
    (tcl_eval [sprintf "cb:hide_fanin %s %s %d" tab anon (stop=>1|0)]) fseq
    ()
;


// Add the waveforms for the vectors in vecs.
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
//
//
// vecs:	    The list of vectors to end at (whose fanins to draw)
//
let add_waveform vfsm vecs =
    (check_valid_vectors vfsm "add_waveform" vecs) fseq
    let w = vfsm2id vfsm then
    let ww = sprintf "%s.nb.waveform" w then
    let cmds = map (\v. sprintf "wv:prim_add_waveform %s {%s}" ww v) vecs in
    (foreach (fl_record_waveform_addition w) vecs) fseq
    (tcl_eval (cmds@[sprintf "wv:set_time_pointer %s {}" ww, "update"])) fseq
    ()
;

// Delete waveform 
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
//
//
// idx:		    Which waveform (starting from 0) to delete
//
let delete_waveform vfsm idx =
    let ww = deref (vfsm2wvr vfsm) then
    let nn = sprintf "%s.panes.name_frame.names" ww in
    let cmd = sprintf "wv:delete_waveform %s %d" nn idx in
    (tcl_eval [cmd, sprintf "wv:set_time_pointer %s {}" ww, "update"]) fseq
    ()
;

// Move waveform up or down
//
// Arguments:
// vfsm:	    A visualization GUI started with STE_debug.
//
// idx:		    Which waveform (starting from 0) to delete
//
// dir:		    1/-1 direction to mve the waveform (1=down, -1=up)
//
let move_waveform vfsm idx dir =
    let ww = deref (vfsm2wvr vfsm) then
    let nn = sprintf "%s.panes.name_frame.names" ww in
    let cmd = sprintf "wv:move_waveform %s %d %d" nn idx dir in
    (tcl_eval [cmd, sprintf "wv:set_time_pointer %s {}" ww, "update"]) fseq
    ()
;

// Set the global time to be t in visualization GUI vfsm.
// Returns the old time.
//
let draw_set_time vfsm t =
    let w = (vfsm2id vfsm) then
    let old = tcl_eval [sprintf "set ::vstatus(time,%s)" w] then
    (tcl_eval [sprintf "set ::vstatus(time,%s) %d" w t, "update"]) fseq
    sscanf "%d" old
;

// Set the visible window in the waveform viewer to be between t_min and t_max.
let draw_set_minmax vfsm t_min t_max =
    let w = (vfsm2id vfsm) then
    (tcl_eval [
	sprintf "set ::wv_info(min_time_to_show,[w2root %s]) %d" w t_min,
	sprintf "set ::wv_info(max_time_to_show,[w2root %s]) %d" w t_max,
	sprintf "gui:update_minmax %s.nb.waveform" w
    ]) fseq ()
;

// Get the vsfm named 'name'
let name2vfsm name = w2vfsm name;

//
let expand_fanin {vsfm::vfsm} c draw_level levels vecs =
    let tags = fl_vecs2tags c vecs then
    length tags != 1 =>
	eprintf "expand_fanin can only be used on a single vector (%S)" vecs
    |
    fl_expand_fanin c draw_level levels (hd tags)
;


// Turn on/off backannotation of values on canvas c.
let draw_show_values {vis::vfsm} c show =
    let cur = tcl_eval [sprintf "set ::vstatus(show_value,%s)" c] then
    let toggle = show XOR (cur = "1") then
    NOT toggle => () |
    ((tcl_eval [
	sprintf "set ::vstatus(show_value,%s) %s" c (show => "1" | "0"),
	sprintf "sch:toggle_show_value_buttons %s [winfo parent %s].menu" c c,
	"update"]
    ) fseq ())
;


// Turn on/off backannotation of values on canvas c.
let draw_show_dependencies {vis::vfsm} c show =
    let cur = tcl_eval [sprintf "set ::vstatus(show_bdd_group,%s)" c] then
    let toggle = show XOR (cur = "1") then
    NOT toggle => () |
    ((tcl_eval [
	sprintf "set ::vstatus(show_bdd_group,%s) %s" c (show => "1" | "0"),
	sprintf "sch:toggle_show_value_buttons %s [winfo parent %s].menu" c c,
	"update"]
    ) fseq ())
;
