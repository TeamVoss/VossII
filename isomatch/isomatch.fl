load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");
load (DIR^"lib/ullman.fl");

let ?! = undefined;

//==============================================================================
//
// Construction of a subst. eq. between two pexlifs.
//
//==============================================================================

// Merge two subst., fails if any is empty.
//  @@::(subst opt)->(subst opt)->(subst opt)
let
    @@ (SOME x) (SOME y) = SOME (x @ y)
/\  @@ _        _        = NONE
;
infix 9 @@;

// Merge a list of opt. subst., fails if any is empty.
//  collect::((subst opt) list)->(subst opt)
let collect ss = itlist (defix @@) ss (SOME []);

// For every pair '(x,y)' in 's', 'assoc x s == y' and 'rev_assoc y s == x'.
//  coherent::subst->bool
let coherent s = all (\(u,t). all (\(x,y). (u == x) <==> (t == y)) s) s;

//------------------------------------------------------------------------------

// Find a subst., if any, s.t. both expressions are equal.
// TODO: Some missing cases.
//  alpha::wexpr->wexpr->subst
letrec
    alpha (W_X _)       (W_X _)       = SOME []
/\  alpha (W_CONST _ _) (W_CONST _ _) = SOME []
/\  alpha (W_VAR _ n)   (W_VAR _ m)   = SOME [(n,m)]
/\  alpha (W_NAMED_CONST n _ _) (W_NAMED_CONST m _ _) = SOME [(n,m)]
/\  alpha (W_EXPLICIT_VAR _ n)  (W_EXPLICIT_VAR _ m)  = SOME [(n,m)]
/\  alpha (W_AND a b)   (W_AND x y)   = alpha a x @@ alpha b y
/\  alpha (W_OR a b)    (W_OR x y)    = alpha a x @@ alpha b y
/\  alpha (W_NOT a)     (W_NOT x)     = alpha a x
/\  alpha (W_EQ a b)    (W_EQ x y)    = alpha a x @@ alpha b y
/\  alpha (W_GR a b)    (W_GR x y)    = alpha a x @@ alpha b y
/\  alpha (W_ADD a b)   (W_ADD x y)   = alpha a x @@ alpha b y
/\  alpha (W_SUB a b)   (W_SUB x y)   = alpha a x @@ alpha b y
/\  alpha (W_MUL a b)   (W_MUL x y)   = alpha a x @@ alpha b y
/\  alpha (W_DIV a b)   (W_DIV x y)   = alpha a x @@ alpha b y
/\  alpha (W_MOD a b)   (W_MOD x y)   = alpha a x @@ alpha b y
/\  alpha (W_SHL a b)   (W_SHL x y)   = alpha a x @@ alpha b y
/\  alpha (W_SHR a b)   (W_SHR x y)   = alpha a x @@ alpha b y
/\  alpha (W_ASHR a b)  (W_ASHR x y)  = alpha a x @@ alpha b y
/\  alpha (W_SX _ a)    (W_SX _ x)    = alpha a x
/\  alpha (W_ZX _ a)    (W_ZX _ x)    = alpha a x
/\  alpha (W_ITE a b c) (W_ITE x y z) = alpha a x @@ alpha b y @@ alpha c z
/\  alpha _ _ = NONE
;

// Find a subst., if any, s.t. both update functions are equal.
//  alpha_fn::update_fn->update_fn->subst
let
    alpha_fn (W_UPDATE_FN a b)   (W_UPDATE_FN x y)   = alpha a x @@ alpha b y
/\  alpha_fn (W_PHASE_DELAY a b) (W_PHASE_DELAY x y) = alpha a x @@ alpha b y
/\  alpha_fn _ _ = NONE
;

// Find subst., if any, s.t. both sets of functions are equal.
//  alpha_leaf::content->content->subst
let
    alpha_leaf (P_LEAF fs) (P_LEAF gs) =
        let
            verify (SOME x) = coherent x => SOME x | NONE
        /\  verify _        = NONE
        in
        let test = verify # collect # map2 alpha_fn fs in
        exhaust (map test (permutations gs))
;

//------------------------------------------------------------------------------

// Given an SHA eq. between 'p' and 'g', construct a formal subst.
//  actualize_sha::pexlif->pexlif->(subst opt)
let
    actualize_sha p g =
        SOME (zip (actuals p) (actuals g))
;

// Find formal subst. for two leaf pexlif's.
//  actualize_leaf::pexlif->pexlif->(subst opt)
let
    actualize_leaf (PINST _ _ _ i1 o1 _ l1) (PINST _ _ _ i2 o2 _ l2) =
        let lift = actualize (i1 @ o1) (i2 @ o2) in
        maybe NONE (alpha_leaf l1 l2) (SOME # lift)
;

// Given a list of subst. of actuals for their children, find formal subst.
//  actualize_hier::((subst opt) list)->pexlif->pexlif->(subst opt)
let
    actualize_hier ss (PINST _ _ _ i1 o1 _ _) (PINST _ _ _ i2 o2 _ _) =
        let lift = actualize (i1 @ o1) (i2 @ o2) in
        maybe NONE (collect ss) (\s. coherent s => SOME (lift s) | NONE)
;

//==============================================================================
//
// Construction of adj. & iso. matrices.
//
//==============================================================================

// Memoized fetch of a pexlif's fingerprint and SHA signature.
//   fp&sig::pexlif->string
clet fp   = find_fingerprint # _pexlif_attrs;
clet sig  = find_signature   # _pexlif_attrs;

// Fetch a pexlif's children.
//  hier::pexlif->(pexlif list)
let hier (PINST _ _ _ _ _ _ (P_HIER cs)) = cs;

// Check if the lists 'x' and 'y' share any elements.
//  intersects::(* list)->(* list)->bool
let intersects x y = NOT (empty (x intersect y) OR empty x OR empty y);
infix 7 intersects;

// Matrix over each node's relation ('cmp') to every other node.
//  compare_all::(*->*->bool)->(* list)->((* list) list)
let
    compare_all cmp xs =
        letrec
            build [] = []
        /\  build (x:xs) = (F : map (cmp x) xs) : build xs
        in
        letrec
            fill [] = []
        /\  fill (x:xs) = x : map2 cons (tl x) (fill xs)
        in
        fill (build xs)
;

//------------------------------------------------------------------------------

// ...
//  expand::pexlif->[string]
let expand = flatmap md_expand_vector;

// ...
//  child_of::pexlif->pexlif->bool
clet
    child_of x y =
        let child_slow x y = (expand (formals x)) intersects (expand (actuals y)) in
        let child_fast x y = (formals x) intersects (actuals y) in
        IF child_fast x y THEN T ELSE child_slow x y
;

// ...
//  sibling_of::pexlif->pexlif->bool
clet
    sibling_of x y =
        let sibling_slow x y = (expand (actuals x)) intersects (expand (actuals y)) in
        let sibling_fast x y = (actuals x) intersects (actuals y) in
        IF sibling_fast x y THEN T ELSE sibling_slow x y
;

// Construct adj. matrix for 'pex' when "flattened" one level.
//  adjacencies::pexlif->(bool mat)
clet
    adjacencies parent =
        let children = hier parent in
        // Compute adj. for "parent<->child".
        let adj_parent   = F : map (child_of parent) children in
        // Compute adj. for "child<->child".
        let adj_children = compare_all sibling_of children in
        // Merge above two adj. matrices.
        let adj = adj_parent : map2 cons (tl adj_parent) adj_children in
        // Done.
// (fprintf stderr "### adjacencies for '%s' with %d children %S:\n%s\n"
//     (_pexlif_name parent)
//     (length children)
//     (map _pexlif_name children)
//     (print_large_matrix print_bool (mat_tl adj))
// ) fseq
        adj
;

// Construct iso. matrix between 'pex' and 'qex' when "flattened" one level.
//  isomorphisms::pexlif->pexlif->(bool mat)
let
    isomorphisms pex qex =
        // Fetch parent&children.
        let xs = pex : hier pex in
        let ys = qex : hier qex in
        // Compare every pos. pairing.
        let iso = map (flip map ys # equal on fp) xs then
        // Done.
// (fprintf stderr "### isomorphisms for '%s' and '%s':\n%s\n"
//     (_pexlif_name pex)
//     (_pexlif_name qex)
//     (print_large_matrix print_bool (mat_tl iso))
// ) fseq
        iso
;

//==============================================================================
//
// Isomatch. searching.
//
//==============================================================================

// Find el. given by mask 'xs' (one and only one el. of 'xs' must be 'T').
//  find_mask::(bool list)->(* list)->*
letrec
    find_mask (F:xs) (y:ys) = find_mask xs ys
/\  find_mask (T:xs) (y:ys) = y
;

// Expand list of choices, i.e, '[[1,2],[3,4]] = [[1,3],[1,4],[2,3],[2,4]]'.
//  expand_choices::((* list) list)->((* list) list)
letrec
    expand_choices []       = []
/\  expand_choices (xs:[])  = map (\x. [x]) xs
/\  expand_choices (xs:xss) = flatmap (\x. map (\ys. x:ys) (expand_choices xss)) xs
;

//------------------------------------------------------------------------------

// Exand a matching of 'p' and 'g' to test whether it's valid pairing or not.
//
// expand(P, G)
//     S = recurse(none, 1, adj(P), adj(G), iso(P, G))
//     for all solutions R in S
//         explore all pairings X of children in P and G according to R
//
forward_declare{explore::pexlif->pexlif->({((string#string) list)} opt list)};
//  expand::pexlif->pexlif->(({(string#string list)} opt list) list)
let
    expand p g =
        //
(fprintf stderr "expanding '%s' and '%s'\n" (_pexlif_name p) (_pexlif_name g)) fseq
        //
        // Find possible solutions for a 'p' and 'g' mapping.
        //let adj_p = adjacencies p then
        //let adj_g = adjacencies g then
        let iso   = isomorphisms p g then
        let ss    = recurse iso then //adj_p adj_g then
        // Explore each pairing in a solution to validate it.
        let g_flat = g : hier g in
        pam (filter (hd # hd) ss) (\sol.
            let matches = map (\col. find_mask col (g : hier g)) (tl sol) then
            let options = map2 explore (hier p) matches then
            let choices = expand_choices options then
            let res     = map collect choices then
            //
            res
        )
;

// Explore two pexlifs to find if they are a potential match.
//
// explore(P, G)
//     if P == G
//         report direct mapping
//     else if P ~ G
//         if P and G are leafs
//             report subst. s.t. P == G, if any.
//         else if P and G are hierarchies
//             CS = sets of possible subst. s.t. P == G
//             report each coherent choice C in CS
//     else
//         report no solution
//
let
    explore p g =
        let leaf = _pexlif_leaf then
// (fprintf stderr "exploring '%s' and '%s'\n" (_pexlif_name p) (_pexlif_name g)) fseq
        IF sig p == sig g THEN
            let x = [actualize_sha p g] then
// (fprintf stderr "> signatures matched!\n") fseq
            x
        ELSE IF fp p == fp g THEN
            IF leaf p AND leaf g THEN
// (fprintf stderr ">both leaf.\n") fseq
                let x = [actualize_leaf p g] then
// (fprintf stderr "found %d sols. while exploring leafs '%s' and '%s'.\n" (num_some x) (_pexlif_name p) (_pexlif_name g)) fseq
                x
            ELSE
// (fprintf stderr ">both hier.\n") fseq
                let x = map (\ss. actualize_hier ss p g) (expand p g) then
// (fprintf stderr "found %d sols. while exploring hiers. '%s' and '%s'.\n" (num_some x) (_pexlif_name p) (_pexlif_name g)) fseq
                x
        ELSE
// (fprintf stderr "> no match!") fseq
            []
;

//==============================================================================
//
// Main.
//
//==============================================================================

//  clean_subst::(string list)->subst->subst
let clean_subst f = filter (flip elem f # fst);

//  clean_solution::pexlif->(subst list)->(subst list)
let clean_solution p = map (clean_subst (formals p));

//  recover_matches::pexlif->pexlif->((bool mat) list)->(((pexlif#pexlif) list) list)
let recover_matches p g iso = map (map2 (\n. \r. (n, find_mask r (hier g))) (hier p)) iso;

//------------------------------------------------------------------------------

//  print_subst::((string#string) list)->string
let print_subst = print_list (curry print_pair);

//  print_solution::((subst opt) list)->string
let print_solution = print_list print_subst # filter_some;

//  pretty::((pexlif#pexlif) list)->((subst list) list)->void
let pretty p g ms ss =
        let
            pretty_header =
                (fprintf stdout "Found match for '%s' and '%s'\n"
                    (_pexlif_name p)
                    (_pexlif_name g))
        in
        let
            pretty_one (a,b) s =
                (fprintf stdout "matching '%s' and '%s' %s"
                    (_pexlif_name a)
                    (_pexlif_name b)
                    (list2str T "where " " or " "\n" (print_subst) s))
        in
        pretty_header fseq
        foreach (curry pretty_one) (zip ms ss)
;

//------------------------------------------------------------------------------

let
    pex_length (PINST _ _ _ _ _ _ (P_HIER cs)) = 1 + length cs
/\  pex_length _ = 1
;

// Isomatch and pretty-print.
//  moo::pexlif->pexlif->void
let
    moo p g =
        let ok_p = mk_needle p (pex_length p) then
        let ok_g = mk_haystack g (pex_length g) then
        let iso  = isomorphisms p g then
        // ...
        IF NOT (ok_p AND ok_g) THEN (fprintf stderr "Not OK!") ELSE
        // ...
        // todo: mat_tl (adjacencies p)
        // todo: mat_tl (adjacencies g)
        let iso' = mat_tl iso then
        let ss   = recurse iso' then
        // ...
        flip foreach ss (\sol.
            //  matches::(pexlif list)
            let matches = map (flip find_mask (hier g)) sol then
            //  pairs::(pexlif#pexlif list)
            let pairs   = zip (hier p) matches then
            //  options::(((subst opt) list) list)
            let options = map (curry explore) pairs then
            //  choices::(((subst opt) list) list)
            let choices = expand_choices options then
            //  res::((subst list) list)
            let res = map filter_some options then
            //
            pretty p g pairs res
        )
;

//==============================================================================
// Fin.