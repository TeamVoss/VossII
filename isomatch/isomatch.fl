load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");
//load (DIR^"lib/ullman.fl");

let ?! = undefined;

//==============================================================================
//
//
//
//==============================================================================

lettype ann_pex =
        ANN
            {pex::pexlif}
;

let _pex (ANN p) = p;

let _hier (PINST _ _ _ _ _ _ (P_HIER cs)) = cs;
let _fp  = find_fingerprint # _pexlif_attrs;
let _sig = find_signature # _pexlif_attrs;

//==============================================================================
//
// ...
//
//==============================================================================

// ...
//  @@::(subst opt)->(subst opt)->(subst opt)
let
    @@ (SOME x) (SOME y) = SOME (x @ y)
/\  @@ _        _        = NONE
;
infix 9 @@;

// ...
//  collect::((subst opt) list)->(subst opt)
let collect ss = itlist (defix @@) ss (SOME []);

// For every pair '(x,y)' in 's', 'assoc x s == y' and 'rev_assoc y s == x'.
//  coherent::subst->bool
let coherent s = all (\(u,t). all (\(x,y). (u == x) <==> (t == y)) s) s;

//------------------------------------------------------------------------------

// Find a subst., if any, s.t. both expressions are equal.
//   TODO: Some missing cases.
letrec
    alpha (W_X _)       (W_X _)       = SOME []
/\  alpha (W_CONST _ _) (W_CONST _ _) = SOME []
/\  alpha (W_VAR _ n)   (W_VAR _ m)   = SOME [(n,m)]
/\  alpha (W_NAMED_CONST n _ _) (W_NAMED_CONST m _ _) = SOME [(n,m)]
/\  alpha (W_EXPLICIT_VAR _ n)  (W_EXPLICIT_VAR _ m)  = SOME [(n,m)]
/\  alpha (W_AND a b)   (W_AND x y)   = alpha a x @@ alpha b y
/\  alpha (W_OR a b)    (W_OR x y)    = alpha a x @@ alpha b y
/\  alpha (W_NOT a)     (W_NOT x)     = alpha a x
/\  alpha (W_EQ a b)    (W_EQ x y)    = alpha a x @@ alpha b y
/\  alpha (W_GR a b)    (W_GR x y)    = alpha a x @@ alpha b y
/\  alpha (W_ADD a b)   (W_ADD x y)   = alpha a x @@ alpha b y
/\  alpha (W_SUB a b)   (W_SUB x y)   = alpha a x @@ alpha b y
/\  alpha (W_MUL a b)   (W_MUL x y)   = alpha a x @@ alpha b y
/\  alpha (W_DIV a b)   (W_DIV x y)   = alpha a x @@ alpha b y
/\  alpha (W_MOD a b)   (W_MOD x y)   = alpha a x @@ alpha b y
/\  alpha (W_SHL a b)   (W_SHL x y)   = alpha a x @@ alpha b y
/\  alpha (W_SHR a b)   (W_SHR x y)   = alpha a x @@ alpha b y
/\  alpha (W_ASHR a b)  (W_ASHR x y)  = alpha a x @@ alpha b y
/\  alpha (W_SX _ a)    (W_SX _ x)    = alpha a x
/\  alpha (W_ZX _ a)    (W_ZX _ x)    = alpha a x
/\  alpha (W_ITE a b c) (W_ITE x y z) = alpha a x @@ alpha b y @@ alpha c z
/\  alpha _ _ = NONE
;

// Find a subst., if any, s.t. both update functions are equal.
let
    alpha_fn (W_UPDATE_FN a b)   (W_UPDATE_FN x y)   = alpha a x @@ alpha b y
/\  alpha_fn (W_PHASE_DELAY a b) (W_PHASE_DELAY x y) = alpha a x @@ alpha b y
/\  alpha_fn _ _ = NONE
;

// Find subst., if any, s.t. both sets of functions are equal.
let
    alpha_leaf (P_LEAF fs) (P_LEAF gs) =
        let
            verify (SOME x) = coherent x => SOME x | NONE
        /\  verify _        = NONE
        in
        let test = verify # collect # map2 alpha_fn fs in
        exhaust (map test (permutations gs))
;

//==============================================================================
// ...

let
    actualize_sha p g =
        val p_act = actuals (_pex p) in
        val g_act = actuals (_pex g) in
        //
        SOME (zip p_act g_act)
;

// ...
let
    actualize_leaf p g =
        val (PINST _ _ _ i1 o1 _ l1) = _pex p in
        val (PINST _ _ _ i2 o2 _ l2) = _pex g in
        //
        let lift = actualize (i1 @ o1) (i2 @ o2) in
        maybe NONE (alpha_leaf l1 l2) (SOME # lift)
;

// ...
let
    actualize_hier ss p g =
        val (PINST _ _ _ i1 o1 _ _) = _pex p in
        val (PINST _ _ _ i2 o2 _ _) = _pex g in
        //
        let lift = actualize (i1 @ o1) (i2 @ o2) in
        maybe NONE (collect ss) (\s. coherent s => SOME (lift s) | NONE)
;

//==============================================================================
//
// ...
//
//==============================================================================

// Check if the lists 'x' and 'y' share any elements.
let intersects x y = NOT (empty (x intersect y) OR empty x OR empty y);
infix 7 intersects;

//  Matrix over each node's relation ('cmp') to every other node.
let
    reflexive_compare_all cmp xs =
        letrec
            build [] = []
        /\  build (x:xs) = map (cmp x) xs : build xs
        in
        letrec
            fill [] = []
        /\  fill (x:xs) = x : map2 cons x (fill xs)
        in
        fill (build xs)
;

//------------------------------------------------------------------------------

// ...
let
    adjacencies ann =
        let child   x y = (formals x) intersects (actuals y) in
        let sibling x y = (actuals x) intersects (actuals y) in
        // Fetch parent/children.
        let parent   = _pex ann in
        let children = _hier parent in
        // Compute adj. for "parent<->child" and "child<->child".
        let adj_parent   = F : map (child parent) children in
        let adj_children = reflexive_compare_all sibling children in
        // Complete adj. mat. combines above two.
        adj_parent : map2 cons adj_parent adj_children
;

// ...
let
    isomorphisms ann bnn =
        // Fetch parent&children.
        let xs = _pex ann : _hier (_pex ann) in
        let ys = _pex bnn : _hier (_pex bnn) in
        // Compare every pos. pairing.
        map (flip map ys # equal on _fp) xs
;

//==============================================================================
//
// ...
//
//==============================================================================

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->a->((int#int)->a->a)->a
let forall_ones mat x f = itlist f (filter_rows id mat) x;

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = itlist f (filter_cols id (el i mat));

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Checks that list 'xs' does not contain any duplicates.
//  unique::(* list)->bool
let unique xs = setify xs == xs;

// ...
//  filter_mask::(bool list)->(* list)->(* list)
let filter_mask mask = snd # unzip # filter fst # zip mask;

//==============================================================================
// Solution checking.

// Check if 'mat' is well formatted.
//  single_morphism::(bool mat)->bool
let
    single_morphism mat =
        val (rs,cs) = unzip (filter_rows id mat) then
        unique rs AND unique cs
;

// Check if 'mat' is a valid morphism from 'g' to 'p'.
//  valid_morphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    valid_morphism mat p g =
        p == mult mat (transpose (mult mat g))
;

// Checks if 'mat' is a valid isomorphism.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat p g =
         single_morphism mat AND valid_morphism mat p g
;

//==============================================================================
// Pruning of match matrix.

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(M, P, G)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m p g =
        val m' =
            forall_ones m m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            )
        then m != m' => prune m' g p | m'
;

//==============================================================================
// ...

// ...
forward_declare{search::ann_pex->ann_pex->((({(string#string) list} opt) list) list)};
let
    explore p g =
        let sig  = _sig # _pex in
        let fp   = _fp  # _pex in
        let leaf = _pexlif_leaf # _pex in
        //
        IF sig p == sig g THEN
            [actualize_sha p g]
        ELSE IF fp p == fp g THEN
            IF leaf p AND leaf g THEN
                [actualize_leaf p g]
            ELSE
                map (\ss. actualize_hier ss p g) (search p g)
        ELSE
            []
;

//==============================================================================
// ...

// Ullman-esque isomorphism search.
//
// recurse(used, row, P, G, M)
//   if row = num_rows(M) + 1
//       if isomorphism(P, G, M)
//           report M as a solution
//   else
//       N = prune(M)
//       for all unused columns c in N[row]
//           N'    = zero all columns but c in N[row]
//           used' = mark c in used
//           recurse(used', row+1, P, G, N')
let
    recurse iso adj_p adj_g =
        let
            forall_unused iso row used f =
                let columns = filter_cols id (el row iso) in
                let unused  = filter_mask used columns in
                flatmap f unused
        in
        //
        let solution m = isomorphism m adj_p adj_g in
        let rows = num_rows iso in
        letrec
            search m used row =
                IF row == rows + 1 THEN
                    IF solution m THEN
                        [m]
                    ELSE
                        [ ]
                ELSE
                    let n = prune m adj_p adj_g then
		    forall_unused n row used (\col.
                        let n'    = modify (mark_one col) row n in
                        let used' = modify (const T) col used in
                        search n' used' (row+1))
        in
        search iso (replicate rows F) 1
;

//------------------------------------------------------------------------------

// ...
//  find_mask::(bool list)->(* list)->*
letrec
    find_mask (F:xs) (y:ys) = find_mask xs ys
/\  find_mask (T:xs) (y:ys) = y
;

// "expand_choices [[1,2],[3,4]] = [[1,3],[1,4],[2,3],[2,4]]"
//  expand_choices::((* list) list)->((* list) list)
letrec
    expand_choices []       = []
/\  expand_choices (xs:[])  = map (\x. [x]) xs
/\  expand_choices (xs:xss) = flatmap (\x. map (\ys. x:ys) (expand_choices xss)) xs
;

// Finds each possible matching of children for P and G and explores it.
//
// search(P, G)
//     S = recurse(none, 1, adj(P), adj(G), iso(P, G))
//     for all solutions R in S
//         for all pairings X of P and G according to R
//             explore(X)
let
    search p g =
        // Find possible solutions for a 'p' and 'g' mapping.
        let adj_p   = adjacencies p in
        let adj_g   = adjacencies g in
        let iso     = isomorphisms p g in
        let sols    = recurse iso adj_p adj_g in
        // Explore each pairing in a solution to validate it.
        let flat1 a = _pex a : _hier (_pex a) in
        let p_flat  = map ANN (flat1 p) in
        let g_flat  = map ANN (flat1 g) in
        pam sols (\sol.
            let g_matches = map (flip find_mask g_flat) sol in
            // Explore each matched pair.
            let options = map2 explore p_flat g_matches in
            // Construct list of all possible solutions.
            let choices = expand_choices options in
            // Merge substitutions for each choice.
            map collect choices
        )
;

//==============================================================================
// Fin.