load (DIR^"utils.fl");

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

//------------------------------------------------------------------------------

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->a->((int#int)->a->a)->a
let forall_ones mat x f = sitlist f (filter_rows id mat) x;

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Checks that list 'xs' does not contain any duplicates.
//  unique::(* list)->bool
let unique xs = setify xs == xs;

//==============================================================================
// Pruning of match matrix.

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(P, G, M)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            )
        then m != m' => prune m' g p | m'
;

//==============================================================================
// Solution checking.

// Check if 'mat' is well formatted.
//  single_morphism::(bool mat)->bool
let
    single_morphism mat =
        val (rs,cs) = unzip (filter_rows id mat) then
        unique rs AND unique cs
;

// Check if 'mat' is a valid morphism from 'g' to 'p'.
//  valid_morphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    valid_morphism mat p g =
        p == mult mat (transpose (mult mat g))
;

// Checks if 'mat' is a valid isomorphism.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat p g =
         single_morphism mat AND valid_morphism mat p g
;

//==============================================================================
// Matching algo.

// Recursively search for an isomorphism in 'P', 'G' and 'M'.
//
// recurse(used, row, P, G, M)
//   if row = num_rows(M) + 1
//       if isomorphism(P, G, M)
//           report M as a solution
//   else
//       N = prune(M)
//       for all unused columns c in N[row]
//           N'    = zero all columns but c in N[row]
//           used' = mark c in used
//           recurse(used', row+1, P, G, N')
let
    recurse iso adj_p adj_g =
        let
            forall_unused iso row used f =
                let columns = filter_cols id (el row iso) in
                let unused  = filter_mask used columns in
                flatmap f unused
        in
        //
        let solution m = isomorphism m adj_p adj_g in
        let rows = num_rows iso in
        letrec
            search m used row =
                IF row == rows + 1 THEN
                    IF solution m THEN
                        [m]
                    ELSE
                        []
                ELSE
                    let n = prune m adj_p adj_g then
		    forall_unused n row used (\col.
                        let n'    = modify (mark_one col) row n in
                        let used' = modify (const T) col used in
                        search n' used' (row+1))
        in
        search iso (replicate rows F) 1
;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] [] (\p. \l. p : l) = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));