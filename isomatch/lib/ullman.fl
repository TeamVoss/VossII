load (DIR^"utils.fl");

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

//------------------------------------------------------------------------------

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// ...
//  filter_mask::(bool list)->(* list)->(* list)
let filter_mask mask = snd # unzip # filter fst # zip mask;

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->a->((int#int)->a->a)->a
let forall_ones mat x f = sitlist f (filter_rows id mat) x;

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Checks that list 'xs' does not contain any duplicates.
//  unique::(* list)->bool
let unique xs = setify xs == xs;

//==============================================================================
// Pruning of match matrix.

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(P, G, M)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune_isomorphisms::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune_isomorphisms m p g =
        // Check if there are neighbors of 'i' in 'm'.
        let any_neighbors i m = forall_neighbors i m (\vj. const T) F in
        // Prune 'm' once.
        val
            m' =
                forall_ones m m (\(i,j).
                    forall_neighbors i p (\vi. \n.
                        any_neighbors j g => n | mat_update F (i,j) n))
        then
        // Continue pruning until options are exhausted.
        IF m == m' THEN m ELSE prune_isomorphisms m' g p
;

// Trim impossible matches given a match of 'P(r)' to 'G(c)': If 'P(r)' is
// matched against 'G(c)', then no 'P(x)' adj. to 'P(r)' can be isomorphic to
// some 'G(y)' that is not adj. to 'G(c)'.
//
//  thin_isomorphisms::int->int->(bool mat)->(bool mat)
let
    thin_isomorphisms r c m =
        // Trim col. if 'G(y)' is not adj. to 'G(c)'.
        //          =    NOT (el c (el j g)   )
        let f col j = IF NOT (adj_haystack c j) THEN F ELSE col in
        // Trim row if 'P(x)' is adj. to 'P(r)'.
        //          =    (el r (el i p) )
        let g row i = IF (adj_needle r i) THEN ixmap f row ELSE row in
        // Check every matching.
        ixmap g m
;

//==============================================================================
// Solution checking.

// Check if 'mat' is well formatted.
//  single_morphism::(bool mat)->bool
let
    single_morphism mat =
        val (rs,cs) = unzip (filter_rows id mat) then
        unique rs AND unique cs
;

// Check if 'mat' is a valid morphism from 'g' to 'p'.
//  valid_morphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    valid_morphism mat p g =
        p == mult mat (transpose (mult mat g))
;

// Checks if 'mat' is a valid isomorphism.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat =
         single_morphism mat //AND valid_morphism mat p g
;

//==============================================================================
// Matching algo.

// Recursively search for an isomorphism in 'P', 'G' and 'M'.
//
// recurse(used, row, P, G, M)
//   if row = num_rows(M) + 1
//       if isomorphism(P, G, M)
//           report M as a solution
//   else
//       N = prune(M)
//       for all unused columns c in N[row]
//           N'    = zero all columns but c in N[row]
//           used' = mark c in used
//           recurse(used', row+1, P, G, N')
let
    recurse iso =
        let
            forall_unused m row used f =
                let unused  = map NOT used then
                let matches = map2 (defix AND) (el row m) unused then
                flatmap f (filter_cols id matches)
        in
        let solution m = isomorphism m in
        let cols = length (hd iso) in
        let rows = length iso in
        letrec
            search m used row =
                IF row == rows + 1 THEN
                    IF solution m THEN
                        [m]
                    ELSE
                        [ ]
                ELSE
		    forall_unused m row used (\col.
                        let m'    = modify (mark_one col) row m then
                        let m''   = thin_isomorphisms row col m' then
                        let used' = modify (const T) col used then
                        search m'' used' (row+1)
                    )
        in
        // ...
        let res = search iso (replicate cols F) 1 then res
;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] [] (\p. \l. p : l) = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));