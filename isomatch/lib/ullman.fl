load (DIR^"utils.fl");

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

//------------------------------------------------------------------------------

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// ...
//  filter_mask::(bool list)->(* list)->(* list)
let filter_mask mask = snd # unzip # filter fst # zip mask;

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->a->((int#int)->a->a)->a
let forall_ones mat x f = sitlist f (filter_rows id mat) x;

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Checks that list 'xs' does not contain any duplicates.
//  unique::(* list)->bool
let unique xs = setify xs == xs;

//==============================================================================
// Pruning of match matrix.

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(P, G, M)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m p g =
        // Check if there are neighbors of 'i' in 'm'.
        let any_neighbors i m = forall_neighbors i m (\vj. const T) F in
        // Prune 'm' once.
        val m' =
            forall_ones m m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    any_neighbors j g => n | mat_update F (i,j) n))
        then
        // Continue pruning until options are exhausted.
        IF m == m' THEN
            m
        ELSE
(fprintf stderr ">>> pruning.\n") fseq
            prune m' g p
;

//==============================================================================
// Solution checking.

// Check if 'mat' is well formatted.
//  single_morphism::(bool mat)->bool
let
    single_morphism mat =
        val (rs,cs) = unzip (filter_rows id mat) then
        unique rs AND unique cs
;

// Check if 'mat' is a valid morphism from 'g' to 'p'.
//  valid_morphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    valid_morphism mat p g =
        p == mult mat (transpose (mult mat g))
;

// Checks if 'mat' is a valid isomorphism.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat p g =
         single_morphism mat AND valid_morphism mat p g
;

//==============================================================================
// Matching algo.

// Recursively search for an isomorphism in 'P', 'G' and 'M'.
//
// recurse(used, row, P, G, M)
//   if row = num_rows(M) + 1
//       if isomorphism(P, G, M)
//           report M as a solution
//   else
//       N = prune(M)
//       for all unused columns c in N[row]
//           N'    = zero all columns but c in N[row]
//           used' = mark c in used
//           recurse(used', row+1, P, G, N')
let
    recurse iso adj_p adj_g =
        //
(fprintf stderr "### recursing...\n") fseq
        //
        let
            forall_unused m row used f =
                let unused  = map NOT used then
                let matches = map2 (defix AND) (el row m) unused then
                flatmap f (filter_cols id matches)
        in
        //
        let solution m = isomorphism m adj_p adj_g in
        let cols = length (hd iso) in
        let rows = length iso in
        letrec
            search m used row =
                IF row == rows + 1 THEN
(fprintf stderr ">> reached bottom...") fseq
                    IF solution m THEN
(fprintf stderr "found solution!\n") fseq
                        [m]
                    ELSE
(fprintf stderr "no solution.\n") fseq
                        []
                ELSE
                    let n = prune m adj_p adj_g then
                    //
(fprintf stderr ">> exploring row %d\nused:%s\niso: %s\nadj: %s\n"
    row
    (print_list print_bool used)
    (print_list print_bool (el row n))
    (print_list print_bool (el row adj_p))
) fseq
                    //
		    forall_unused n row used (\col.
                        let n'    = modify (mark_one col) row n in
                        let used' = modify (const T) col used in
                        search n' used' (row+1))
        in
        let res = search iso (replicate cols F) 1 then
        //
(fprintf stderr "### finished recursion with %d solution(s):\n%s\n"
    (length res)
    (print_large_list (print_large_matrix print_bool) res)
) fseq
        //
        res
;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] [] (\p. \l. p : l) = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));