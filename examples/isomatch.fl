//------------------------------------------------------------------------------
// Random util. things.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Misc.

// Check if 'p' is satisfied with all elements of 'as'.
//  all::(a->bool)->(a list)->bool
let all p as = AND_list (map p as);

// Check if 'p' is satisfied with any element of 'as'.
//  any::(a->bool)->(a list)->bool
let any p as = OR_list (map p as);

// Constant function.
//  const::a->b->a
let const a b = a;

// Flip the arguments of a function.
//  flip::(a->b->c)->b->a->c
let flip f a b = f b a;

//------------------------------------------------------------------------------
// List

// Drops the first element of a list.
//  butfirst::(a list)->(a list)
let butfirst = butfirstn 1;

// Make a pair of lists into a list of pairs.
//  zip::(a list)#(b list)->(a#b list)
let zip (xs,ys) = map2 (\x. \y. (x,y)) xs ys;

// Makes a list of pairs into a pair of lists.
//  unzip::(a#b list)->(a list)#(b list)
let unzip xs = itlist (\(x,y). \(as,bs). (x:as,y:bs)) xs ([],[]);

// Fold (rigth-to-left) a list 'xs' with 'f' into 'b'.
//  ixlist::(a->int->b->b)->(a list)->b->b
let ixlist f xs b = snd (itlist (\x. \(ix,s). (ix-1,f x ix s)) xs (length xs,b));

// Modify the 'n'th element of a list 'xs' with 'f'.
//  modify::(a->a)->int->(a list)->(a list)
let modify f n xs = ixlist (\x. \ix. \ys. n == ix => f x : ys | x : ys) xs [];

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

//------------------------------------------------------------------------------
// Matrix

// Set the 'i,j'th element of a matrix (assumes there is one).
//  update::int->int->((a list) list)->a->((a list) list)
let update i j mat v = modify (modify (const v) j) i mat;

// "Matrix multiplication" of two boolean matrices (c_ij = a_i1 * b_j1 + ... + a_in * b_jn).
//  mult::((bool list) list)->((bool list) list)->((bool list) list)
let mult m n = val n' = transpose n then map (\r. map (dot r) n') m;

//------------------------------------------------------------------------------
// String.

// Checks if string 's' is empty.
//  empty_string::string->bool
let empty_string s = empty (explode s);

// Removes the first character of a string.
//  butfirst_string::string->string
let butfirst_string s = implode (butfirst (explode s));

// Removes the first and last characters of a string.
//  trim::string->string
let trim s = implode (butlast (butfirst (explode s)));

// Split a string 's' on a character 'c' ('let (_,_) = X'?).
//  split_on::string->string->string#string
let split_on c s = val (h,t) = split (\x. x != c) (explode s) then (implode h, implode t);

//------------------------------------------------------------------------------
// Ports/Wires.

// Model of Verilog's port references.
//
// <port_reference>
//   ::= <name_of_variable>
//   ||= <name_of_variable> [ <constant_expression> ]
//   ||= <name_of_variable> [ <constant_expression> : <constant_expression> ]
lettype port =
          OPEN     {name::string}
        | CONSTANT {name::string} {index::string}
        | RANGE    {name::string} {from::string} {to::string}
;

// Check if two port references are equal.
//  port_eq::port->port->bool
let
    port_eq (OPEN a)       (OPEN b)       = a == b
/\  port_eq (CONSTANT a i) (CONSTANT b j) = a == b AND i == j
/\  port_eq (RANGE a r s)  (RANGE b u v)  = a == b AND r == u AND s == v
;

// Parse a <port_reference> into its parts, i.e. a name and possibly some range.
//  parse_port::string->port
let parse_port p =
    val (n,r) = split_on "[" p        then empty_string r => OPEN n       |
    val (l,h) = split_on ":" (trim r) then empty_string h => CONSTANT n l |
    RANGE n l (butfirst_string h)
;

// Short-hand for parsing multiple named ports.
//  parse_ports::(string#(string list) list)->(string#(port list) list)
let parse_ports ws = map (\(n,ps). (n,map parse_port ps)) ws;

//------------------------------------------------------------------------------
// Pexlif.

// Feth a 'PEXLIF's attribute list.
//  attributes_of::pexlif->(string#string list)
let attributes_of (PINST _ as _ _ _ _ _) = as;

// Fetch the "fingerprint" attribute. If none exists, returns 0.
//  find_fingerprint::(string#string list)->int
let find_fingerprint as = find_first0 (\(n,_). n == "fingerprint") as;

//------------------------------------------------------------------------------
// Fingerprinting.
//------------------------------------------------------------------------------

let list_of_primes = [
      2,      3,      5,      7,     11,     13,     17,     19,     23,     29,
     31,     37,     41,     43,     47,     53,     59,     61,     67,     71,
     73,     79,     83,     89,     97,    101,    103,    107,    109,    113,
    127,    131,    137,    139,    149,    151,    157,    163,    167,    173,
    179,    181,    191,    193,    197,    199,    211,    223,    227,    229,
    233,    239,    241,    251,    257,    263,    269,    271,    277,    281,
    283,    293,    307,    311,    313,    317,    331,    337,    347,    349,
    353,    359,    367,    373,    379,    383,    389,    397,    401,    409,
    419,    421,    431,    433,    439,    443,    449,    457,    461,    463,
    467,    479,    487,    491,    499,    503,    509,    521,    523,    541
  ];

// Fetch the 'n'th prime.
//  prime::int->int
let prime = flip el list_of_primes;

// Sum a list of numbers given by 'f' into some primes starting at 'n'.
//  prime_list::(a->int)->int->(a list)->int
let prime_list f = flip (ixlist (\a.\i.\s. prime i * f a + s));

// Gen. a fingerprint for 'MEM'.
let
    fp_mem (MEM as l ds) = prime 1 * as + prime 2 * l + prime 3 * ds
;

// Gen. a fingerprint for 'WEXPR'.
letrec
    fp_w (W_X s)		= prime 0 * s
/\  fp_w (W_CONST s i)		= prime 1 * s + prime 2 * i
/\  fp_w (W_NAMED_CONST _ s i)	= prime 3 * s + prime 4 * i
/\  fp_w (W_VAR s _)		= prime 5 * s
/\  fp_w (W_EXPLICIT_VAR s _)	= prime 6 * s
/\  fp_w (W_AND a b)		= prime 7 + fp_w a + fp_w b
/\  fp_w (W_OR a b)		= prime 8 + fp_w a + fp_w b
/\  fp_w (W_NOT a)		= prime 9 + fp_w a
/\  fp_w (W_EQ a b)		= prime 10 + fp_w a + fp_w b
/\  fp_w (W_PRED _ a)		= prime 11 + fp_w a
/\  fp_w (W_GR a b)		= prime 12 + fp_w a + fp_w b
/\  fp_w (W_ADD a b)		= prime 13 + fp_w a + fp_w b
/\  fp_w (W_SUB a b)		= prime 14 + fp_w a + fp_w b
/\  fp_w (W_MUL a b)		= prime 15 + fp_w a + fp_w b
/\  fp_w (W_DIV a b)		= prime 16 + fp_w a + fp_w b
/\  fp_w (W_MOD a b)		= prime 17 + fp_w a + fp_w b
/\  fp_w (W_SHL a b)		= prime 18 + fp_w a + fp_w b
/\  fp_w (W_SHR a b)		= prime 19 + fp_w a + fp_w b
/\  fp_w (W_ASHR a b)		= prime 20 + fp_w a + fp_w b
/\  fp_w (W_SX s a)		= prime 21 * s + fp_w a
/\  fp_w (W_ZX s a)		= prime 22 * s + fp_w a
/\  fp_w (W_ITE a b c)          = prime 23 + fp_w a + fp_w b + fp_w c
/\  fp_w (W_SLICE is a)	        = prime_list id 24 is + fp_w a
/\  fp_w (W_NAMED_SLICE _ is a) = prime_list id 25 is + fp_w a
/\  fp_w (W_UPDATE_NAMED_SLICE a _ is b)
                                = prime_list id 26 is + fp_w a + fp_w b
/\  fp_w (W_CAT as)             = prime_list fp_w 27 as
/\  fp_w (W_MEM_READ m a b)     = fp_mem m + fp_w a + fp_w b
/\  fp_w (W_MEM_WRITE m a b d)  = fp_mem m + fp_w a + fp_w b + fp_w d
;

// Gen. a fingerprint for 'UPDATE_FN'.
let
    fp_fn (W_UPDATE_FN l r)   = prime_list fp_w 28 (l : r : [])
/\  fp_fn (W_PHASE_DELAY l r) = prime_list fp_w 30 (l : r : [])
;

// Gen. a fingerprint for 'CONTENT'.
let
    fp_c (P_HIER cs) = prime_list (\c. find_fingerprint (attributes_of c)) 31 cs
/\  fp_c (P_LEAF fs) = prime_list fp_fn 32 fs
;

// Gen. a fingerprint for a 'PORT'.
let
    fp_p (OPEN _)        = prime 33
/\  fp_p (CONSTANT _ ix) = prime 34 * s2int ix
/\  fp_p (RANGE _ f t)   = prime 35 * s2int f + prime 36 * s2int t
;

// Gen. a fingerprint for a input/output declaration. ('str2int'?)
let
    fp_wl ws =
        prime_list (\w. prime_list (\p. fp_p (parse_port p)) 37 (snd w)) 38 ws
;

// Gen. a fingerprint for each 'PEXLIF' on creation (fingerprint 'c'?).
let
    PINST n as l i o is c =
        let finger = fp_wl i + fp_wl o in
        PINST n (("fingerprint", int2str finger) : as) l i o is c;

//------------------------------------------------------------------------------

// "entity" decl. of a 'PEXLIF'.
lettype scheme =
        SCHEME
            {name::string}
            {fp::int}
            {inps::(string#(port list)) list}
            {outs::(string#(port list)) list}
;

// "Smart" constructor for a 'SCHEME'.
let scheme n as is os = SCHEME n (find_fingerprint as) (parse_ports is) (parse_ports os);

// Fetch the fingerprint of a 'SCHEME'.
//  fingerprint_of::scheme->int
let fingerprint_of (SCHEME _ fp _ _) = fp;

// Flatten a 'PEXLIF' into its 'SCHEME's.
//  flatten::pexlif->(scheme list)
letrec
    flatten (PINST n as _ is os _ (P_LEAF _)) = [scheme n as is os]
/\  flatten (PINST n as _ is os _ (P_HIER c)) = (scheme n as is os) : flatmap flatten c
;

// Check if two 'SCHEME's share a wire.
//  connected::scheme->scheme->bool
let
    connected (SCHEME n _ is os) (SCHEME n' _ is' os') = n == n' => T |
        let shares_wire xs ys = any (\x. any (port_eq x) ys) xs in
        let wires xs = flatmap snd xs in
        shares_wire (wires is) (wires os') OR
        shares_wire (wires os) (wires is')
;

// Construct an adjacency matrix for a 'PEXLIF' (order nodes by connectivity).
//  adjacency_matrix::pexlif->((int list) list)
let
    adjacency_matrix pex =
        let adjacent x scs =
          map (\sc. connected x sc => fingerprint_of sc | 0) scs in
        val scs = flatten pex then map (flip adjacent scs) scs
;

// ...
let
    isomatch_matrix piece puzzle =
        let build pi pu = map (\p. map (\q. p == q) pu) pi in
        let strip mat   = map (\c. map (\v. v != 0) c) mat in
        val pi = adjacency_matrix piece  then
        val pu = adjacency_matrix puzzle then
        val m  = build pi pu then
        (strip pi, strip pu, m)
;

//------------------------------------------------------------------------------
// Ullman’s Subgraph Isomorphism Algorithm:
//   G - graph, or puzzle.
//   P - potential subgraphs of G, or piece.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//------------------------------------------------------------------------------

letrec
    ix_cols _ _ p []     = []
/\  ix_cols r d p (c:cs) = p c =>
        (r,d) : ix_cols r (d+1) p cs | ix_cols r (d+1) p cs
;

letrec
    ix_rows _ p []     = []
/\  ix_rows d p (r:rs) = ix_cols d 0 p r @ ix_rows (d+1) p rs
;

// Iterate over every mat. index that is a possible match.
let forall_ones mat f = val ixs = ix_rows 0 id mat then sitlist f ixs;

// Iterate over every index in a col. that is a possible match.
let forall_neighbors i mat f = val ixs = ix_cols i 0 id (el i mat) then sitlist f (map snd ixs);

// thin the possible set of isomorphisms.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj s.t. M(x,y)=1
//         M(i,j)=0
// while M was changed
//
// prune::(mat->mat->mat->mat)
letrec
    prune mat g p =
      val mat' =
          forall_ones mat (\(i,j). \mat.
            forall_neighbors i p (\vi. \mat.
              forall_neighbors j g (\vj. const T) F
                => mat | update i j mat F
            ) mat
          ) mat
      then mat == mat' => mat' | prune mat' g p
;

//------------------------------------------------------------------------------

// Iterate over all unused row-indices.
//  forall_unused::(bool list)->(int->a->a)->a->a
let
    forall_unused row f =
        val ixs = ix_cols 0 0 NOT row then sitlist f (map snd ixs)
;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(* list)->(bool list)
let
    mark_one n xs =
        modify (const T) n (map (const F) xs)
;

// Check that only a single solution (only one 'T' in each row and column).
//  only_one_solution::((bool list) list)->bool
let
    only_one_solution mat =
        val (rs,cs) = unzip (ix_rows 0 id mat) then
        let unique xs = setify xs == xs in
        unique rs AND unique cs
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::((bool list) list)->((bool list) list)->((bool list) list)->bool
let
    isomorphism mat g p =
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// find ...
//
// recurse(used_columns, cur_row, G, P, M)
//   if cur_row = num_rows(M)
//     if M is an isomorphism:
//        output yes and end the algorithm
//   M' = M
//   prune(M')
//   for all unused columns c
//     set column c in M' to 1 and other columns to 0
//       -- 'c' at 'cur_row'? I might have missed that part during translation.
//     used_columns' = used_columns
//     mark c as used in used_columns'
//     recurse(used_column', cur_row+1, G, P, M')
//   output no
//
// recurse::(mat->mat->mat->int list->int->(bool,mat))
letrec
    recurse mat g p cols row =
        row == length mat AND isomorphism mat g p => (T,mat)
          | val mat' = prune mat g p then
            forall_unused cols (\col. \(r,m). r => (r,m) |
                let m'    = modify (mark_one col) row m in
                let cols' = modify (const T) col cols in
                recurse m' g p cols' (row+1)
            ) (F,mat')
;

//------------------------------------------------------------------------------
// Fin.