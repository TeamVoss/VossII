load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");
load (DIR^"lib/ullman.fl");

//------------------------------------------------------------------------------

let cmp_fp  = int2str # find_fingerprint # _pexlif_attrs;
let cmp_sha = find_signature # _pexlif_attrs;

//==============================================================================
//
// ... Ann
//
//==============================================================================

lettype ann =
        ANN
            {pex::pexlif}
            {lbl::string}
            {adj::ann list}
;

let _ann_pex (ANN p _ _) = p;
let _ann_lbl (ANN _ l _) = l;
let _ann_adj (ANN _ _ a) = a;

let
    Pann (ANN p l a) =
        sprintf "%s(%s):%S" (_pexlif_name p) l (map (_pexlif_name # _ann_pex) a)
;
install_print_function Pann;

//  mk_ann::pexlif->string->ann
let mk_ann pex label = ANN pex label [];

//  ann_cons::ann->ann->ann
let ann_cons sc (ANN p l a) = (ANN p l (sc:a));

//  ann_test::ann->ann->bool
let ann_test (ANN p1 l1 _) (ANN p2 l2 _) = l1 != l2 AND test_adjacent p1 p2;

//  ann_adj_id::ann->(int list)
let ann_adj_id = map (s2int # _ann_lbl) # _ann_adj;

//------------------------------------------------------------------------------

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  annotate_pexlif::(int->pexlif->bool)->pexlif->[ann]
let
    annotate_pexlif stop pex =
        //  ::anode->int
        let size (_,a) = length a + 1 in
        //  ::anode->anode->anode
        let extend (x,_) (y,a) = (ann_cons x y,a) in
        //  ::anode->(anode list)->anode
        let test cs (y,a) = (itlist (\x. \y. ann_test x y => ann_cons x y | y) (map fst cs) y, a) in
        //  test = first # sitlist (\x. \y. ann_test x y => ann_cons x y | y) # map fst
        //  ::(anode list)->anode->anode
        let merge cs = second (itlist (append # curry cons) cs) in
        //  ::int->string->pexlif->anode
        letrec
            annotate lvl id p =
                let
                    traverse _ (P_LEAF _)  = []
                /\  traverse i (P_HIER ps) =
                        letrec
                            go _ []     = []
                        /\  go c (p:ps) =
                                let an = annotate (lvl+1) c p in
                                an : go (c+size an) ps
                        in
                        go i ps
                in
                //
                let anode  = (mk_ann p (int2str id), []) in
                let cs     = traverse (id+1) (_pexlif_content p) in
                //
                let anode' = itlist extend cs anode in
                let cs'    = map (extend anode) cs in
                let cs''   = map (test cs') cs' in
                //
                merge cs'' anode'
        in
        val (sc,adj) = annotate 1 1 pex in (sc:adj)
;

//------------------------------------------------------------------------------

// Builds the 'anode's used to construct an adj. mat. for the needle.
//  adj_needle::pexlif->[ann]
let
    adj_build_needle pex =
        annotate_pexlif (const (const F)) pex
;

// Labels for each possible match at every "level" of a 'pinst'.
//  possible_matches::(pexlif->string)->ann->(((string#int) list) list)
let
    possible_matches attr sc =
        //  ::( list)->( list)->( list)
        let skip vs = filter (NOT # flip elem vs # attr # _ann_pex) in
        letrec
            go vs (ANN p _ as) =
                let l = attr p in
                l : flatmap (go (l:vs)) (skip vs as)
        in
        ixlabel (go [] sc)
;

// Builds the 'anode's used to construct an adj. mat. for the haystack.
//  adj_build_haystack::(pexlif->string)->ann->pexlif->[ann]
let
    adj_build_haystack attr needle pex =
        let matches = possible_matches attr needle in
        let
            stop 1 _ = F
        /\  stop i p =
                let pred j q = (i == j + 1) AND attr p == q in
                NOT (any (curry (flip pred)) matches)
        in
        annotate_pexlif stop pex
;

//==============================================================================
//
// Creation of adj. matrix.
//
//==============================================================================

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->(int list)->(bool list)
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::(ann list)->(bool mat)
let adjacency_matrix as = map (fill (length as) # ann_adj_id) as;

//==============================================================================
//
// Creation of iso. match matrix.
//
//==============================================================================

//  replace_columns::((int#(* list)) list)->(* mat)->(* mat)
let
    replace_columns cset mat =
        let replace i x = (assoc i cset) catch x in
        transpose (ixmap (flip replace) (transpose mat))
;

// Remove every 'sc' and their adjacent nodes from the possible iso. solutions.
//  trim::(ann list)->(bool mat)->(bool mat)
let
    trim_ann sc iso =
        letrec
            adj s = ann_adj_id s @ flatmap adj (_ann_adj s)
        in
        let none = replicate (length iso) F in
        let aset = flatmap (\s. s2int (_ann_lbl s) : adj s) sc in
        transpose (ixmap (\r. \ix. elem ix aset => none | r) (transpose iso))
;

//------------------------------------------------------------------------------

// ...
//  trim_non_top_matches::(ann list)->(ann list)->(bool mat)->(bool mat)
let
    trim_non_top_matches as_g as_p iso = 
        let poss_top = filter_cols id (hd iso) in
        let act_top  = ann_adj_id (hd as_g) in
        let not_top  = filter (NOT # flip elem act_top) poss_top in
        let rem      = map (flip el as_g) not_top in
        //
        trim_ann rem iso
;

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::(pexlif->string)->[ann]->[ann]->(bool mat)
let
    isomatch_matrix cmp as_p as_g =
        // Initial equalities.
        let ps_p = map _ann_pex as_p in
        let ps_g = map _ann_pex as_g in
        let iso  = map (pam ps_g # equal on cmp) ps_p then
        // Filter by depth.
        let iso' = trim_non_top_matches as_g as_p iso then
        //
        iso'
;

//==============================================================================
//
// ... Alpha equality.
//
//==============================================================================

// For every pair '(x,y)' in 's', 'assoc x s == y' and 'rev_assoc y s == x'.
//  subst_verify::subst->bool
let subst_verify s = all (\(u,t). all (\(x,y). (u == x) <==> (t == y)) s) s;

// Extends a substitution with another.
//  ::subst->subst->subst
let subst_extend s u = map (second (subst s)) u @ s;

// Attempts to merge a list of substitutions, fails on conflicting mappings.
//  subst_merge::(subst list)->(subst opt)
let subst_merge ss = let s = flat ss in subst_verify s => SOME s | NONE;

//------------------------------------------------------------------------------

// Find a subst. s.t. both 'wexpr's are alpha-eq.
//  ::wexpr->wexpr->subst
letrec
    alpha (W_X _)       (W_X _)       = []
/\  alpha (W_CONST _ _) (W_CONST _ _) = []
/\  alpha (W_NAMED_CONST n _ _) (W_NAMED_CONST m _ _) = [(n,m)]
/\  alpha (W_VAR _ n)   (W_VAR _ m)   = [(n,m)]
/\  alpha (W_EXPLICIT_VAR _ n)  (W_EXPLICIT_VAR _ m) = [(n,m)]
/\  alpha (W_AND a b)   (W_AND x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_OR a b)    (W_OR x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_NOT a)     (W_NOT x)     = (alpha a x)
/\  alpha (W_EQ a b)    (W_EQ x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_PRED p a)  (W_PRED q x)  = error "todo"
/\  alpha (W_GR a b)    (W_GR x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_ADD a b)   (W_ADD x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SUB a b)   (W_SUB x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_MUL a b)   (W_MUL x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_DIV a b)   (W_DIV x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_MOD a b)   (W_MOD x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SHL a b)   (W_SHL x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SHR a b)   (W_SHR x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_ASHR a b)  (W_ASHR x y)  = (alpha a x) @ (alpha b y)
/\  alpha (W_SX _ a)    (W_SX _ x)    = (alpha a x)
/\  alpha (W_ZX _ a)    (W_ZX _ x)    = (alpha a x)
/\  alpha (W_ITE a b c) (W_ITE x y z) = (alpha a x) @ (alpha b y) @ (alpha c z)
/\  alpha (W_CAT as)    (W_CAT bs)    = flat (map2 (\a. \b. alpha a b) as bs) 
/\  alpha (W_SLICE i a) (W_SLICE j x) = error "todo"
/\  alpha (W_NAMED_SLICE n i a) (W_NAMED_SLICE m j x) = error "todo"
/\  alpha (W_UPDATE_NAMED_SLICE a n i b) (W_UPDATE_NAMED_SLICE x m j y) = error "todo"
/\  alpha (W_MEM_READ i n a)    (W_MEM_READ j m x) = error "todo"
/\  alpha (W_MEM_WRITE i n a b) (W_MEM_WRITE j m x y) = error "todo"
;

//  ::(update_fn list)->(update_fn list)->(subst opt)
let
    alpha_fn fs1 fs2 =
        let
            alpha_pairs u1 u2 v1 v2 = subst_merge [alpha u1 v1, alpha u2 v2]
        in
        let
            alpha_fn (W_UPDATE_FN u1 u2)   (W_UPDATE_FN v1 v2)   = alpha_pairs u1 u2 v1 v2
        /\  alpha_fn (W_PHASE_DELAY u1 u2) (W_PHASE_DELAY v1 v2) = alpha_pairs u1 u2 v1 v2
        /\  alpha_fn _ _ = NONE
        in
        let
            alpha_fns fs =
                letrec
                    collect s []     []     = SOME s
                /\  collect s (x:xs) (y:ys) =
                        let go (SOME u) = collect (s @ u) xs ys
                        /\  go (NONE)   = NONE
                        in
                        go (alpha_fn x y)
                in
                collect [] fs1 fs
        in
        try_all (alpha_fns) (permutations fs2)
;

//------------------------------------------------------------------------------

//  ::pexlif->pexlif->(subst opt)
let
    alpha_pinst_leaf
        (PINST _ _ _ fa_inps1 fa_outs1 _ (P_LEAF fs1))
        (PINST _ _ _ fa_inps2 fa_outs2 _ (P_LEAF fs2))
        =
        let fa_n = (fa_inps1 @ fa_outs1) in
        let fa_h = (fa_inps2 @ fa_outs2) in
        let f    = formalize fa_n fa_h in
        maybe (alpha_fn fs1 fs2) (SOME # f)
;

//  ::pexlif->pexlif->((subst opt) list)->((subst list) opt)
let
    alpha_pinst_hier
        (PINST _ _ _ fa_inps1 fa_outs1 _ (P_HIER _))
        (PINST _ _ _ fa_inps2 fa_outs2 _ (P_HIER _))
        substs
        =
        let
            unpack ms =
                letrec
                    go s []            = SOME s
                /\  go s ((NONE):xs)   = NONE
                /\  go s ((SOME x):xs) = go (x:s) xs
                in
                go [] ms
        in
        let fa_n = (fa_inps1 @ fa_outs1) in
        let fa_h = (fa_inps2 @ fa_outs2) in
        let f    = formalize fa_n fa_h in
        maybe (unpack substs) (flip maybe (SOME # f) # subst_merge)
;

//------------------------------------------------------------------------------

// Fill the 'j'th column of a matrix with values 'v'.
//  fill_column::int->*->(* mat)->(* mat)
let fill_column j v = transpose # modify (\c. replicate (length c) v) j # transpose;

// Traverse the nodes of an adjacency matrix in depth-first order, calling
// 'leaf' for leaf nodes and 'hier' to merge composite nodes.
//  ::(bool mat)->(int->*)->(int->(* list)->*)->*
let
    traverse adj leaf hier =
        letrec
            go am i =
                let am' = fill_column i F am in
                let rs  = forall_neighbors i am (cons # go am') [] in
                empty rs => leaf i | hier i rs
        in
        go adj 1
;

// TODO: 'recover_one' keeps substitutions for formals used in each child node,
// those should really be discarded for the parent.
//  ::(bool mat)->(bool mat)->(ann list)->(ann list)->subst
let
    recover_one res adj needle haystack =
        let
            match_of i =
                letrec
                    go (F:xs) (a:as) = go xs as
                /\  go (T:xs) (a:as) = a
                in
                go (el i res) haystack
        in
        let pair_of i = (_ann_pex (el i needle), _ann_pex (match_of i)) in
        traverse adj
          (curry alpha_pinst_leaf # pair_of)
          (curry alpha_pinst_hier # pair_of)
;

//  ::((bool mat) list)->(bool mat)->(ann list)->(ann list)->(subst list)
let
    recover_all sols adj needle haystack =
        map (\res. recover_one res adj needle haystack) sols
;

//==============================================================================
//
// ... Pretty-Printing.
//
//==============================================================================

//  ::(a list)->string
let print_list = list2str T "{ " "\n, " "}";

//  ::subst->subst->string
let print_subst s1 s2 = sprintf "%s->%s" s1 s2;

//  ::ann->ann->string
let
    print_pair (ANN p1 l1 _) (ANN p2 l2 _) =
        sprintf "%s(%s)=%s(%s)" (_pexlif_name p1) l1 (_pexlif_name p2) l2
;

//  ::((ann#ann) list)->(subst opt)->string
let
    print_match ms (NONE) =
        sprintf "%s\n where no alpha-eq. connection could be found."
            (print_list (curry print_pair) ms)
/\  print_match ms (SOME ss) =
        sprintf "%s\nwhere\n%s"
            (print_list (curry print_pair)  ms)
            (print_list (curry print_subst) ss)
;

//  ::((bool mat) list)->((subst opt) list)->(ann list)->(ann list)->string
let
    print_matches res ss ns hs =
        let
            matches_of m =
                letrec
                    go c (F:xs) = go (c+1) xs
                /\  go c (T:xs) = el c hs
                in
                ixmap (\r. \i. (el i ns, go 1 r)) m
        in
        let pr_solution = print_match # matches_of in
        list2str T "\n===\n" "\n===\n" "\n" (curry pr_solution) (zip res ss)
;

//==============================================================================
//
// ... Everything in one function.
//
//==============================================================================

let
    isomatch cmp p_pex g_pex =
        // Needle.
        let sc_p  = adj_build_needle p_pex then
        let adj_p = adjacency_matrix sc_p then
        // Haystack.
        let sc_g  = adj_build_haystack cmp (hd sc_p) g_pex then
        let adj_g = adjacency_matrix sc_g then
        // Isomatch.
        let iso = isomatch_matrix cmp sc_p sc_g then
        let res = recurse iso adj_p adj_g then
        let ss  = recover_all res adj_p sc_p sc_g then
        // Done.
        print_matches res ss sc_p sc_g;
;

//==============================================================================
//
// ... Debug.
//
//==============================================================================

let
    DBG_isomatch cmp p_pex g_pex =
        // Needle.
        let sc_p  = adj_build_needle p_pex in
        let adj_p = adjacency_matrix sc_p in
        // Haystack.
        let sc_g  = adj_build_haystack cmp (hd sc_p) g_pex in
        let adj_g = adjacency_matrix sc_g in
        // Isomatch.
        let iso   = isomatch_matrix cmp sc_p sc_g in
        let res   = recurse iso adj_p adj_g in
        let ss    = recover_all res adj_p sc_p sc_g in
// Debug printing ----------------------
        val (_,t1) = wtime sc_p in
        val (_,t2) = wtime adj_p in
        let p1 = mat2str b2str adj_p in
        (fprintf stdout "-- Adj.P in (%s+%s):\n" t1 t2) fseq
        (fprintf stdout "%s\n" p1) fseq
        //
        val (_,t3) = wtime sc_g in
        val (_,t4) = wtime adj_g in
        let p2 = mat2str b2str adj_g in
        (fprintf stdout "-- Adj.G in (%s+%s):\n" t3 t4) fseq
        (fprintf stdout "%s\n" p2) fseq
        //
        val (_,t5) = wtime iso in
        let p3 = mat2str b2str iso in
        (fprintf stdout "-- Iso.M in %s:\n" t5) fseq
        (fprintf stdout "%s\n" p3) fseq
        //
        val (_,t6) = wtime res in
        let p4 = map (mat2str b2str) res in
        (fprintf stdout "-- Result in %s:\n" t6) fseq
        (foreach (fprintf stdout "%s\n") p4) fseq
        //
        val (_,t7) = wtime ss in
        let
            print5 (NONE)    = "No match."
        /\  print5 (SOME xs) =
                let pr (a,b) = a ^ "->" ^ b in
                list2str T "[" "," "]" pr xs
        in
        let p5 = map print5 ss in
        (fprintf stdout "-- Matching in %s:\n" t7) fseq
        (foreach (fprintf stdout "%s\n") p5) fseq
//--------------------------------------
        // Done.
        print_matches res ss sc_p sc_g;
;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));
