load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");

//==============================================================================
//
// ...
//
//==============================================================================


//------------------------------------------------------------------------------
// ...

// ...
lettype
    entity =
        ENTITY
            {name::string}
            {indices::index list}
andlettype
    index =
        INDEX {index::int}
      | RANGE {range::int#int}
      | SUBE  {sube::entity}
;

letrec
    Pentity (ENTITY n rs) =
        let
            pr (INDEX i)     = sprintf "%d" i
        /\  pr (RANGE (l,u)) = sprintf "%d:%d" l u
        /\  pr (SUBE e)      = Pentity e
        in
        sprintf "%s%s" n (list2str F "[" "," "]" pr rs)
;
install_print_function Pentity;

// ...
// todo: fails if a name is used in the indices.
//  parse_vec::string->entity
let
    parse_vec s =
        val (e:rs) = md_split_vector s in
        let e'  = val (TXT n) = e in string_butlast n in
        let rs' = empty rs => [] | butlast rs in
        //
        let go (u,l) = u == l => INDEX u | RANGE (u,l) in
        let unpack (RANGES rs) = map go rs in
        //
        ENTITY e' (flatmap unpack rs')
;

// ...
//  test_vec::entity->entity->bool
let
    test_vec (ENTITY n1 rs1) (ENTITY n2 rs2) =
        let
            test (INDEX i1) (INDEX i2) = i1 == i2
        /\  test (RANGE r1) (RANGE r2) = r1 == r2
        /\  test _ _ = F
        in
        n1 == n2 AND all (curry test) (zip rs1 rs2)
;

// ...
//  shared_vec::entity->entity->bool
let shared_vec (ENTITY n1 rs1) (ENTITY n2 rs2) = n1 == n2;

//------------------------------------------------------------------------------
// ...

lettype scheme =
        SCHEME
            {pex::pexlif}
            {lbl::string}
            {adj::scheme list}
            {inp::(entity list) list}
            {out::(entity list) list}
            {int::entity list}
;

let _scheme_pex (SCHEME p _ _ _ _ _) = p;
let _scheme_lbl (SCHEME _ l _ _ _ _) = l;
let _scheme_adj (SCHEME _ _ a _ _ _) = a;
let _scheme_inp (SCHEME _ _ _ i _ _) = i;
let _scheme_out (SCHEME _ _ _ _ o _) = o;
let _scheme_int (SCHEME _ _ _ _ _ t) = t;

let
    Pscheme (SCHEME p l a i o t) =
        let name_of (PINST n _ _ _ _ _ _) = n in
        let pr = list2str T "{" "," "}" Pentity in
        sprintf "%s(%s):%S:%S:%S:%s"
            (name_of p)
            l
            (map (name_of # _scheme_pex) a)
            (map pr i)
            (map pr o)
            (pr t)
;
install_print_function Pscheme;

// "Smart" constructor for a 'SCHEME'.
//  mk_scheme::*parts of PEXLIF*->scheme
let
    mk_scheme pex label =
        val (PINST _ _ _ i o t _) = pex in
        let parse = map parse_vec # snd in 
        SCHEME pex label []
            (map parse i)
            (map parse o)
            (map parse_vec t)
;

// ...
//  scheme_cons_adj::scheme->scheme->scheme
let
    scheme_cons_adj sc (SCHEME n l a i o t) = (SCHEME n l (sc:a) i o t)
;

// Checks if two 'SCHEME's are connected via a wire.
//  test_scheme::scheme->scheme->bool
let
    scheme_shared (SCHEME _ _ _ i1 o1 _) (SCHEME _ _ _ i2 o2 _) =
        let check_one x  ys = any (any (test_vec x)) ys in
        let check_all xs ys = any (any (flip check_one ys)) xs in
        check_all o1 i2 OR check_all i1 o2
;

//------------------------------------------------------------------------------
// Construction of adj. nodes from a pexlif.

// ...
//  adj_length::(scheme,[scheme])->int
let
    adj_length (_,adj) = length adj + 1
;

// ...
//  adj_cons::(scheme,[scheme])->(scheme,[scheme])->(scheme,[scheme])
let
    adj_cons (s1,a1) (s2,a2) =
        scheme_shared s1 s2 => (scheme_cons_adj s1 s2,a2) | (s2,a2)
;

// Merge a "parent" node with its "children".
//  adj_merge::(scheme,[scheme])->[(scheme,[scheme])]->(scheme,[scheme])
let
    adj_merge (sc,adj) cs = (sc,itlist (\(s,a). append (s:a)) cs adj)
;

// Traverse each child in order.
//  adj_map::int->content->[(scheme,[scheme])];
forward_declare{adj_reduce::int->pexlif->(scheme#(scheme list))};
letrec
    adj_map id (P_LEAF _)  = []
/\  adj_map id (P_HIER ps) =
        letrec
            go _ []     = []
        /\  go c (p:ps) =
                let an = adj_reduce c p in
                let l  = adj_length an in
                an : go (c+l) ps
        in
        go id ps
;

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  adj_reduce::int->pexlif->(scheme,[scheme])
letrec
    adj_reduce id pex =
        // Pattern-match against the 'PINST'.
        val (PINST n as _ fa_is fa_os int cont) = pex in
        // Construct an ... for the 'PINST'.
        let anode = (mk_scheme pex (int2str id), []) in
        // Check if we're at the 'bottom'.
        // Fetch "anodes" for children.
        let cs = adj_map (id+1) cont in
        // Find new adjacencies between children and this node.
        let anode' = itlist (adj_cons) cs anode in
//      let cs'    = map (adj_cons anode) cs in
        // Merge this "anode" and its children.
        adj_merge anode' cs
;

// Calls 'adj_reduce' and flattens its result.
//  adj_build::pexlif->int->[scheme]
let
    adj_build pex = val (sc,adj) = adj_reduce 1 pex in (sc:adj)
;

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

//------------------------------------------------------------------------------
// Creationg of adj. matrix.

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->(int list)->(bool list)
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

// ...
//  adj_to_id::scheme->(int list)
let adj_to_id = map (s2int # _scheme_lbl) # _scheme_adj;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::(scheme list)->(bool mat)
let adjacency_matrix as = map (fill (length as) # adj_to_id) as;

//------------------------------------------------------------------------------
// Creation of iso. match matrix.

// ...
//  fp::pexlif->string
let pex_fp = int2str # find_fingerprint # _pexlif_attrs # _scheme_pex;

// ...
//  sha::pexlif->string
let pex_sha = find_signature # _pexlif_attrs # _scheme_pex;

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::[scheme]->[scheme]->(pexlif->string)->(bool mat)
let isomatch_matrix as_g as_p cmp = map (pam as_g # equal on cmp) as_p;

//------------------------------------------------------------------------------
// Pruning of match matrix.

// Filter every index/pair of indices in a vector/matrix 'xs' using 'p'.
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->((int#int)->a->a)->a->a
let forall_ones mat f = sitlist f (filter_rows id mat);

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            ) m
        then m != m' => prune m' g p | m'
;

//------------------------------------------------------------------------------
// Main "matching" algo.

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Iterate over all unused row-indices.
//  forall_unused::(bool mat)->int->(bool list)
//               ->(int->(bool mat)->((bool mat) list))
//               ->((bool mat) list)
let forall_unused m row used f =
        let unused = filter (NOT # flip el used) (filter_cols id (el row m)) in
        sitlist (\c. \ms. f c m @ ms) unused []
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used, row, G, P, M)
//   if row = num_rows(M) + 1
//     if M is an isomorphism
//        output yes and end the algorithm
//     if not
//        output no
//   N = prune(M)
//   for all unused columns c in N[row]
//     N' = set all columns in N[row] to zero but column c
//     used' = mark c as used
//     recurse(used', row+1, G, P, N')
//   output no
//
//  recurse::(bool mat)->(bool mat)->(bool mat)->((bool mat) list)
letrec
    recurse mat g p =
        let solution m = isomorphism m g p => [m] | [] in
        letrec
            go m cs r = r == num_rows mat + 1 => solution m |
                val m' = prune m g p then
                forall_unused m' r cs (\c. \n.
                    let n'  = modify (mark_one c) r n  in
                    let cs' = modify (const T)    c cs in
                    go n' cs' (r+1)
                )
        in
        go mat (replicate (num_columns mat) F) 1
;

//------------------------------------------------------------------------------
let mat2str = matrix2str T "[" "\n," "," "]";
let b2str b = b => "T" | "F";

// ...
//  recover::(scheme list)->(scheme list)->((bool mat) list)->((scheme#scheme) mat)
let
    recover sc_g sc_p res =
        map (\s. forall_ones s (\(p,g). cons (el p sc_p,el g sc_g)) []) res
;

// ...
//  isomatch::(pexlif->string)->(pexlif,int)->(pexlif,int)->((scheme#scheme) mat)
let
    isomatch cmp g_pex p_pex =
        // Create haystack.
        let sc_g  = adj_build g_pex in
        let adj_g = adjacency_matrix sc_g in
        // Create needle.
        let sc_p  = adj_build p_pex in
        let adj_p = adjacency_matrix sc_p in
        // Create iso. matrix.
        let iso_m = isomatch_matrix sc_g sc_p cmp in
        // Perform isomatch.
        let res   = recurse iso_m adj_g adj_p in
        // Recover solution.
        let sol   = recover sc_g sc_p res in
// Debug: ------------------------------
        val (_,t1) = wtime sc_g in
        val (_,t2) = wtime adj_g in
        let p1 = mat2str b2str adj_g in
        (fprintf stdout "-- Adj.G in (%s+%s):\n" t1 t2) fseq
        //(fprintf stdout "%s\n" p1) fseq
        //
        val (_,t3) = wtime sc_p in
        val (_,t4) = wtime adj_p in
        let p2 = mat2str b2str adj_g in
        (fprintf stdout "-- Adj.P in (%s+%s):\n" t3 t4) fseq
        //(fprintf stdout "%s\n" p2) fseq
        //
        val (_,t5) = wtime iso_m in
        let p3 = mat2str b2str iso_m in
        (fprintf stdout "-- Iso.M in %s:\n" t5) fseq
        //(fprintf stdout "%s\n" p3) fseq
        //
        val (_,t6) = wtime res in
        let p4 = map (mat2str b2str) res in
        (fprintf stdout "-- Result in %s:\n" t6) fseq
        //(foreach (fprintf stdout "%s\n") p4) fseq
        //
        val (_,t7) = wtime sol in
        (fprintf stdout "-- Recover in %s.\n" t7) fseq
//--------------------------------------
        sol
;

//==============================================================================
//
// ...
//
//==============================================================================

// ...
//  subst::((string#string) list)->string->string
let
    subst sub name =
        let ix = find_first0 (equal name # fst) sub then
        ix == 0 => name | (snd (el ix sub))
;

// ...
//  subst_wexpr::((string#string) list)->wexpr->wexpr
letrec
    subst_wexpr _ (W_X sz)               = W_X sz
/\  subst_wexpr _ (W_CONST sz v)         = W_CONST sz v
/\  subst_wexpr s (W_NAMED_CONST n sz v) = W_NAMED_CONST (subst s n) sz v
/\  subst_wexpr s (W_VAR sz n)           = W_VAR sz (subst s n)
/\  subst_wexpr s (W_EXPLICIT_VAR sz n)  = W_EXPLICIT_VAR sz (subst s n)
/\  subst_wexpr s (W_AND a b)            = W_AND (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_OR a b)             = W_OR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_NOT a)              = W_NOT (subst_wexpr s a)
/\  subst_wexpr s (W_EQ a b)             = W_EQ (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_PRED n c)           = W_PRED (subst s n) (subst_wexpr s c)
/\  subst_wexpr s (W_GR a b)             = W_GR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_ADD a b)            = W_ADD (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SUB a b)            = W_SUB (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_MUL a b)            = W_MUL (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_DIV a b)            = W_DIV (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_MOD a b)            = W_MOD (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SHL a b)            = W_SHL (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SHR a b)            = W_SHR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_ASHR a b)           = W_ASHR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SX sz w)            = W_SX sz (subst_wexpr s w)
/\  subst_wexpr s (W_ZX sz w)            = W_ZX sz (subst_wexpr s w)
/\  subst_wexpr s (W_ITE c t e)          = W_ITE (subst_wexpr s c) (subst_wexpr s t) (subst_wexpr s e)
/\  subst_wexpr s (W_SLICE i w)          = W_SLICE i (subst_wexpr s w)
/\  subst_wexpr s (W_NAMED_SLICE n i w)  = W_NAMED_SLICE (subst s n) i (subst_wexpr s w)
/\  subst_wexpr s (W_UPDATE_NAMED_SLICE b n i w)
                                         = W_UPDATE_NAMED_SLICE (subst_wexpr s b) (subst s n) i (subst_wexpr s w)
/\  subst_wexpr s (W_CAT ps)             = W_CAT (map (subst_wexpr s) ps)
/\  subst_wexpr s (W_MEM_READ i m a)     = W_MEM_READ i (subst_wexpr s m) (subst_wexpr s a)
/\  subst_wexpr s (W_MEM_WRITE i m a d)  = W_MEM_WRITE i (subst_wexpr s m) (subst_wexpr s a) (subst_wexpr s d)
;

// ...
//  subst_fn::((string#string) list)->update_fn->update_fn
let
    subst_fn s (W_UPDATE_FN l r)   = W_UPDATE_FN (subst_wexpr s l) (subst_wexpr s r)
/\  subst_fn s (W_PHASE_DELAY l r) = W_PHASE_DELAY (subst_wexpr s l) (subst_wexpr s r)
;

//------------------------------------------------------------------------------

// Attemps to find a subst. s.t. the two 'PEXLIF' inputs are "equal".
//  alpha_equality::pexlif->pexlif->((string#string) list)
let
    alpha_equality
      (PINST _ _ _ fa_inps1 fa_outs1 fa_int1 (P_LEAF fs1))
      (PINST _ _ _ fa_inps2 fa_outs2 fa_int2 (P_LEAF fs2)) =
        let
            perms xs ys = map (zip xs) (permutations ys)
        in
        let
            test sub xs ys = sha_set xs == sha_set (map (subst_fn sub) ys)
        in
        letrec
            iter []     f = []
        /\  iter (s:ss) f = let s' = f s in empty s' => iter ss f | s'
        in
        let sub_inps = perms (map fst fa_inps2) (map fst fa_inps1) in
        let sub_outs = perms (map fst fa_outs2) (map fst fa_outs1) in
        let sub_int  = perms fa_int2 fa_int1 in
        iter sub_inps (\sinp. iter sub_outs (\sout. iter sub_int (\sint.
            let sub = sinp @ sout @ sint in
            test sub fs1 fs2 => sub | []
        )))
;

//------------------------------------------------------------------------------

// ...
//  align_actuals::((string#string) list)->scheme->scheme->scheme
let
    align_actuals
      (SCHEME p1 _ _ i1 o1 t1)
      (SCHEME p2 _ _ i2 o2 t2) =
        0
;

//------------------------------------------------------------------------------

// let
//     xxx s1 s2 =
//         val (SCHEME p1 _ _ _ _ _) = s1 in
//         val (SCHEME p2 l a i o t) = s2 in
//         val (PINST _ _ _ fa_inps1 fa_outs1 fa_int1 (P_LEAF fs1)) = p1 in
//         val (PINST _ _ _ fa_inps2 fa_outs2 fa_int2 (P_LEAF fs2)) = p2 in
//         // Find possible subst. of formals that satisfies alpha equality.
//         let sub = alpha_equality p1 p2 in
//         // If none is found, fail.
//         empty sub => (F,s1,s2) |
//         // Recover new ordering of actuals from subst.
//         let ord_inps1 = ixlabel (map fst fa_inps1) in
//         let ord_outs1 = ixlabel (map fst fa_outs1) in
//         let ord_int1  = ixlabel fa_int1 in
//         let
//             lookup f  =
//                 subst (subst sub f) (ord_inps1 @ ord_outs1 @ ord_int1)
//         in
//         // Rearrange wires after new ordering.
//         let ord_inps2 = map lookup (map fst fa_inps2) then
//         let ord_outs2 = map lookup (map fst fa_outs2) then
//         let ord_int2  = map lookup (fa_int2) then
//         letrec
//             reorder []     _  = []
//         /\  reorder (o:os) xs = el o xs : reorder os xs
//         in
//         //let i' = reorder ord_inps2 i then
//         //let o' = reorder ord_outs2 o then
//         //let t' = reorder ord_int2  t then
//         // Succeed and return reordered scheme.
//         (T,s1,(SCHEME p2 l a i o t))
// ;

// ...
//  unify::...
let
    unify =
        0
;

// ...
//  alpha_equality_scheme::scheme->scheme->bool
//let alpha_equality_scheme p g = alpha_equality (pexlif_of_scheme p) (pexlif_of_scheme g);

// ...
//  alpha_equality_solution::((scheme#scheme) mat)->bool
//let alpha_equality_solution = AND_list # flatmap (map (curry alpha_equality_scheme));

// ...
//  fliter_alpha_equal::(((scheme#scheme) mat) mat)->(((scheme#scheme) mat) mat)
//let filter_alpha_equal = map (filter alpha_equality_solution);

//==============================================================================
//
// Printing res.
//
//==============================================================================

// Print-function for a single sol. list.
//  print_one::((scheme#scheme) list)->string
let
    print_one matches =
       let pr_schemes (SCHEME p1 l1 _ _ _ _) (SCHEME p2 l2 _ _ _ _) =
               val (PINST n1 _ _ _ _ _ _) = p1 in
               val (PINST n2 _ _ _ _ _ _) = p2 in
               sprintf "%s(%s) :-> %s(%s)" n1 l1 n2 l2
//                   (list2str T "[" "," "]" (curry pr_wires) (zip i1 i2))
//                   (list2str T "[" "," "]" (curry pr_wires) (zip o1 o2))
       in
       list2str T "{" "\n," "}" (curry pr_schemes) matches
;

// Print all solutions of a given sol. list.
//  print_all::((scheme#scheme) mat)->string
let print_all = list2str T "===\n" "\n===\n" "\n" print_one;

//==============================================================================
// Fin.

// all NOT [T,T] = F;
// any NOT [F,T] = T;
// equal T T;
// const T F = T;
// flip const T F = F;
// curry const (T,F) = T;
// uncurry id T F = (T,F);
// first NOT (T,T) = (F,T);
// second NOT (T,T) = (T,F);
// butfirst [F,T] = [T];
// firstn 3 (iterate NOT T) = [T,F,T];
// ixlist (\a.\i.\b.(i>a):b) [2,2,2,2] [] = [F,F,T,T];
// modify NOT 2 [T,T,T] = [T,F,T];
// string_butfirstn "abc" 2 = "c";
// string_butfirst "abc" = "bc";
// string_butlast "abc" = "ab";
// list_update T 2 [F,F,F] = [F,T,F];
// mat_update T (2,2) [[F,F,F],[F,F,F],[F,F,F]] = [[F,F,F],[F,T,F],[F,F,F]];
// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused
//     [[T,F,T,F,T,F,T]]
//     1
//     [F,F,F,F,T,T,T]
//     (\c. \m. (print (sprintf "%d " c)) fseq (F,m));

//------------------------------------------------------------------------------
// Old

// parse_vec_info
        // letrec
        //     build_entity x y [] =
        //         (ENTITY undefined,[])
        // /\  build_entity x y ((TXT s):vs) = 
        //         str_is_suffix "]" s =>
        //             let e = ENTITY x y in
        //             (e,vs) |
        //         str_is_suffix "[" s =>
        //             let n = butlast s in
        //             build_entity  |
        //         undefined
        // /\  build_entity x y ((RANGES rs):vs) =
        //         undefined
        // in
        // letrec
        //     build_index [] = []
        // /\  build_index ((TXT s):vs) =
        //         val (e,vs') = build_entity "" [] ((TXT s):vs) in
        //         e : build_index vs'
        // /\  build_index ((RANGES rs):vs) =
        //         let go (u,l) = u == l => INDEX u | RANGE (u,l) in
        //         map go rs @ build_index vs
        // in