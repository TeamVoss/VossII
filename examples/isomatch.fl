load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");

//==============================================================================
//
// ... Schemes ...
//
//==============================================================================

// ...
lettype scheme =
        SCHEME
            {pex::pexlif}
            {lbl::string}
            {adj::scheme list}
;

let _scheme_pex (SCHEME p _ _) = p;
let _scheme_lbl (SCHEME _ l _) = l;
let _scheme_adj (SCHEME _ _ a) = a;

let
    Pscheme (SCHEME p l a) =
        sprintf "%s(%s):%S" (_pexlif_name p) l (map (_pexlif_name # _scheme_pex) a)
;
install_print_function Pscheme;

//------------------------------------------------------------------------------

// "Smart" constructor for a 'SCHEME'.
//  mk_scheme::*parts of PEXLIF*->scheme
let mk_scheme pex label = SCHEME pex label [];

// ...
//  scheme_cons_adj::scheme->scheme->scheme
let scheme_cons_adj sc (SCHEME n l a) = (SCHEME n l (sc:a));

// Checks if two 'SCHEME's are connected via a wire.
//  test_scheme::scheme->scheme->bool
let scheme_shared (SCHEME p1 _ _) (SCHEME p2 _ _) = T;

// Check if a scheme wraps a "leaf" 'pexlif'.
//  is_leaf_node::scheme->bool
let
    is_leaf_node (SCHEME ((PINST _ _ _ _ _ _ (P_LEAF _))) _ _) = T
/\  is_leaf_node _ = F
;

//==============================================================================
//
// Creationg of adj. matrix.
//
//==============================================================================

// ...
//  adj_length::(scheme,[scheme])->int
let adj_length (_,adj) = length adj + 1;

// ...
//  adj_cons::(scheme,[scheme])->(scheme,[scheme])->(scheme,[scheme])
let adj_cons (s1,a1) (s2,a2) = (scheme_cons_adj s1 s2,a2);

// ...
//  adj_merge::(scheme,[scheme])->[(scheme,[scheme])]->(scheme,[scheme])
let adj_merge (sc,adj) cs = (sc,itlist (\(s,a). append (s:a)) cs adj);

// Traverse each child in order.
//  adj_map::int->content->[(scheme,[scheme])];
forward_declare{adj_reduce::int->pexlif->(scheme#(scheme list))};
letrec
    adj_map id (P_LEAF _)  = []
/\  adj_map id (P_HIER ps) =
        letrec
            go _ []     = []
        /\  go c (p:ps) =
                let an = adj_reduce c p in
                let l  = adj_length an in
                an : go (c+l) ps
        in
        go id ps
;

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  adj_reduce::int->pexlif->(scheme,[scheme])
letrec
    adj_reduce id pex =
        val (PINST n as _ fa_is fa_os int cont) = pex in
        // Construct adjencies for node and children.
        let anode = (mk_scheme pex (int2str id), []) in
        let cs    = adj_map (id+1) cont in
        // Connect node and children.
        let anode' = itlist (adj_cons) cs anode in
        let cs'    = map (adj_cons anode) cs in
        // Merge adjacencies.
        adj_merge anode' cs'
;

// Calls 'adj_reduce' and flattens its result.
//  adj_build::pexlif->int->[scheme]
let adj_build pex = val (sc,adj) = adj_reduce 1 pex in (sc:adj);

// Fetch the ID's of each node adjacent to the given one.
//  adj_to_id::scheme->(int list)
let adj_to_id = map (s2int # _scheme_lbl) # _scheme_adj;

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->(int list)->(bool list)
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::(scheme list)->(bool mat)
let adjacency_matrix as = map (fill (length as) # adj_to_id) as;

//==============================================================================
//
// Creation of iso. match matrix.
//
//==============================================================================

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// ...
//  replace_columns::((int#(* list)) list)->(* mat)->(* mat)
let
    replace_columns cset mat =
        let replace i x = (assoc i cset) catch x in
        transpose (ixmap (flip replace) (transpose mat))
;

// Remove every 'sc' and their adjacent nodes from the possible iso. solutions.
//  trim::(scheme list)->(bool mat)->(bool mat)
let
    trim_scheme sc iso =
        letrec
            adj s = adj_to_id s @ flatmap adj (_scheme_adj s)
        in
        let none = replicate (length iso) F in
        let aset = flatmap (\s. s2int (_scheme_lbl s) : adj s) sc in
        transpose (ixmap (\r. \ix. elem ix aset => none | r) (transpose iso))
;

// ...
//  trim_non_top_matches::(scheme list)->(scheme list)->(bool mat)->(bool mat)
let
    trim_non_top_matches as_g as_p iso = 
        let poss_top = filter_cols id (hd iso) in
        let act_top  = adj_to_id (hd as_g) in
        let not_top  = filter (NOT # flip elem act_top) poss_top in
        let rem      = map (flip el as_g) not_top in
        //
        trim_scheme rem iso
;

//------------------------------------------------------------------------------

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::[scheme]->[scheme]->(pexlif->string)->(bool mat)
let
    isomatch_matrix as_g as_p cmp =
        // Initial equalities.
        let iso = map (pam as_g # equal on cmp) as_p then
        // Filter by depth.
        let iso' = trim_non_top_matches as_g as_p iso then
        //
        iso'
;

// Fetch the fingerprint...
//  fp::pexlif->string
let pex_fp = int2str # find_fingerprint # _pexlif_attrs # _scheme_pex;

// Fetch the SHA256 signature...
//  sha::pexlif->string
let pex_sha = find_signature # _pexlif_attrs # _scheme_pex;

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

//==============================================================================
// Pruning of match matrix.

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->((int#int)->a->a)->a->a
let forall_ones mat f = sitlist f (filter_rows id mat);

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            ) m
        then m != m' => prune m' g p | m'
;

//==============================================================================
// Main "matching" algo.

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Iterate over all unused row-indices.
//  forall_unused::(bool mat)->int->(bool list)
//               ->(int->(bool mat)->((bool mat) list))
//               ->((bool mat) list)
let forall_unused m row used f =
        let unused = filter (NOT # flip el used) (filter_cols id (el row m)) in
        sitlist (\c. \ms. f c m @ ms) unused []
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used, row, G, P, M)
//   if row = num_rows(M) + 1
//     if M is an isomorphism
//        output yes and end the algorithm
//     if not
//        output no
//   N = prune(M)
//   for all unused columns c in N[row]
//     N' = set all columns in N[row] to zero but column c
//     used' = mark c as used
//     recurse(used', row+1, G, P, N')
//   output no
//
//  recurse::(bool mat)->(bool mat)->(bool mat)->((bool mat) list)
letrec
    recurse mat g p =
        let solution m = isomorphism m g p => [m] | [] in
        letrec
            go m cs r = r == num_rows mat + 1 => solution m |
                val m' = prune m g p then
                forall_unused m' r cs (\c. \n.
                    let n'  = modify (mark_one c) r n  in
                    let cs' = modify (const T)    c cs in
                    go n' cs' (r+1)
                )
        in
        go mat (replicate (num_columns mat) F) 1
;

//==============================================================================
//
// ...
//
//==============================================================================

// For every pair '(x,y)' in 's', 'assoc x s == y' and 'rev_assoc y s == x'.
//  subst_verify::((string#string) list)->bool
let subst_verify s = all (\(u,t). all (\(x,y). (u == x) <==> (t == y)) s) s;

// Extends a substitution with another.
//  subst_extend::((string#string) list)->((string#string) list)->((string#string) list)
let subst_extend s u = map (second (subst s)) u @ s;

// Attempts to merge a list of substitutions, fails on conflicting mappings.
//  subst_merge::(((string#string) list) list)->(((string#string) list) opt)
let subst_merge ss = let s = flat ss in subst_verify s => SOME s | NONE;

//------------------------------------------------------------------------------

// Attemps to find a substitution such that both 'wexpr's match.
//  alpha::wexpr->wexpr->((string#string) list)
letrec
    alpha (W_X _)       (W_X _)       = []
/\  alpha (W_CONST _ _) (W_CONST _ _) = []
/\  alpha (W_NAMED_CONST n _ _) (W_NAMED_CONST m _ _) = [(n,m)]
/\  alpha (W_VAR _ n)   (W_VAR _ m)   = [(n,m)]
/\  alpha (W_EXPLICIT_VAR _ n)  (W_EXPLICIT_VAR _ m) = [(n,m)]
/\  alpha (W_AND a b)   (W_AND x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_OR a b)    (W_OR x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_NOT a)     (W_NOT x)     = (alpha a x)
/\  alpha (W_EQ a b)    (W_EQ x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_PRED p a)  (W_PRED q x)  = error "todo"
/\  alpha (W_GR a b)    (W_GR x y)    = (alpha a x) @ (alpha b y)
/\  alpha (W_ADD a b)   (W_ADD x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SUB a b)   (W_SUB x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_MUL a b)   (W_MUL x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_DIV a b)   (W_DIV x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_MOD a b)   (W_MOD x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SHL a b)   (W_SHL x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_SHR a b)   (W_SHR x y)   = (alpha a x) @ (alpha b y)
/\  alpha (W_ASHR a b)  (W_ASHR x y)  = (alpha a x) @ (alpha b y)
/\  alpha (W_SX _ a)    (W_SX _ x)    = (alpha a x)
/\  alpha (W_ZX _ a)    (W_ZX _ x)    = (alpha a x)
/\  alpha (W_ITE a b c) (W_ITE x y z) = (alpha a x) @ (alpha b y) @ (alpha c z)
/\  alpha (W_CAT as)    (W_CAT bs)    = flat (map2 (\a. \b. alpha a b) as bs) 
/\  alpha (W_SLICE i a) (W_SLICE j x) = error "todo"
/\  alpha (W_NAMED_SLICE n i a) (W_NAMED_SLICE m j x) = error "todo"
/\  alpha (W_UPDATE_NAMED_SLICE a n i b) (W_UPDATE_NAMED_SLICE x m j y) = error "todo"
/\  alpha (W_MEM_READ i n a)    (W_MEM_READ j m x) = error "todo"
/\  alpha (W_MEM_WRITE i n a b) (W_MEM_WRITE j m x y) = error "todo"
;

//------------------------------------------------------------------------------

let
    DBG_update_fn (W_UPDATE_FN lhs rhs) =
        sprintf "(UPDATE %s := %s)" (DBGwexpr lhs) (DBGwexpr rhs)
/\  DBG_update_fn (W_PHASE_DELAY lhs rhs) =
        sprintf "(PHASE %s := %s)" (DBGwexpr lhs) (DBGwexpr rhs)
;

// ...
//  alpha_leaf::(update_fn list)->(update_fn list)->(((string#string) list) opt)
let
    alpha_leaf fs1 fs2 =
        let
            alpha_pairs u1 u2 v1 v2 = subst_merge [alpha u1 v1, alpha u2 v2]
        in
        let
            alpha_fn (W_UPDATE_FN u1 u2)   (W_UPDATE_FN v1 v2)   = alpha_pairs u1 u2 v1 v2
        /\  alpha_fn (W_PHASE_DELAY u1 u2) (W_PHASE_DELAY v1 v2) = alpha_pairs u1 u2 v1 v2
        /\  alpha_fn _ _ = NONE
        in
        let
            alpha_fns fs =
                letrec
                    collect s []     []     = SOME s
                /\  collect s (x:xs) (y:ys) =
                        let go (SOME u) = collect (s @ u) xs ys
                        /\  go (NONE)   = NONE
                        in
                        go (alpha_fn x y)
                in
                collect [] fs1 fs
        in
        try_all (alpha_fns) (permutations fs2)
        //
        // let x = try_all (alpha_fns) (permutations fs2) in
        // has_value x => x |
        // let prt = map (\(x,y). sprintf "%s=%s" x y) in
        // let
        //     dbg (W_UPDATE_FN u1 u2) (W_UPDATE_FN v1 v2) =
        //         let a1 = alpha u1 v1 in
        //         let a2 = alpha u2 v2 in
        //         sprintf "%S;%S" (prt a1) (prt a2)
        // in
        // eprintf "\n%S\n%S\n%S"
        //   (map DBG_update_fn fs1)
        //   (map DBG_update_fn fs2)
        //   (map2 dbg fs1 fs2)
;

//------------------------------------------------------------------------------

//  lineup::(formal#(actual list) list)->(formal#actual list)
let lineup = flatmap (curry zip # both md_expand_vector md_expand_vectors);

//  lift::(formal#actual list)->(actual list)->(formal list)
let lift = map # rev_subst;

//  promote::(formal#actual list)->(formal#actual list)->(actual#actual list)->(formal#formal list)
let promote ns hs = curry zip # both (lift ns) (lift hs) # unzip;

//  formalize::(formal#(actual list) list)->(formal#(actual list) list)->(actual#actual list)->(formal#formal list)
let formalize fa_n fa_h = promote (lineup fa_n) (lineup fa_h);

// ...
//  unpack::({(string#string list)} opt list)->{((string#string list) list)} opt
let
    unpack ms =
        letrec
            go s []            = SOME s
        /\  go s ((NONE):xs)   = NONE
        /\  go s ((SOME x):xs) = go (x:s) xs
        in
        go [] ms
;

// ...
//  alpha_pinst::pexlif->pexlif->((string#string) list)
let
    alpha_pinst_leaf
        (PINST _ _ _ fa_inps1 fa_outs1 _ (P_LEAF fs1))
        (PINST _ _ _ fa_inps2 fa_outs2 _ (P_LEAF fs2))
        =
        let f = formalize (fa_inps1 @ fa_outs1) (fa_inps2 @ fa_outs2) in
        maybe (alpha_leaf fs1 fs2) (SOME # f)
;
// ...
let
    alpha_pinst_hier
        (PINST _ _ _ fa_inps1 fa_outs1 _ (P_HIER _))
        (PINST _ _ _ fa_inps2 fa_outs2 _ (P_HIER _))
        substs
        =
        let f = formalize (fa_inps1 @ fa_outs1) (fa_inps2 @ fa_outs2) in
        maybe (unpack substs) (flip maybe (SOME # f) # subst_merge)
;

//------------------------------------------------------------------------------

// Fill the 'j'th column of a matrix with values 'v'.
//  fill_column::int->*->(* mat)->(* mat)
let fill_column j v = transpose # modify (\c. replicate (length c) v) j # transpose;

// Traverse the nodes of an adjacency matrix in depth-first order, calling
// 'leaf' for leaf nodes and 'hier' to merge composite nodes.
//  traverse::(bool mat)->(int->*)->(int->(* list)->*)->*
let
    traverse adj leaf hier =
        letrec
            go am i =
                let am' = fill_column i F am in
                let rs  = forall_neighbors i am (cons # go am') [] in
                empty rs => leaf i | hier i rs
        in
        go adj 1
;

// ...
//  recover_one::(bool mat)->(bool mat)->(scheme list)->(scheme list)->((string#string) list)
let
    recover_one res adj needle haystack =
        let
            match_of i =
                letrec
                    go (F:xs) (a:as) = go xs as
                /\  go (T:xs) (a:as) = a
                in
                go (el i res) haystack
        in
        let pair_of i = (_scheme_pex (el i needle), _scheme_pex (match_of i)) in
        traverse adj
          (curry alpha_pinst_leaf # pair_of)
          (curry alpha_pinst_hier # pair_of)
;

// ...
//  recover_all::((bool mat) list)->(bool mat)->(scheme list)->(scheme list)->(((string#string) list) list)
let recover_all sols adj needle haystack = map (\res. recover_one res adj needle haystack) sols;

//==============================================================================
//
// ... Pretty-Printing.
//
//==============================================================================

// Pretty-print a matching.
//  print_match::((scheme#scheme) list)->{((string#string) list) opt}->string
let
    print_match ms (NONE) =
       let name_of = _pexlif_name # _scheme_pex in
       let pr_match n h = sprintf "%s=%s"  (name_of n) (name_of h) in
       sprintf "%s\n%s"
         (list2str T "{ " "\n, " "\n}" (curry pr_match) ms)
         "No alpha-eq. match found."
/\  print_match ms (SOME ss) =
       let name_of = _pexlif_name # _scheme_pex in
       let pr_subst n h = sprintf "%s->%s" n h in
       let pr_match n h = sprintf "%s=%s"  (name_of n) (name_of h) in
       sprintf "%s\n%s"
         (list2str T "{ " "\n, " "\n}" (curry pr_match) ms)
         (list2str T "{ " "\n, " "\n}" (curry pr_subst) ss)
;

// Pretty-print matches.
//  print_matches::((bool mat) list)->({((string#string) list) opt} list)->(scheme list)->(scheme list)->string
let
    print_matches res ss ns hs =
        let
            matches_of m =
                letrec
                    go c (F:xs) = go (c+1) xs
                /\  go c (T:xs) = el c hs
                in
                ixmap (\r. \i. (el i ns, go 1 r)) m
        in
        let pr_solution = print_match # matches_of in
        list2str T "\n===\n" "\n===\n" "\n" (curry pr_solution) (zip res ss)
;

//==============================================================================
//
// ... Debug.
//
//==============================================================================

let
    DBG_isomatch cmp g_pex p_pex =
        // Create haystack.
        let sc_g  = adj_build g_pex in
        let adj_g = adjacency_matrix sc_g in
        // Create needle.
        let sc_p  = adj_build p_pex in
        let adj_p = adjacency_matrix sc_p in
        // Create iso. matrix.
        let iso   = isomatch_matrix sc_g sc_p cmp in
        // Perform isomatch.
        let res   = recurse iso adj_g adj_p in
// Debug printing ----------------------
        val (_,t1) = wtime sc_g in
        val (_,t2) = wtime adj_g in
        let p1 = mat2str b2str adj_g in
        (fprintf stdout "-- Adj.G in (%s+%s):\n" t1 t2) fseq
        (fprintf stdout "%s\n" p1) fseq
        //
        val (_,t3) = wtime sc_p in
        val (_,t4) = wtime adj_p in
        let p2 = mat2str b2str adj_p in
        (fprintf stdout "-- Adj.P in (%s+%s):\n" t3 t4) fseq
        (fprintf stdout "%s\n" p2) fseq
        //
        val (_,t5) = wtime iso in
        let p3 = mat2str b2str iso in
        (fprintf stdout "-- Iso.M in %s:\n" t5) fseq
        (fprintf stdout "%s\n" p3) fseq
        //
        val (_,t6) = wtime res in
        let p4 = map (mat2str b2str) res in
        (fprintf stdout "-- Result in %s:\n" t6) fseq
        (foreach (fprintf stdout "%s\n") p4) fseq
//--------------------------------------
        res
;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));
