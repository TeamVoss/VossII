//------------------------------------------------------------------------------
// Random util. things.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Misc.

// Check if 'p' is satisfied with all elements of 'as'.
//  all::(a->bool)->(a list)->bool
let all p as = AND_list (map p as);

// Check if 'p' is satisfied with any element of 'as'.
//  any::(a->bool)->(a list)->bool
let any p as = OR_list (map p as);

// Non-infix version of (==) because I can't figure out how to write that.
//  equal::a->a->bool
let equal a b = a == b;

// Non-infix version of (!=) for a similar reason.
//  not_equal::a->a->bool
let not_equal a b = NOT (equal a b);

// Constant function.
//  const::a->b->a
let const a b = a;

// Flip the arguments of a function.
//  flip::(a->b->c)->b->a->c
let flip f a b = f b a;

// "Curry" a function.
//  curry::((a->b->c)->(a#b)->c
let curry f (a,b) = f a b;

// Un"curry" a function.
//  uncurry::((a#b)->c)->a->b->c
let uncurry f a b = f (a,b);

// Runs the binary function g on the results of applying unary function f to two arguments x and y.
//  on::(b->b->c)->(a->b)->a->a->c
let on g f x y = g (f x) (f y);
infix 3 on;

// "Map" with its arguments flipped.
let pam = flip map;

// Non-infix version of (,) because "(,) a b" doesn't seem to work.
let pair a b = (a,b);

// ...
//  sum_with::(a->int)->(a list)->int
let sum_with f as = itlist (\a. \s. f a + s) as 0;

//------------------------------------------------------------------------------
// Pairs

// Apply 'f' to the first element of pair '(a,b)'.
//  first::(a->c)->(a#b)->(c#b)
let first f (a,b) = (f a,b);

// Apply 'f' to the second element of a pair '(a,b)'.
//  second::(b->c)->(a#b)->(a#c)
let second f (a,b) = (a,f b);

//------------------------------------------------------------------------------
// List

// Drops the first element of a list.
//  butfirst::(a list)->(a list)
let butfirst (x:xs) = xs;

// Infinite list of repeated applications of 'f' to 'x'.
//     iterate::(a->a)->a->(a list)
letrec iterate f x = x : iterate f (f x);

// Fold (rigth-to-left) a list 'xs' with 'f' into 'b'.
//  ixlist::(a->int->b->b)->(a list)->b->b
let ixlist f xs b = snd (itlist (\x. \(ix,s). (ix-1,f x ix s)) xs (length xs,b));

// Modify the 'n'th element of a list 'xs' with 'f'.
//  modify::(a->a)->int->(a list)->(a list)
let modify f n xs = ixlist (\x. \ix. \ys. n == ix => f x : ys | x : ys) xs [];

//------------------------------------------------------------------------------
// String

// Drops the first 'n' characters from the string 's'.
//  string_butfirstn::string->int->string
let string_butfirstn s n = el (n+1) (iterate (string_tl) s);

// Short-hand for 'string_tl'.
//  string_butfirst::string->string
let string_butfirst = string_tl;

// Short-hand for 'string_butlastn 1'.
//  string_butlast::string->string
let string_butlast s = string_butlastn s 1;

//------------------------------------------------------------------------------
// Vector/Matrix (lists/list of lists).

// Set the 'n'th element of a list 'x' to 'v'.
//  list_update::a->int->(a vec)->(a vec)
let list_update v i = modify (const v) i;

// Set the '(i,j)'th element of matrix 'mat' to 'v'.
//  mat_update::a->(int#int)->(a mat)->(a mat)
let mat_update v (i,j) = modify (list_update v j) i;

//------------------------------------------------------------------------------
// Pexlif.

// Compare two 'VEC_INFO' to see if they're equal.
//  vec_info_eq::(vec_info list)->(vec_info list)->bool
let
    vec_info_eq vs ys =
        let
            check (TXT _)     (TXT _)     = T
        /\  check (RANGES ix) (RANGES jx) = ix == jx
        /\  check _           _           = F
        in
        (length vs) == (length ys) AND all (curry check) (zip vs ys)
;

// Feth a 'PEXLIF's attribute list.
//  attributes_of::pexlif->(string#string list)
let attributes_of (PINST _ as _ _ _ _ _) = as;

// Fetch the "fingerprint" attribute. If none exists, returns 0.
//  find_fingerprint::(string#string list)->int
let find_fingerprint as = find_first0 (\(n,_). n == "fingerprint") as;

//------------------------------------------------------------------------------
// Fingerprinting.
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Prime numbers.

// todo: replace with built in generator.
let list_of_primes = [
      2,      3,      5,      7,     11,     13,     17,     19,     23,     29,
     31,     37,     41,     43,     47,     53,     59,     61,     67,     71,
     73,     79,     83,     89,     97,    101,    103,    107,    109,    113,
    127,    131,    137,    139,    149,    151,    157,    163,    167,    173,
    179,    181,    191,    193,    197,    199,    211,    223,    227,    229,
    233,    239,    241,    251,    257,    263,    269,    271,    277,    281,
    283,    293,    307,    311,    313,    317,    331,    337,    347,    349,
    353,    359,    367,    373,    379,    383,    389,    397,    401,    409,
    419,    421,    431,    433,    439,    443,    449,    457,    461,    463,
    467,    479,    487,    491,    499,    503,    509,    521,    523,    541
  ];

// note: we cap the integers so that they fit in a 64-bit word.
let roof = ipow 2 63 - 1;

// ...
//  prime::int->int->int
let prime n v = (v * el n list_of_primes) % roof;

// ...
//  prime_list::(a->int)->int->(a list)->int
let prime_list f = flip (ixlist (\a.\i.\s. prime i (f a) + s));

//------------------------------------------------------------------------------
// Gen. of a fingerprint.

// Gen. a fingerprint for 'MEM'.
let
    fp_mem (MEM as l ds) = prime 0 as + prime 1 l + prime 2 ds
;

// Gen. a fingerprint for 'WEXPR'.
letrec
    fp_w (W_X s)		= prime 0 s
/\  fp_w (W_CONST s i)		= prime 1 s + prime 2 i
/\  fp_w (W_NAMED_CONST _ s i)	= prime 3 s + prime 4 i
/\  fp_w (W_VAR s _)		= prime 5 s
/\  fp_w (W_EXPLICIT_VAR s _)	= prime 6 s
/\  fp_w (W_AND a b)		= prime 7 (fp_w a + fp_w b)
/\  fp_w (W_OR a b)		= prime 8 (fp_w a + fp_w b)
/\  fp_w (W_NOT a)		= prime 9 (fp_w a)
/\  fp_w (W_EQ a b)		= prime 10 (fp_w a + fp_w b)
/\  fp_w (W_PRED _ a)		= prime 11 (fp_w a)
/\  fp_w (W_GR a b)		= prime 12 (fp_w a) + prime 13 (fp_w b)
/\  fp_w (W_ADD a b)		= prime 14 (fp_w a + fp_w b)
/\  fp_w (W_SUB a b)		= prime 15 (fp_w a) + prime 16 (fp_w b)
/\  fp_w (W_MUL a b)		= prime 17 (fp_w a) + prime 18 (fp_w b)
/\  fp_w (W_DIV a b)		= prime 19 (fp_w a) + prime 20 (fp_w b)
/\  fp_w (W_MOD a b)		= prime 21 (fp_w a) + prime 22 (fp_w b)
/\  fp_w (W_SHL a b)		= prime 23 (fp_w a) + prime 24 (fp_w b)
/\  fp_w (W_SHR a b)		= prime 25 (fp_w a) + prime 26 (fp_w b)
/\  fp_w (W_ASHR a b)		= prime 27 (fp_w a) + prime 28 (fp_w b)
/\  fp_w (W_SX s a)		= prime 29 s + prime 30 (fp_w a)
/\  fp_w (W_ZX s a)		= prime 31 s + prime 32 (fp_w a)
/\  fp_w (W_ITE a b c)          = prime 33 (fp_w a) + prime 34 (fp_w b)
                                                    + prime 35 (fp_w c)
/\  fp_w (W_SLICE ix a)	        = prime 36 (fp_w a) + prime_list id 0 ix
/\  fp_w (W_NAMED_SLICE _ ix a) = prime 37 (fp_w a) + prime_list id 0 ix
/\  fp_w (W_UPDATE_NAMED_SLICE a _ ix b)
                                = prime 38 (fp_w a) + prime 39 (fp_w b)
                                                    + prime_list id 0 ix
/\  fp_w (W_CAT as)             = prime_list fp_w 40 as
/\  fp_w (W_MEM_READ m a b)     = prime 41 (fp_mem m) + prime 42 (fp_w a)
                                                      + prime 43 (fp_w b)
/\  fp_w (W_MEM_WRITE m a b d)  = prime 44 (fp_mem m) + prime 45 (fp_w a)
                                                      + prime 46 (fp_w b)
                                                      + prime 47 (fp_w d)
;

// Gen. a fingerprint for 'UPDATE_FN'.
let
    fp_fn (W_UPDATE_FN l r)   = prime 48 (fp_w l) + prime 49 (fp_w r)
/\  fp_fn (W_PHASE_DELAY l r) = prime 50 (fp_w l) + prime 51 (fp_w r)
;

// Gen. a fingerprint for the "formals" of an input/output declaration.
// todo: consider the sizes of each formal argument (how to fetch them?).
let
    fp_formal ps = prime 58 (length ps)
;

// Gen. a fingerprint for the "actuals" of an input/output declaration.
let
    fp_actual ps =
        let fp_vi (TXT _)     = prime 54 1
        /\  fp_vi (RANGES ix) =
                let go (x,y) = x = y => prime 55 x | prime 56 x + prime 57 y in
                prime_list go 0 ix
        in
        let vss = map (map md_split_vector # snd) ps in
        prime_list (\vs. prime_list (\v. sum_with fp_vi v) 0 vs) 59 vss
;

// Gen. a fingerprint for 'CONTENT'.
let
    fp_c (P_LEAF fs) = prime 52 (length fs) + prime_list fp_fn   0 fs
/\  fp_c (P_HIER cs) =
        let go (PINST _ attrs _ fa_inps fa_outs _ _) =
            ( find_fingerprint attrs
            + fp_actual fa_inps
            + fp_actual fa_outs
            )
        in
        prime 51 (length cs) + prime_list go 0 cs
;

// Gen. a fingerprint for each 'PEXLIF' on creation (fingerprint 'c'?).
let
    PINST name attrs leaf fa_inps fa_outs internals content =
        let has_fingerprint = find_fingerprint attrs != 0 in
        let new_fingerprint = int2str
                ( fp_formal fa_inps
                + fp_formal fa_outs
                + fp_c content
                )
        in
        let new_attrs = has_fingerprint => attrs |
                ("fingerprint", new_fingerprint) : attrs
        in
        PINST name new_attrs leaf fa_inps fa_outs internals content
;

//------------------------------------------------------------------------------

// "entity" decl. of a 'PEXLIF'.
lettype scheme =
        SCHEME
            {name::string}
            {fp::int}
            {inps::(string#((vec_info list) list)) list}
            {outs::(string#((vec_info list) list)) list}
;

// Fetch the fingerprint of a 'SCHEME'.
let fp_of (SCHEME _ fp _ _) = fp;

let
    Pscheme scheme =
        val (SCHEME name fp inps outs) = scheme in
        let pr (f,a) = sprintf "(%s,%s)" f (list2str T "{" "," "}" vec_info2str a) in
        let i = list2str T "\n    [" "," "]" pr inps in
        let o = list2str T "\n    [" "," "]" pr outs in
        sprintf "\n(SCHEME name:\"%s\" fingerprint:%d %s %s)" name fp i o
;
install_print_function Pscheme;

// "Smart" constructor for a 'SCHEME'.
let
    scheme name attrs fa_inps fa_outs =
        let parse = map (second (map md_split_vector)) in
        let fp_ix = find_fingerprint attrs in
        let fp    = fp_ix == 0 => 0 | s2int (snd (el fp_ix attrs)) in
        SCHEME name fp (parse fa_inps) (parse fa_outs)
;

// Flatten a 'PEXLIF' into its 'SCHEME's.
//  flatten::pexlif->(scheme list)
letrec
    flatten (PINST name attrs _ fa_inps fa_outs _ (P_LEAF _)) =
        [scheme name attrs fa_inps fa_outs]
/\  flatten (PINST name attrs _ fa_inps fa_outs _ (P_HIER c)) =
        (scheme name attrs fa_inps fa_outs) : flatmap flatten c
;

// Check if two 'SCHEME's share a wire.
//  connected::scheme->scheme->bool
let
    connected (SCHEME name _ fa_inps fa_outs) (SCHEME name' _ fa_inps' fa_outs') =
        let shares_wire xs ys = any (\x. any (vec_info_eq x) ys) xs in
        let wires xs = flatmap snd xs in name == name' OR
        shares_wire
          (wires fa_inps  @ wires fa_outs)
          (wires fa_inps' @ wires fa_outs')
;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::(scheme list)->(int mat)
let adjacency_matrix sc = map (pam sc # connected) sc;
// todo: order nodes by connectivity

// Construct an isomatch matrix (possible matches) from two adjacency matrices.
//  isomatch_matrix::(scheme list)->(scheme list)->(bool mat)
let isomatch_matrix p_sc g_sc = map (pam g_sc # equal on fp_of) p_sc;

//------------------------------------------------------------------------------
// Ullmanâ€™s Subgraph Isomorphism Algorithm:
//   G - graph, or puzzle.
//   P - potential subgraphs of G, or piece.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//------------------------------------------------------------------------------

// Filter every index/pair of indices in a vector/matrix 'xs' using 'p'.
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
let forall_ones mat f = sitlist f (filter_rows id mat) mat;

// Iterate over every index in a col. that is a possible match.
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
// prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            )
        then m != m' => prune m' g p | m'
;

//------------------------------------------------------------------------------

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Iterate over all unused row-indices.
//  forall_unused::(bool list)->(int->a->a)->a->a
let forall_unused row f = sitlist f (filter_cols NOT row);

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used_columns, cur_row, G, P, M)
//   if cur_row = num_rows(M)
//     if M is an isomorphism:
//        output yes and end the algorithm
//   M' = M
//   prune(M')
//   for all unused columns c
//     set column c in M' to 1 and other columns to 0
//       -- 'c' at 'cur_row'? I might have missed that part during translation.
//     used_columns' = used_columns
//     mark c as used in used_columns'
//     recurse(used_column', cur_row+1, G, P, M')
//   output no
//
// recurse::(bool mat)->(bool mat)->(bool mat)->(bool list)->int->(bool#(bool mat))
letrec
    recurse mat g p cols row =
        row == length mat AND isomorphism mat g p => (T,mat)
          | val mat' = prune mat g p then
            forall_unused cols (\col. \(r,m). r => (r,m) |
                let m'    = modify (mark_one col) row m in
                let cols' = modify (const T) col cols in
                recurse m' g p cols' (row+1)
            ) (F,mat')
;

//------------------------------------------------------------------------------
// Fin.

// all NOT [T,T] = F;
// any NOT [F,T] = T;
// equal T T;
// const T F = T;
// flip const T F = F;
// curry const (T,F) = T;
// uncurry id T F = (T,F);
// first NOT (T,T) = (F,T);
// second NOT (T,T) = (T,F);
// butfirst [F,T] = [T];
// firstn 3 (iterate NOT T) = [T,F,T];
// ixlist (\a.\i.\b.(i>a):b) [2,2,2,2] [] = [F,F,T,T];
// modify NOT 2 [T,T,T] = [T,F,T];
// string_butfirstn "abc" 2 = "c";
// string_butfirst "abc" = "bc";
// string_butlast "abc" = "ab";
// list_update T 2 [F,F,F] = [F,T,F];
// mat_update T (2,2) [[F,F,F],[F,F,F],[F,F,F]] = [[F,F,F],[F,T,F],[F,F,F]];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];

//------------------------------------------------------------------------------
