//==============================================================================
//
// Random util. things that I think are just neat.
//
//==============================================================================

//------------------------------------------------------------------------------
// Misc. combinators.

// Check if 'p' is satisfied with all elements of 'as'.
//  all::(a->bool)->(a list)->bool
let all p as = AND_list (map p as);

// Check if 'p' is satisfied with any element of 'as'.
//  any::(a->bool)->(a list)->bool
let any p as = OR_list (map p as);

// Constant function.
//  const::a->b->a
let const a b = a;

// Flip the arguments of a function.
//  flip::(a->b->c)->b->a->c
let flip f a b = f b a;

// Infinite list of repeated applications of 'f' to 'x'.
//     iterate::(a->a)->a->(a list)
letrec iterate f x = x : iterate f (f x);

// "Curry" a function.
//  curry::((a->b->c)->(a#b)->c
let curry f (a,b) = f a b;

// Un"curry" a function.
//  uncurry::((a#b)->c)->a->b->c
let uncurry f a b = f (a,b);

// Runs the binary function g on the results of applying unary function f to two
// arguments x and y.
//  on::(b->b->c)->(a->b)->a->a->c
let on g f x y = g (f x) (f y);
infix 3 on;

// Takes two lists and returns a list of corresponding pairs. If one input list
// is short, excess elements of the longer list are discarded.
//  zip_uneven::(a list)->(b list)->((a#b) list)
letrec
    zip_uneven (x:xs) (y:ys) = (x,y) : zip_uneven xs ys
/\  zip_uneven _ [] = []
/\  zip_uneven [] _ = []
;

// Apply 'f' to the first element of pair '(a,b)'.
//  first::(a->c)->(a#b)->(c#b)
let first f (a,b) = (f a,b);

// Apply 'f' to the second element of a pair '(a,b)'.
//  second::(b->c)->(a#b)->(a#c)
let second f (a,b) = (a,f b);

// 'map' with its arguments flipped.
//  pam::(a list)->(a->b)->(b list)
let pam = flip map;

//------------------------------------------------------------------------------
// Non-infix versions of combinators/constructors.

// Non-infix version of (,).
//  pair::a->b->(a#b)
let pair a b = (a,b);

// Non-infix version of (:).
//  const::a->(a list)->(a list)
let cons a b = a : b;

// Non-infix version of (==).
//  equal::a->a->bool
let equal a b = a == b;

// Non-infix version of (!=).
//  not_equal::a->a->bool
let not_equal a b = NOT (equal a b);

//------------------------------------------------------------------------------
// List.

// Drops the first element of a list.
//  butfirst::(a list)->(a list)
let butfirst = tl;

// ...
//  itlist1::(a->a->a)->(a list)->a
let itlist1 f (x:xs) = itlist f xs x;

// Fold (rigth-to-left) a list 'xs' with 'f' into 'b'.
//  ixlist::(a->int->b->b)->(a list)->b->b
let ixlist f xs b = snd (itlist (\x. \(ix,s). (ix-1,f x ix s)) xs (length xs,b));

// Modify the 'n'th element of a list 'xs' with 'f'.
//  modify::(a->a)->int->(a list)->(a list)
let modify f n xs = ixlist (\x. \ix. \ys. n == ix => f x : ys | x : ys) xs [];

// Set the 'n'th element of a list 'x' to 'v'.
//  list_update::a->int->(a vec)->(a vec)
let list_update v i = modify (const v) i;

// Checks if an element is a memeber of the given list.
//  elem::a->(a list)->bool
let elem a as = find_first0 (equal a) as == 0 => F | T;

// ...
//  extend_with::int->a->(a list)->(a list)
letrec
    extend_with 0 _ as     = as
/\  extend_with n a []     = replicate n a
/\  extend_with n a (a:as) = a : extend_with (n-1) a as
;

// ...
//  sum::(int list)->int
let sum as = itlist (\a. \s. a + s) as 0;

//------------------------------------------------------------------------------
// Matrix.

// Count the number of rows in a matrix.
//  num_rows::(a mat)->int
let num_rows = length;

// Count the number of columns in a square matrix.
//  num_columns::(a mat)->int
let num_columns xs = empty xs => 0 | length (hd xs);

// Set the '(i,j)'th element of matrix 'mat' to 'v'.
//  mat_update::a->(int#int)->(a mat)->(a mat)
let mat_update v (i,j) = modify (list_update v j) i;

//------------------------------------------------------------------------------
// String

// Drops the first 'n' characters from the string 's'.
//  string_butfirstn::string->int->string
let string_butfirstn s n = el (n+1) (iterate (string_tl) s);

// Short-hand for 'string_tl'.
//  string_butfirst::string->string
let string_butfirst = string_tl;

// Short-hand for 'string_butlastn 1'.
//  string_butlast::string->string
let string_butlast s = string_butlastn s 1;

// Checks if a string is empty.
//  string_empty::string->bool
let string_empty s = strlen s == 0;

//------------------------------------------------------------------------------
// Vec_info.

// ...
// todo: Might fail if order of 'vec_info' changes.
//  vec_info_shared::(vec_info list)->(vec_info list)->bool
letrec
    vec_info_shared ((TXT v):vs) ((TXT y):ys) = v == y OR vec_info_shared vs ys
/\  vec_info_shared (v:vs)       (y:ys)       = vec_info_shared vs ys
/\  vec_info_shared _ _ = F
;

// Compare two 'VEC_INFO' to see if they're equal.
// todo: Might fail if order of 'vec_info' changes.
//  vec_info_eq::(vec_info list)->(vec_info list)->bool
let
    vec_info_eq vs ys =
        let
            check (TXT _)     (TXT _)     = T
        /\  check (RANGES ix) (RANGES jx) = ix == jx
        /\  check _           _           = F
        in
        (length vs) == (length ys) AND all (curry check) (zip vs ys)
;

//------------------------------------------------------------------------------
// Pexlif.

let attributes_of_pexlif (PINST _ as _ _ _ _ _) = as;

// Fetch the "fingerprint" attribute. If none exists, returns 0.
//  find_fingerprint::(string#string list)->int
let
    find_fingerprint as =
        let ix = find_first0 (\(n,_). n == "fingerprint") as in
        ix == 0 => 0 | s2int (snd (el ix as))
;

// Fetch the "signature" attribute. If none exists, returns the empty string.
//  find_signature::(string#string list)->string
let
    find_signature as =
        let ix = find_first0 (\(n,_). n == "signature") as in
        ix == 0 => "" | snd (el ix as)
;

//==============================================================================
//
// Signatures.
//
//==============================================================================

//------------------------------------------------------------------------------
// Gen. of a fingerprint.

load (DIR^"primes.fl"); // Needed for 'list_of_primes'.

// Max. value for fingerprints (should fit a 64-bit word).
//  roof::int
let roof = ipow 2 63 - 1;

// Multiply a value 'v' by the 'n'th prime (modulo 10,000), fitted to 64bits.
//  prime::int->int->int
let prime n v = (v * el (n % num_of_primes + 1) list_of_primes) % roof;

// Multiply each value by a prime, starting at some 'n', and sum the results.
//  prime_list::(a->int)->int->(a list)->int
let prime_list f = flip (ixlist (\a. \i. \s. prime i (f a) + s));

//------------------------------------------------------------------------------
// Gen. of "fingerprint".

// Gen. a fingerprint for 'MEM'.
//  fp_mem::MEM->int
let
    fp_mem (MEM as l ds) = prime 0 as + prime 1 l + prime 2 ds
;

// Gen. a fingerprint for 'WEXPR'.
//  fp_w::WEXPR->int
letrec
    fp_w (W_X s)		= prime 1 s
/\  fp_w (W_CONST s i)		= prime 2 s + prime 3 i
/\  fp_w (W_NAMED_CONST _ s i)	= prime 4 s + prime 5 i
/\  fp_w (W_VAR s _)		= prime 6 s
/\  fp_w (W_EXPLICIT_VAR s _)	= prime 7 s
/\  fp_w (W_AND a b)		= prime 8 (fp_w a + fp_w b)
/\  fp_w (W_OR a b)		= prime 9 (fp_w a + fp_w b)
/\  fp_w (W_NOT a)		= prime 10 (fp_w a)
/\  fp_w (W_EQ a b)		= prime 11 (fp_w a + fp_w b)
/\  fp_w (W_PRED _ a)		= prime 12 (fp_w a)
/\  fp_w (W_GR a b)		= prime 13 (fp_w a) + prime 14 (fp_w b)
/\  fp_w (W_ADD a b)		= prime 15 (fp_w a + fp_w b)
/\  fp_w (W_SUB a b)		= prime 16 (fp_w a) + prime 17 (fp_w b)
/\  fp_w (W_MUL a b)		= prime 18 (fp_w a) + prime 19 (fp_w b)
/\  fp_w (W_DIV a b)		= prime 20 (fp_w a) + prime 21 (fp_w b)
/\  fp_w (W_MOD a b)		= prime 22 (fp_w a) + prime 23 (fp_w b)
/\  fp_w (W_SHL a b)		= prime 24 (fp_w a) + prime 25 (fp_w b)
/\  fp_w (W_SHR a b)		= prime 26 (fp_w a) + prime 27 (fp_w b)
/\  fp_w (W_ASHR a b)		= prime 28 (fp_w a) + prime 29 (fp_w b)
/\  fp_w (W_SX s a)		= prime 30 s + prime 31 (fp_w a)
/\  fp_w (W_ZX s a)		= prime 32 s + prime 33 (fp_w a)
/\  fp_w (W_ITE a b c)          = prime 34 (fp_w a) + prime 35 (fp_w b)
                                                    + prime 36 (fp_w c)
/\  fp_w (W_SLICE ix a)	        = prime 37 (fp_w a) + prime_list id 1 ix
/\  fp_w (W_NAMED_SLICE _ ix a) = prime 38 (fp_w a) + prime_list id 1 ix
/\  fp_w (W_UPDATE_NAMED_SLICE a _ ix b)
                                = prime 39 (fp_w a) + prime 40 (fp_w b)
                                                    + prime_list id 1 ix
/\  fp_w (W_CAT as)             = prime_list fp_w 41 as
/\  fp_w (W_MEM_READ m a b)     = prime 42 (fp_mem m) + prime 43 (fp_w a)
                                                      + prime 44 (fp_w b)
/\  fp_w (W_MEM_WRITE m a b d)  = prime 45 (fp_mem m) + prime 46 (fp_w a)
                                                      + prime 47 (fp_w b)
                                                      + prime 48 (fp_w d)
;

// Gen. a fingerprint for 'UPDATE_FN'.
//  fp_fn::UPDATE_FN->int
let
    fp_fn (W_UPDATE_FN l r)   = prime 49 (fp_w l) + prime 50 (fp_w r)
/\  fp_fn (W_PHASE_DELAY l r) = prime 51 (fp_w l) + prime 52 (fp_w r)
;

// Gen. a fingerprint for the "formals" of an input/output declaration.
//  fp_formal::[str]->int
let
    fp_formal ps = prime 53 (sum (map md_size ps))
;

// Gen. a fingerprint for the internals of a 'PINST'.
//  fp_internal::[str]->int
let
    fp_internal ps = prime 54 (sum (map md_size ps))
;

// Gen. a fingerprint for 'CONTENT'.
//  fp_content::CONTENT->int
let
    fp_content (P_LEAF fs) = prime 59 (sum (map fp_fn fs))
/\  fp_content (P_HIER cs) =
        let go (PINST _ attrs _ fa_inps fa_outs int _) =
            ( find_fingerprint attrs
            + fp_internal int
            + fp_formal (map fst fa_inps)
            + fp_formal (map fst fa_outs)
            )
        in
        prime 65 (sum (map go cs))
;

// Gen. a fingerprint for the components of a 'PINST'.
//  fp_pinst::((str#(str list)) list)->((str#(str list)) list)->(str list)->content->str
let
    fp_pinst fa_inps fa_outs internals content = int2str
        ( fp_formal (map fst fa_inps)
        + fp_formal (map fst fa_inps)
        + fp_internal internals
        + fp_content content
        )
;

//------------------------------------------------------------------------------
// Gen. of SHA256 signature.

// Compute the SHA256 signature of a 'set' of components.
let sha_set = sha256_signature # qsort strcmp # map sha256_signature;

forward_declare{sha_content::content->string};
// Compute the SHA256 signature of a 'PINST'.
let
    sha_pinst name fa_inps fa_outs internals content = sha256_signature
        ( name
        , sha_set (map fst fa_inps)
        , sha_set (map fst fa_outs)
        , sha_set internals
        , sha_content content
        )
;

// Compute the SHA256 signature of a 'CONTENT'.
let
    sha_content (P_LEAF fs) = sha_set fs
/\  sha_content (P_HIER cs) =
        let
            sha_child (PINST name as _ fa_inps fa_outs internals content) =
                let new = sha_pinst name fa_inps fa_outs internals content in
                let old = find_signature as in
                string_empty old => new | old
        in
        sha256_signature (qsort strcmp (map sha_child cs))
;

//------------------------------------------------------------------------------
// Modify the 'PINST' creation.

// Gen. a fingerprint for each 'PEXLIF' on creation (fingerprint 'c'?).
let
    PINST name attrs leaf fa_inps fa_outs internals content =
        let fp  = ("fingerprint", fp_pinst fa_inps fa_outs internals content) in
        let sig = ("signature", sha_pinst name fa_inps fa_outs internals content) in
        find_fingerprint attrs != 0
          => PINST name attrs leaf fa_inps fa_outs internals content
          |  PINST name (fp : sig : attrs) leaf fa_inps fa_outs internals content
;

//==============================================================================
//
// ...
//
//==============================================================================

lettype scheme =
        SCHEME
            {node::pexlif}
            {label::string}
            {adjacent::scheme list}
            {inps::(((vec_info list) list)) list}
            {outs::(((vec_info list) list)) list}
;

let pexlif_of_scheme   (SCHEME p _ _ _ _) = p;
let label_of_scheme    (SCHEME _ l _ _ _) = l;
let adjacent_of_scheme (SCHEME _ _ a _ _) = a;
let inps_of_scheme     (SCHEME _ _ _ i _) = i;
let outs_of_scheme     (SCHEME _ _ _ _ o) = o;
let
    Pscheme (SCHEME p l a i o) =
        let name_of (PINST n _ _ _ _ _ _) = n in
        let pr_one  as  = list2str T "{" "," "}" Pvec_info as in
        let pr_list ass = list2str T "(" "," ")" pr_one ass in
        sprintf "%s(%s):%S:%S:%S" (name_of p) l
            (map (name_of # pexlif_of_scheme) a)
            (map pr_list i)
            (map pr_list o)
;
install_print_function Pscheme;

// "Smart" constructor for a 'SCHEME'.
//  mk_scheme::*parts of PEXLIF*->scheme
let
    mk_scheme pex label =
        val (PINST name _ _ fa_inps fa_outs _ _) = pex in
        let parse = map (\(f,a). (map md_split_vector a)) in
        SCHEME pex label [] (parse fa_inps) (parse fa_outs)
;

// ...
//  cons_adjacent_scheme::scheme->scheme->scheme
let
    cons_adjacent_scheme sc (SCHEME n l as i o) = (SCHEME n l (sc:as) i o)
;

// Checks if two 'SCHEME's are connected via a wire.
//  test_scheme::scheme->scheme->bool
let
    test_conn_scheme s1 s2 =
        let check_once  x  ys = any (any (vec_info_shared x)) ys in
        let check_twice xs ys = any (any (flip check_once ys)) xs in
        check_twice
            (inps_of_scheme s1 @ outs_of_scheme s1)
            (inps_of_scheme s2 @ outs_of_scheme s2)
;

//------------------------------------------------------------------------------
// Construction of adj. nodes from a pexlif.

// ...
//  adj_length::(scheme,[scheme])->int
let
    adj_length (_,adj) = length adj + 1
;

// ...
//  adj_cons::(scheme,[scheme])->(scheme,[scheme])->(scheme,[scheme])
let
    adj_cons (s1,a1) (s2,a2) = NOT (test_conn_scheme s1 s2) => (s2,a2) |
        (cons_adjacent_scheme s1 s2,a2)
;

// Merge a "parent" node with its "children".
//  adj_merge::(scheme,[scheme])->[(scheme,[scheme])]->(scheme,[scheme])
let
    adj_merge (sc,adj) cs = (sc,itlist (\(s,a). append (s:a)) cs adj)
;

// Traverse each child in order.
//  adj_map::int->int->content->[(scheme,[scheme])];
forward_declare{adj_reduce::int->int->pexlif->(scheme#(scheme list))};
letrec
    adj_map id _ (P_LEAF _)  = []
/\  adj_map id d (P_HIER ps) =
        letrec
            go _ []     = []
        /\  go c (p:ps) =
                let an = adj_reduce c d p in
                let l  = adj_length an in
                an : go (c+l) ps
        in
        go id ps
;

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  adj_reduce::int->int->pexlif->(scheme,[scheme])
letrec
    adj_reduce id d pex =
        // Pattern-match against the 'PINST'.
        val (PINST n as _ fa_is fa_os int cont) = pex in
        // Construct an ... for the 'PINST'.
        let anode = (mk_scheme pex (int2str id), []) in
        // Check if we're at the 'bottom'.
        d == 0 => anode |
        // Fetch "anodes" for children.
        let d' = str_is_prefix "draw_" n => d-1 | d in
        let cs = adj_map (id+1) d' cont in
        // Find new adjacencies between children and this node.
        let anode' = itlist (adj_cons) cs anode in
        let cs'    = map (adj_cons anode) cs in
        // Merge this "anode" and its children.
        adj_merge anode' cs'
;

// Calls 'adj_reduce' and flattens its result.
//  adj_build::pexlif->int->[anode]
let
    adj_build pexlif depth = val (sc,adj) = adj_reduce 1 depth pexlif in (sc:adj)
;

//==============================================================================
//
// Ullman’s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

//------------------------------------------------------------------------------
// Creationg of adj. matrix.

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->[int]->[bool]
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

let adj_to_id = map (s2int # label_of_scheme) # adjacent_of_scheme;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::[scheme]->(bool mat)
let adjacency_matrix as = as fseq map (fill (length as) # adj_to_id) as;

//------------------------------------------------------------------------------
// Creation of iso. match matrix.

//  fp::pexlif->string
let pex_fp = int2str # find_fingerprint # attributes_of_pexlif # pexlif_of_scheme;

//  sha::pexlif->string
let pex_sha = find_signature # attributes_of_pexlif # pexlif_of_scheme;

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::[scheme]->[scheme]->(pexlif->string)->(bool mat)
let isomatch_matrix as_g as_p cmp = map (pam as_g # equal on cmp) as_p;

//------------------------------------------------------------------------------
// Pruning of match matrix.

// Filter every index/pair of indices in a vector/matrix 'xs' using 'p'.
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->((int#int)->a->a)->a->a
let forall_ones mat f = sitlist f (filter_rows id mat);

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            ) m
        then m != m' => prune m' g p | m'
;

//------------------------------------------------------------------------------
// Main "matching" algo.

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Iterate over all unused row-indices.
//  forall_unused::(bool mat)->int->(bool list)
//               ->(int->(bool mat)->((bool mat) list))
//               ->((bool mat) list)
let forall_unused m row used f =
        let unused = filter (NOT # flip el used) (filter_cols id (el row m)) in
        sitlist (\c. \ms. f c m @ ms) unused []
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used, row, G, P, M)
//   if row = num_rows(M) + 1
//     if M is an isomorphism
//        output yes and end the algorithm
//     if not
//        output no
//   N = prune(M)
//   for all unused columns c in N[row]
//     N' = set all columns in N[row] to zero but column c
//     used' = mark c as used
//     recurse(used', row+1, G, P, N')
//   output no
//
//  recurse::(bool mat)->(bool mat)->(bool mat)->((bool mat) list)
letrec
    recurse mat g p =
        let solution m = isomorphism m g p => [m] | [] in
        letrec
            go m cs r = r == num_rows mat + 1 => solution m |
                val m' = prune m g p then
                forall_unused m' r cs (\c. \n.
                    let n'  = modify (mark_one c) r n  in
                    let cs' = modify (const T)    c cs in
                    go n' cs' (r+1)
                )
        in
        go mat (replicate (num_columns mat) F) 1
;

//------------------------------------------------------------------------------

// ...
//  recover::(scheme list)->(scheme list)->((bool mat) list)->((scheme#scheme) mat)
let
    recover sc_g sc_p res =
        map (\s. forall_ones s (\(p,g). cons (el p sc_p,el g sc_g)) []) res
;

// ...
//  isomatch::(pexlif->string)->(pexlif,int)->(pexlif,int)->((scheme#scheme) mat)
let
    isomatch cmp (g_pex, g_dep) (p_pex, p_dep) =
        // Create haystack.
        let sc_g  = adj_build g_pex g_dep then
        let adj_g = adjacency_matrix sc_g then
        // Create needle.
        let sc_p  = adj_build p_pex p_dep then
        let adj_p = adjacency_matrix sc_p then
        // Perform isomatch.
        let iso_m = isomatch_matrix sc_g sc_p cmp then
        let res   = recurse iso_m adj_g adj_p then
        // Recover solution.
        recover sc_g sc_p res
;

// ...
//  isomatch_top::(pexlif->string)->pexlif->pexlif->((scheme#scheme) mat)
let isomatch_top cmp g_pex p_pex = isomatch cmp (g_pex,1) (p_pex,0);

// ...
//  isomatch_all::(pexlif->string)->pexlif->pexlif->((scheme#scheme) mat)
let isomatch_all cmp g_pex p_pex = isomatch cmp (g_pex,-1) (p_pex,-1);

//==============================================================================
//
// ...
//
//==============================================================================

//  extend::((scheme#scheme) mat)->...
let
    extend =
        0
;


//==============================================================================
//
// Printing res.
//
//==============================================================================

// Print-function for a single sol. list.
//  print_one::((scheme#scheme) list)->string
let
    print_one matches =
       let pr_schemes (SCHEME p1 l1 _ _ _) (SCHEME p2 l2 _ _ _) =
               val (PINST n1 _ _ _ _ _ _) = p1 in
               val (PINST n2 _ _ _ _ _ _) = p2 in
               sprintf "%s(%s) :-> %s(%s)" n1 l1 n2 l2
//                   (list2str T "[" "," "]" (curry pr_wires) (zip i1 i2))
//                   (list2str T "[" "," "]" (curry pr_wires) (zip o1 o2))
       in
       list2str T "{" "\n," "}" (curry pr_schemes) matches
;

// Print all solutions of a given sol. list.
//  print_all::((scheme#scheme) mat)->string
let print_all = list2str T "=== Solutions:\n" "\n" "\n" print_one;

// ...
//  print_all_ex::((scheme#scheme) mat)->(((scheme#scheme) mat) mat)->string
let print_all_ex ms es =
        let // ::(scheme#scheme)->((scheme#scheme) mat)->string
            print_pair (SCHEME _ l1 _ _ _) (SCHEME _ l2 _ _ _) ss =
                let header = sprintf "(%s)->(%s):\n" l1 l2 in
                list2str T header "\n" "\n" print_one ss
        in
        let //::((scheme#scheme) list)->(((scheme#scheme) mat) list)->string
            print_list match ssl =
                list2str T "--- Group solutions for " "" ""
                    (curry (curry print_pair)) (zip match ssl)
        in
        let //::((scheme#scheme) mat)->(((scheme#scheme) mat) mat)->string
            print_mat matches ssm =
                list2str T "=== Expanded solutions:\n" "\n" "\n"
                    (curry print_list) (zip matches ssm)
        in
        print_mat ms es
;

//==============================================================================
// Fin.

// all NOT [T,T] = F;
// any NOT [F,T] = T;
// equal T T;
// const T F = T;
// flip const T F = F;
// curry const (T,F) = T;
// uncurry id T F = (T,F);
// first NOT (T,T) = (F,T);
// second NOT (T,T) = (T,F);
// butfirst [F,T] = [T];
// firstn 3 (iterate NOT T) = [T,F,T];
// ixlist (\a.\i.\b.(i>a):b) [2,2,2,2] [] = [F,F,T,T];
// modify NOT 2 [T,T,T] = [T,F,T];
// string_butfirstn "abc" 2 = "c";
// string_butfirst "abc" = "bc";
// string_butlast "abc" = "ab";
// list_update T 2 [F,F,F] = [F,T,F];
// mat_update T (2,2) [[F,F,F],[F,F,F],[F,F,F]] = [[F,F,F],[F,T,F],[F,F,F]];
// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused
//     [[T,F,T,F,T,F,T]]
//     1
//     [F,F,F,F,T,T,T]
//     (\c. \m. (print (sprintf "%d " c)) fseq (F,m));

//------------------------------------------------------------------------------
