load (DIR^"lib/signatures.fl");
load (DIR^"lib/utils.fl");

//==============================================================================
//
// ...
//
//==============================================================================

//==============================================================================
// ...

// ...
lettype
    entity =
        ENTITY
            {name::string}
            {indices::index list}
andlettype
    index =
        INDEX {index::int}
      | RANGE {range::int#int}
      | SUBE  {sube::entity}
;

let _entity_name    (ENTITY n _) = n;
let _entity_indices (ENTITY _ i) = i;

forward_declare{Pindex::index->string};
let
    Pentity (ENTITY n rs) = sprintf "%s%s" n (list2str F "[" "," "]" Pindex rs)
;
install_print_function Pentity;

let
    Pindex (INDEX i)     = sprintf "%d" i
/\  Pindex (RANGE (l,u)) = sprintf "%d:%d" l u
/\  Pindex (SUBE e)      = Pentity e
;
install_print_function Pindex;

// ...
//  parse_vec::string->entity
let
    parse_vec s =
        val (e:rs) = md_split_vector s in
        let e'  = val (TXT n) = e in string_butlast n in
        let rs' = empty rs => [] | butlast rs in
        //
        let go (u,l) = u == l => INDEX u | RANGE (u,l) in
        let unpack (RANGES rs) = map go rs in
        //
        ENTITY e' (flatmap unpack rs')
;

// ...
//  test_vec::entity->entity->bool
let
    test_vec (ENTITY n1 rs1) (ENTITY n2 rs2) =
        let
            test (INDEX i1) (INDEX i2) = i1 == i2
        /\  test (RANGE r1) (RANGE r2) = r1 == r2
        /\  test _ _ = F
        in
        n1 == n2 AND all (curry test) (zip rs1 rs2)
;

// ...
//  size_vec::entity->int
let
    size_vec (ENTITY _ rs) =
        let diff (x,y) = iabs (y - x) in
        letrec
            size [] = 0
        /\  size (INDEX x:xs) = 1 + size xs
        /\  size (RANGE x:xs) = diff x + size xs
        in
        size rs
;

//------------------------------------------------------------------------------

// Splits off each index constraint in an entity to seperate entities.
//  explode_entity::entity->(entity list)
let
    explode_entity (ENTITY n rs) =
        let
            explode (INDEX i)     = [INDEX i]
        /\  explode (RANGE (i,j)) = map INDEX (i <= j => i upto j | i downto j)
        in
        map (\i. ENTITY n [i]) (flatmap explode rs)
;

// Groups index constraints for entities that share a common name.
//  implode_entities::(entity list)->entity
let
    implode_entity es =
        letrec
            implode []     = []
        /\  implode (x:[]) = [x]
        /\  implode ((INDEX i):(INDEX x):xs) =
                i == (x+1) OR i == (x-1) => implode (RANGE (i,x):xs) |
                INDEX i : implode (INDEX x:xs)
        /\  implode ((RANGE (i,j)):(INDEX x):xs) =
                i < j AND j == (x-1) => implode (RANGE (i,x):xs) |
                i > j AND j == (x+1) => implode (RANGE (i,x):xs) |
                RANGE (i,j) : implode (INDEX x:xs)
        in
        ENTITY (_entity_name (hd es)) (implode (flatmap _entity_indices es))
;

//==============================================================================
// ...

// ...
lettype scheme =
        SCHEME
            {pex::pexlif}
            {lbl::string}
            {adj::scheme list}
;

let _scheme_pex (SCHEME p _ _) = p;
let _scheme_lbl (SCHEME _ l _) = l;
let _scheme_adj (SCHEME _ _ a) = a;

let
    Pscheme (SCHEME p l a) =
        sprintf "%s(%s):%S" (_pexlif_name p) l (map (_pexlif_name # _scheme_pex) a)
;
install_print_function Pscheme;

//------------------------------------------------------------------------------

// "Smart" constructor for a 'SCHEME'.
//  mk_scheme::*parts of PEXLIF*->scheme
let mk_scheme pex label = SCHEME pex label [];

// ...
//  scheme_cons_adj::scheme->scheme->scheme
let scheme_cons_adj sc (SCHEME n l a) = (SCHEME n l (sc:a));

// Checks if two 'SCHEME's are connected via a wire.
//  test_scheme::scheme->scheme->bool
let
    scheme_shared (SCHEME p1 _ _) (SCHEME p2 _ _) = T
        // let check_one x  ys = any (any (test_vec x)) ys in
        // let check_all xs ys = any (any (flip check_one ys)) xs in
        // check_all o1 i2 OR check_all i1 o2
;

// Check if a scheme wraps a "leaf" 'pexlif'.
//  is_leaf_node::scheme->bool
let
    is_leaf_node (SCHEME ((PINST _ _ _ _ _ _ (P_LEAF _))) _ _) = T
/\  is_leaf_node _ = F
;

//==============================================================================
//
// Ullmanâ€™s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

//==============================================================================
// Creationg of adj. matrix.

// ...
//  adj_length::(scheme,[scheme])->int
let adj_length (_,adj) = length adj + 1;

// ...
//  adj_cons::(scheme,[scheme])->(scheme,[scheme])->(scheme,[scheme])
let adj_cons (s1,a1) (s2,a2) = (scheme_cons_adj s1 s2,a2);

// ...
//  adj_merge::(scheme,[scheme])->[(scheme,[scheme])]->(scheme,[scheme])
let adj_merge (sc,adj) cs = (sc,itlist (\(s,a). append (s:a)) cs adj);

// Traverse each child in order.
//  adj_map::int->content->[(scheme,[scheme])];
forward_declare{adj_reduce::int->pexlif->(scheme#(scheme list))};
letrec
    adj_map id (P_LEAF _)  = []
/\  adj_map id (P_HIER ps) =
        letrec
            go _ []     = []
        /\  go c (p:ps) =
                let an = adj_reduce c p in
                let l  = adj_length an in
                an : go (c+l) ps
        in
        go id ps
;

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  adj_reduce::int->pexlif->(scheme,[scheme])
letrec
    adj_reduce id pex =
        val (PINST n as _ fa_is fa_os int cont) = pex in
        //
        let anode = (mk_scheme pex (int2str id), []) in
        let cs = adj_map (id+1) cont in
        //
        let anode' = itlist (adj_cons) cs anode in
        let cs' = map (adj_cons anode) cs in
        //
        adj_merge anode' cs'
;

// Calls 'adj_reduce' and flattens its result.
//  adj_build::pexlif->int->[scheme]
let adj_build pex = val (sc,adj) = adj_reduce 1 pex in (sc:adj);

// Fetch the ID's of each node adjacent to the given one.
//  adj_to_id::scheme->(int list)
let adj_to_id = map (s2int # _scheme_lbl) # _scheme_adj;

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->(int list)->(bool list)
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::(scheme list)->(bool mat)
let adjacency_matrix as = map (fill (length as) # adj_to_id) as;

//==============================================================================
// Creation of iso. match matrix.

// Filter every index in a vector 'xs' using 'p'.
//  filter_cols::(a->bool)->(a list)->(int list)
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];

// Filter every pair of indices in matrix 'xs' using 'p'.
//  filter_rows::(a->bool)->(a mat)->((int#int) list)
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Remove every 'sc' and their adjacent nodes from the possible iso. solutions.
//  trim::(scheme list)->(bool mat)->(bool mat)
let
    trim sc iso =
        letrec
            adj s = adj_to_id s @ flatmap adj (_scheme_adj s)
        in
        let none = replicate (length iso) F in
        let aset = flatmap (\s. s2int (_scheme_lbl s) : adj s) sc in
        transpose (ixmap (\r. \ix. elem ix aset => none | r) (transpose iso))
;

//------------------------------------------------------------------------------

// ...
//  trim_non_top_matches::(scheme list)->(scheme list)->(bool mat)->(bool mat)
let
    trim_non_top_matches as_g as_p iso = 
        let poss_top = filter_cols id (hd iso) in
        let act_top  = adj_to_id (hd as_g) in
        let not_top  = filter (NOT # flip elem act_top) poss_top in
        let rem  = map (flip el as_g) not_top in
        trim rem iso
;

//------------------------------------------------------------------------------

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::[scheme]->[scheme]->(pexlif->string)->(bool mat)
let
    isomatch_matrix as_g as_p cmp =
        // Initial equalities.
        let iso = map (pam as_g # equal on cmp) as_p then
        // Filter by depth.
        let iso' = trim_non_top_matches as_g as_p iso then
        //
        iso'
;

// Fetch the fingerprint...
//  fp::pexlif->string
let pex_fp = int2str # find_fingerprint # _pexlif_attrs # _scheme_pex;

// Fetch the SHA256 signature...
//  sha::pexlif->string
let pex_sha = find_signature # _pexlif_attrs # _scheme_pex;

//==============================================================================
// Pruning of match matrix.

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->((int#int)->a->a)->a->a
let forall_ones mat f = sitlist f (filter_rows id mat);

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            ) m
        then m != m' => prune m' g p | m'
;

//==============================================================================
// Main "matching" algo.

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Iterate over all unused row-indices.
//  forall_unused::(bool mat)->int->(bool list)
//               ->(int->(bool mat)->((bool mat) list))
//               ->((bool mat) list)
let forall_unused m row used f =
        let unused = filter (NOT # flip el used) (filter_cols id (el row m)) in
        sitlist (\c. \ms. f c m @ ms) unused []
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used, row, G, P, M)
//   if row = num_rows(M) + 1
//     if M is an isomorphism
//        output yes and end the algorithm
//     if not
//        output no
//   N = prune(M)
//   for all unused columns c in N[row]
//     N' = set all columns in N[row] to zero but column c
//     used' = mark c as used
//     recurse(used', row+1, G, P, N')
//   output no
//
//  recurse::(bool mat)->(bool mat)->(bool mat)->((bool mat) list)
letrec
    recurse mat g p =
        let solution m = isomorphism m g p => [m] | [] in
        letrec
            go m cs r = r == num_rows mat + 1 => solution m |
                val m' = prune m g p then
                forall_unused m' r cs (\c. \n.
                    let n'  = modify (mark_one c) r n  in
                    let cs' = modify (const T)    c cs in
                    go n' cs' (r+1)
                )
        in
        go mat (replicate (num_columns mat) F) 1
;

//==============================================================================
// ...

let mat2str = matrix2str T "[" "\n," "," "]";
let b2str b = b => "T" | "F";

// ...
//  recover::(scheme list)->(scheme list)->((bool mat) list)->((scheme#scheme) mat)
let
    recover sc_g sc_p res =
        map (\s. forall_ones s (\(p,g). cons (el p sc_p,el g sc_g)) []) res
;

// ...
//  isomatch::(pexlif->string)->(pexlif,int)->(pexlif,int)->((scheme#scheme) mat)
let
    isomatch cmp g_pex p_pex =
        // Create haystack.
        let sc_g  = adj_build g_pex in
        let adj_g = adjacency_matrix sc_g in
        // Create needle.
        let sc_p  = adj_build p_pex in
        let adj_p = adjacency_matrix sc_p in
        // Create iso. matrix.
        let iso   = isomatch_matrix sc_g sc_p cmp in
        // Perform isomatch.
        let res   = recurse iso adj_g adj_p in
        // Recover solution.
        let sol   = recover sc_g sc_p res in
// Debug: ------------------------------
        val (_,t1) = wtime sc_g in
        val (_,t2) = wtime adj_g in
        let p1 = mat2str b2str adj_g in
        (fprintf stdout "-- Adj.G in (%s+%s):\n" t1 t2) fseq
        (fprintf stdout "%s\n" p1) fseq
        //
        val (_,t3) = wtime sc_p in
        val (_,t4) = wtime adj_p in
        let p2 = mat2str b2str adj_p in
        (fprintf stdout "-- Adj.P in (%s+%s):\n" t3 t4) fseq
        (fprintf stdout "%s\n" p2) fseq
        //
        val (_,t5) = wtime iso in
        let p3 = mat2str b2str iso in
        (fprintf stdout "-- Iso.M in %s:\n" t5) fseq
        (fprintf stdout "%s\n" p3) fseq
        //
        val (_,t6) = wtime res in
        let p4 = map (mat2str b2str) res in
        (fprintf stdout "-- Result in %s:\n" t6) fseq
        (foreach (fprintf stdout "%s\n") p4) fseq
        //
        val (_,t7) = wtime sol in
        (fprintf stdout "-- Recover in %s.\n" t7) fseq
//--------------------------------------
        sol
;

//==============================================================================
//
// ...
//
//==============================================================================

//==============================================================================
// Substitution.

// ...
//  subst::((string#string) list)->string->string
let subst s n = (assoc n s) catch n;

// ...
//  subst_wexpr::((string#string) list)->wexpr->wexpr
letrec
    subst_wexpr _ (W_X sz)               = W_X sz
/\  subst_wexpr _ (W_CONST sz v)         = W_CONST sz v
/\  subst_wexpr s (W_NAMED_CONST n sz v) = W_NAMED_CONST (subst s n) sz v
/\  subst_wexpr s (W_VAR sz n)           = W_VAR sz (subst s n)
/\  subst_wexpr s (W_EXPLICIT_VAR sz n)  = W_EXPLICIT_VAR sz (subst s n)
/\  subst_wexpr s (W_AND a b)            = W_AND (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_OR a b)             = W_OR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_NOT a)              = W_NOT (subst_wexpr s a)
/\  subst_wexpr s (W_EQ a b)             = W_EQ (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_PRED n c)           = W_PRED (subst s n) (subst_wexpr s c)
/\  subst_wexpr s (W_GR a b)             = W_GR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_ADD a b)            = W_ADD (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SUB a b)            = W_SUB (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_MUL a b)            = W_MUL (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_DIV a b)            = W_DIV (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_MOD a b)            = W_MOD (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SHL a b)            = W_SHL (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SHR a b)            = W_SHR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_ASHR a b)           = W_ASHR (subst_wexpr s a) (subst_wexpr s b)
/\  subst_wexpr s (W_SX sz w)            = W_SX sz (subst_wexpr s w)
/\  subst_wexpr s (W_ZX sz w)            = W_ZX sz (subst_wexpr s w)
/\  subst_wexpr s (W_ITE c t e)          = W_ITE (subst_wexpr s c) (subst_wexpr s t) (subst_wexpr s e)
/\  subst_wexpr s (W_SLICE i w)          = W_SLICE i (subst_wexpr s w)
/\  subst_wexpr s (W_NAMED_SLICE n i w)  = W_NAMED_SLICE (subst s n) i (subst_wexpr s w)
/\  subst_wexpr s (W_UPDATE_NAMED_SLICE b n i w) = W_UPDATE_NAMED_SLICE (subst_wexpr s b) (subst s n) i (subst_wexpr s w)
/\  subst_wexpr s (W_CAT ps)             = W_CAT (map (subst_wexpr s) ps)
/\  subst_wexpr s (W_MEM_READ i m a)     = W_MEM_READ i (subst_wexpr s m) (subst_wexpr s a)
/\  subst_wexpr s (W_MEM_WRITE i m a d)  = W_MEM_WRITE i (subst_wexpr s m) (subst_wexpr s a) (subst_wexpr s d)
;

// ...
//  subst_fn::((string#string) list)->update_fn->update_fn
let
    subst_fn s (W_UPDATE_FN l r)   = W_UPDATE_FN (subst_wexpr s l) (subst_wexpr s r)
/\  subst_fn s (W_PHASE_DELAY l r) = W_PHASE_DELAY (subst_wexpr s l) (subst_wexpr s r)
;

//==============================================================================
// ...

// Given a list of formal names, finds each name's actuals.
//  find_actuals::pexlif->(string list)->((string list) list)
let
    find_actuals (PINST _ _ _ fa_inps fa_outs _ _) names =
        let expand = map (second (md_expand_vectors)) in
        let inps = expand fa_inps in
        let outs = expand fa_outs in
        //
        map (flip assoc (inps @ outs)) names
;

// ...
//  formal_to_actuals::pexlif->pexlif->((string#string) list)->((string#string) list)
let
    formal_to_actuals p1 p2 sub = 
        (curry zip) (both (flat # find_actuals p1) (flat # find_actuals p2) (unzip sub))
;

//------------------------------------------------------------------------------

// Given two "leaf" 'pexlif's, 'alpha_equality' attemps to find a substitution of
// their "formal" wire names s.t. the second pexlif's wexprs are syntactically
// equal to the first pexlif's wexprs. If no such substitution is found, returns
// an empty list.
//  alpha_equal::pexlif->pexlif->((string#string) list)
let
    alpha_equal
        (PINST _ _ _ fa_inps1 fa_outs1 _ (P_LEAF fs1))
        (PINST _ _ _ fa_inps2 fa_outs2 _ (P_LEAF fs2))
        =
        let perms  xs ys = map (zip xs) (permutations ys) in
        let test s xs ys = sha_set xs == sha_set (map (subst_fn s) ys) in
        letrec
            search []     f = []
        /\  search (s:ss) f = let s' = f s in empty s' => search ss f | s'
        in
        //
        let sub_inps = perms (map fst fa_inps2) (map fst fa_inps1) in
        let sub_outs = perms (map fst fa_outs2) (map fst fa_outs1) in
        search sub_inps (\sinp.
            search sub_outs (\sout.
                let sub = sinp @ sout in test sub fs1 fs2 => sub | []
        ))
;

// ...
//  alpha_equal_actual::pexlif->pexlif->((string#string) list)->((string#string) list)
let
    alpha_equal_actual p1 p2 =
        let
            alpha_equal_err p1 p2 = 
                let sub = alpha_equal p1 p2 in
                empty sub => error "not-alpha-equal" | sub
        in
        formal_to_actuals p1 p2 (alpha_equal_err p1 p2)
;

//------------------------------------------------------------------------------

// ...
//  merge_substitutions::(((string#string) list) list)->((string#string) list)
let
    merge_substitutions subs =
        let
            subst_err s n =
                let m = subst s n in
                m != n => error "not-subst-equal" | n
        in
        letrec
            merge sub []         = sub
        /\  merge sub ((a,b):ss) = (a,subst_err sub b) : merge sub ss
        in
        setify (itlist1 merge subs)
;

// ...
//  composite_equal::pexlif->pexlif->(((string#string) list) list)->((string#string) list)
let
    composite_equal p1 p2 subs =
        merge_substitutions (map (formal_to_actuals p1 p2) subs)
;

//------------------------------------------------------------------------------

letrec
    recover_pair (s1,s2) ss =
        // If the pair consists of leaf nodes we attempt to find a renaming.
        is_leaf_node s2 => alpha_equal_actual (_scheme_pex s1) (_scheme_pex s2) |
        // If not, we must recover every child pairing.
        let
            pairing_of pex =
                (find (equal pex # _scheme_pex # snd) ss) catch
                (error "not-matched-node")
        in
        let
            traverse children =
                map (flip recover_pair ss # pairing_of) children
        in
        let
            reduce subs =
                composite_equal (_scheme_pex s1) (_scheme_pex s2) subs
        in
        val (SCHEME ((PINST _ _ _ _ _ _ (P_HIER cs))) _ _) = s2 in
        reduce (traverse cs)
;

//  recover_solution::((scheme#scheme) list)->((string#string) list)
let
    recover_solution scs =
        undefined
;

//==============================================================================
//
// Printing res.
//
//==============================================================================

// Print-function for a single sol. list.
//  print_one::((scheme#scheme) list)->string
let
    print_one matches =
       let pr_schemes (SCHEME p1 l1 _) (SCHEME p2 l2 _) =
               val (PINST n1 _ _ _ _ _ _) = p1 in
               val (PINST n2 _ _ _ _ _ _) = p2 in
               sprintf "%s(%s) :-> %s(%s)" n1 l1 n2 l2
       in
       list2str T "{" "\n," "}" (curry pr_schemes) matches
;

// Print all solutions of a given sol. list.
//  print_all::((scheme#scheme) mat)->string
let print_all = list2str T "===\n" "\n===\n" "\n" print_one;

//==============================================================================
// Fin.

// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused [[T,F,T,F,T,F,T]] 1 [F,F,F,F,T,T,T] (\c. \m. (print (sprintf "%d " c)) fseq (F,m));
