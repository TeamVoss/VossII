//==============================================================================
//
// Random util. things that I think are just neat.
//
//==============================================================================

//------------------------------------------------------------------------------
// Misc. combinators.

// Check if 'p' is satisfied with all elements of 'as'.
//  all::(a->bool)->(a list)->bool
let all p as = AND_list (map p as);

// Check if 'p' is satisfied with any element of 'as'.
//  any::(a->bool)->(a list)->bool
let any p as = OR_list (map p as);

// Constant function.
//  const::a->b->a
let const a b = a;

// Flip the arguments of a function.
//  flip::(a->b->c)->b->a->c
let flip f a b = f b a;

// Infinite list of repeated applications of 'f' to 'x'.
//     iterate::(a->a)->a->(a list)
letrec iterate f x = x : iterate f (f x);

// "Curry" a function.
//  curry::((a->b->c)->(a#b)->c
let curry f (a,b) = f a b;

// Un"curry" a function.
//  uncurry::((a#b)->c)->a->b->c
let uncurry f a b = f (a,b);

// Runs the binary function g on the results of applying unary function f to two
// arguments x and y.
//  on::(b->b->c)->(a->b)->a->a->c
let on g f x y = g (f x) (f y);
infix 3 on;

// Takes two lists and returns a list of corresponding pairs. If one input list
// is short, excess elements of the longer list are discarded.
//  zip_uneven::(a list)->(b list)->((a#b) list)
letrec
    zip_uneven (x:xs) (y:ys) = (x,y) : zip_uneven xs ys
/\  zip_uneven _ [] = []
/\  zip_uneven [] _ = []
;

// Apply 'f' to the first element of pair '(a,b)'.
//  first::(a->c)->(a#b)->(c#b)
let first f (a,b) = (f a,b);

// Apply 'f' to the second element of a pair '(a,b)'.
//  second::(b->c)->(a#b)->(a#c)
let second f (a,b) = (a,f b);

// 'map' with its arguments flipped.
//  pam::(a list)->(a->b)->(b list)
let pam = flip map;

//------------------------------------------------------------------------------
// Non-infix versions of combinators/constructors.

// Non-infix version of (,).
//  pair::a->b->(a#b)
let pair a b = (a,b);

// Non-infix version of (:).
//  const::a->(a list)->(a list)
let cons a b = a : b;

// Non-infix version of (==).
//  equal::a->a->bool
let equal a b = a == b;

// Non-infix version of (!=).
//  not_equal::a->a->bool
let not_equal a b = NOT (equal a b);

//------------------------------------------------------------------------------
// List.

// Drops the first element of a list.
//  butfirst::(a list)->(a list)
let butfirst = tl;

// ...
//  itlist1::(a->a->a)->(a list)->a
let itlist1 f (x:xs) = itlist f xs x;

// Fold (rigth-to-left) a list 'xs' with 'f' into 'b'.
//  ixlist::(a->int->b->b)->(a list)->b->b
let ixlist f xs b = snd (itlist (\x. \(ix,s). (ix-1,f x ix s)) xs (length xs,b));

// Modify the 'n'th element of a list 'xs' with 'f'.
//  modify::(a->a)->int->(a list)->(a list)
let modify f n xs = ixlist (\x. \ix. \ys. n == ix => f x : ys | x : ys) xs [];

// Set the 'n'th element of a list 'x' to 'v'.
//  list_update::a->int->(a vec)->(a vec)
let list_update v i = modify (const v) i;

// Checks if an element is a memeber of the given list.
//  elem::a->(a list)->bool
let elem a as = find_first0 (equal a) as == 0 => F | T;

// ...
//  extend_with::int->a->(a list)->(a list)
letrec
    extend_with 0 _ as     = as
/\  extend_with n a []     = replicate n a
/\  extend_with n a (a:as) = a : extend_with (n-1) a as
;

// ...
//  sum::(int list)->int
let sum as = itlist (\a. \s. a + s) as 0;

//------------------------------------------------------------------------------
// Matrix.

// Count the number of rows in a matrix.
//  num_rows::(a mat)->int
let num_rows = length;

// Count the number of columns in a square matrix.
//  num_columns::(a mat)->int
let num_columns xs = empty xs => 0 | length (hd xs);

// Set the '(i,j)'th element of matrix 'mat' to 'v'.
//  mat_update::a->(int#int)->(a mat)->(a mat)
let mat_update v (i,j) = modify (list_update v j) i;

//------------------------------------------------------------------------------
// String

// Drops the first 'n' characters from the string 's'.
//  string_butfirstn::string->int->string
let string_butfirstn s n = el (n+1) (iterate (string_tl) s);

// Short-hand for 'string_tl'.
//  string_butfirst::string->string
let string_butfirst = string_tl;

// Short-hand for 'string_butlastn 1'.
//  string_butlast::string->string
let string_butlast s = string_butlastn s 1;

// Checks if a string is empty.
//  string_empty::string->bool
let string_empty s = strlen s == 0;

//------------------------------------------------------------------------------
// Vec_info.

// Compare two 'VEC_INFO' to see if they're equal.
//  vec_info_eq::(vec_info list)->(vec_info list)->bool
let
    vec_info_eq vs ys =
        let
            check (TXT _)     (TXT _)     = T
        /\  check (RANGES ix) (RANGES jx) = ix == jx
        /\  check _           _           = F
        in
        (length vs) == (length ys) AND all (curry check) (zip vs ys)
;

//------------------------------------------------------------------------------
// Pexlif.

let attributes_of_pexlif (PINST _ as _ _ _ _ _) = as;

// Fetch the "fingerprint" attribute. If none exists, returns 0.
//  find_fingerprint::(string#string list)->int
let
    find_fingerprint as =
        let ix = find_first0 (\(n,_). n == "fingerprint") as in
        ix == 0 => 0 | s2int (snd (el ix as))
;

// Fetch the "signature" attribute. If none exists, returns the empty string.
//  find_signature::(string#string list)->string
let
    find_signature as =
        let ix = find_first0 (\(n,_). n == "signature") as in
        ix == 0 => "" | snd (el ix as)
;

//==============================================================================
//
// Signatures.
//
//==============================================================================

//------------------------------------------------------------------------------
// Gen. of a fingerprint.

load "examples/primes.fl"; // Needed for 'list_of_primes'.

// Max. value for fingerprints (should fit a 64-bit word).
//  roof::int
let roof = ipow 2 63 - 1;

// Multiply a value 'v' by the 'n'th prime (modulo 10,000), fitted to 64bits.
//  prime::int->int->int
let prime n v = (v * el (n % num_of_primes) list_of_primes) % roof;

// Multiply each value by a prime, starting at some 'n', and sum the results.
//  prime_list::(a->int)->int->(a list)->int
let prime_list f = flip (ixlist (\a. \i. \s. prime i (f a) + s));

// Gen. a fingerprint for 'MEM'.
//  fp_mem::MEM->int
let
    fp_mem (MEM as l ds) = prime 0 as + prime 1 l + prime 2 ds
;

// Gen. a fingerprint for 'WEXPR'.
//  fp_w::WEXPR->int
letrec
    fp_w (W_X s)		= prime 1 s
/\  fp_w (W_CONST s i)		= prime 2 s + prime 3 i
/\  fp_w (W_NAMED_CONST _ s i)	= prime 4 s + prime 5 i
/\  fp_w (W_VAR s _)		= prime 6 s
/\  fp_w (W_EXPLICIT_VAR s _)	= prime 7 s
/\  fp_w (W_AND a b)		= prime 8 (fp_w a + fp_w b)
/\  fp_w (W_OR a b)		= prime 9 (fp_w a + fp_w b)
/\  fp_w (W_NOT a)		= prime 10 (fp_w a)
/\  fp_w (W_EQ a b)		= prime 11 (fp_w a + fp_w b)
/\  fp_w (W_PRED _ a)		= prime 12 (fp_w a)
/\  fp_w (W_GR a b)		= prime 13 (fp_w a) + prime 14 (fp_w b)
/\  fp_w (W_ADD a b)		= prime 15 (fp_w a + fp_w b)
/\  fp_w (W_SUB a b)		= prime 16 (fp_w a) + prime 17 (fp_w b)
/\  fp_w (W_MUL a b)		= prime 18 (fp_w a) + prime 19 (fp_w b)
/\  fp_w (W_DIV a b)		= prime 20 (fp_w a) + prime 21 (fp_w b)
/\  fp_w (W_MOD a b)		= prime 22 (fp_w a) + prime 23 (fp_w b)
/\  fp_w (W_SHL a b)		= prime 24 (fp_w a) + prime 25 (fp_w b)
/\  fp_w (W_SHR a b)		= prime 26 (fp_w a) + prime 27 (fp_w b)
/\  fp_w (W_ASHR a b)		= prime 28 (fp_w a) + prime 29 (fp_w b)
/\  fp_w (W_SX s a)		= prime 30 s + prime 31 (fp_w a)
/\  fp_w (W_ZX s a)		= prime 32 s + prime 33 (fp_w a)
/\  fp_w (W_ITE a b c)          = prime 34 (fp_w a) + prime 35 (fp_w b)
                                                    + prime 36 (fp_w c)
/\  fp_w (W_SLICE ix a)	        = prime 37 (fp_w a) + prime_list id 1 ix
/\  fp_w (W_NAMED_SLICE _ ix a) = prime 38 (fp_w a) + prime_list id 1 ix
/\  fp_w (W_UPDATE_NAMED_SLICE a _ ix b)
                                = prime 39 (fp_w a) + prime 40 (fp_w b)
                                                    + prime_list id 1 ix
/\  fp_w (W_CAT as)             = prime_list fp_w 41 as
/\  fp_w (W_MEM_READ m a b)     = prime 42 (fp_mem m) + prime 43 (fp_w a)
                                                      + prime 44 (fp_w b)
/\  fp_w (W_MEM_WRITE m a b d)  = prime 45 (fp_mem m) + prime 46 (fp_w a)
                                                      + prime 47 (fp_w b)
                                                      + prime 48 (fp_w d)
;

// Gen. a fingerprint for 'UPDATE_FN'.
//  fp_fn::UPDATE_FN->int
let
    fp_fn (W_UPDATE_FN l r)   = prime 49 (fp_w l) + prime 50 (fp_w r)
/\  fp_fn (W_PHASE_DELAY l r) = prime 51 (fp_w l) + prime 52 (fp_w r)
;

// Gen. a fingerprint for the "formals" of an input/output declaration.
//  fp_formal::[str]->int
let
    fp_formal ps = prime 53 (sum (map md_size ps))
;

// Gen. a fingerprint for the internals of a 'PINST'.
//  fp_internal::[str]->int
let
    fp_internal ps = prime 54 (sum (map md_size ps))
;

// Gen. a fingerprint for 'CONTENT'.
//  fp_content::CONTENT->int
let
    fp_content (P_LEAF fs) = prime 59 (sum (map fp_fn fs))
/\  fp_content (P_HIER cs) =
        let go (PINST _ attrs _ fa_inps fa_outs int _) =
            ( find_fingerprint attrs
            + fp_internal int
            + fp_formal (map fst fa_inps)
            + fp_formal (map fst fa_outs)
            )
        in
        prime 65 (sum (map go cs))
;

// Gen. a fingerprint for the components of a 'PINST'.
//  fp_pinst::((str#(str list)) list)->((str#(str list)) list)->(str list)->content->str
let
    fp_pinst fa_inps fa_outs internals content = int2str
        ( fp_formal (map fst fa_inps)
        + fp_formal (map fst fa_inps)
        + fp_internal internals
        + fp_content content
        )
;

//------------------------------------------------------------------------------
// Gen. of a SHA256 signature.

// Compute the SHA256 signature of a 'set' of components.
let sha_list = sha256_signature # qsort strcmp # map sha256_signature;

// Compute the SHA256 signature of a 'CONTENT'.
let
    sha_content (P_LEAF fs) = sha_list fs
/\  sha_content (P_HIER cs) =
        let
            sha_child (PINST name as _ fa_inps fa_outs internals content) =
                let new = sha_pinst name fa_inps fa_outs internals content in
                let old = find_signature as in
                string_empty old => new | old
        in
        sha256_signature (qsort strcmp (map sha_child cs))
;

// Compute the SHA256 signature of a 'PINST'.
let
    sha_pinst name fa_inps fa_outs internals content = sha256_signature
        ( name
        , sha_list (map fst fa_inps)
        , sha_list (map fst fa_outs)
        , sha_list internals
        , sha_content content
        )
;

//------------------------------------------------------------------------------
// Modify the 'PINST' creation.

// Gen. a fingerprint for each 'PEXLIF' on creation (fingerprint 'c'?).
let
    PINST name attrs leaf fa_inps fa_outs internals content =
        let fp  = ("fingerprint", fp_pinst fa_inps fa_outs internals content) in
        let sig = ("signature", sha_pinst name fa_inps fa_outs internals content) in
        find_fingerprint attrs != 0
          => PINST name attrs leaf fa_inps fa_outs internals content
          |  PINST name (fp : sig : attrs) leaf fa_inps fa_outs internals content
;

//==============================================================================
//
// ...
//
//==============================================================================

lettype scheme =
        SCHEME
            {name::string}
            {sig::string}
            {inps::(string#((vec_info list) list)) list}
            {outs::(string#((vec_info list) list)) list}
;

let name_of_scheme (SCHEME n _ _ _) = n;
let sig_of_scheme  (SCHEME _ s _ _) = s;
let inps_of_scheme (SCHEME _ _ i _) = i;
let outs_of_scheme (SCHEME _ _ _ o) = o;
let
    Pscheme (SCHEME n s i o) =
        let
            pr (f,as) = sprintf "%s<-%S" f
                (map (\a. list2str T "" "," "" Pvec_info a) as)
        in
        sprintf "%s(%s):%S:%S" n s (map pr i) (map pr o)
;
install_print_function Pscheme;

// "Smart" constructor for a 'SCHEME'.
//  mk_scheme::*parts of PEXLIF*->SCHEME
let
    mk_scheme name signature fa_inps fa_outs =
        let parse = map (second (map md_split_vector)) in
        SCHEME name signature (parse fa_inps) (parse fa_outs)
;

// Checks if two 'SCHEME's are connected via a wire.
//  test_scheme::SCHEME->SCHEME->bool
let
    test_scheme (SCHEME _ _ i1 o1) (SCHEME _ _ i2 o2) =
        let check xs ys = any (\x. any (\y. vec_info_eq x y) ys) xs in
        let wires xs = flatmap snd xs in
        check (wires i1 @ wires o1) (wires i2 @ wires o2)
;

//------------------------------------------------------------------------------
// ...

lettype anode =
        ANODE
            {id::int}
            {sig::int}
            {adj::int list}
;

let id_of_anode  (ANODE i _ _) = i;
let sig_of_anode (ANODE _ s _) = s;
let adj_of_anode (ANODE _ _ a) = a;
let
    Panode (ANODE i s as) =
        sprintf "%s(%s):%s"
            (int2str i)
            (int2str s)
            (list2str T "[" "," "]" int2str as)
;
install_print_function Panode;

// Cons a node to an 'ADJ.NODE's adjacencies.
//  cons_anode::anode->int->anode
let cons_anode a (ANODE i sig as) = ANODE i sig (cons a as);

//------------------------------------------------------------------------------
// Construction of adj. nodes from a pexlif.

// ...
//  xxx_length::(ANODE,SCHEME,[ANODE])->int
let xxx_length (_,_,c) = length c + 1;

// Connect two nodes if their SCHEME's share a wire.
//  xxx_connect::SCHEME->(ANODE,SCHEME,[ANODE])->(ANODE,SCHEME,[ANODE])
let
    xxx_connect r (a,s,c) = test_scheme s r =>
        (cons_anode (s2int (sig_of_scheme r)) a,s,c) | (a,s,c)
;

// Merge a "parent" node with its "children".
//  xxx_merge::(ANODE,SCHEME,[ANODE])->[(ANODE,SCHEME,[ANODE])]->(ANODE,SCHEME,[ANODE])
let xxx_merge (a,s,c) as = (a,s,itlist (\(b,_,d). append (b:d)) as c);

// Traverse a 'PINST' and record every node's adjacencies to other nodes.
//  xxx_reduce::int->int->PINST->(ANODE,SCHEME,[ANODE])
letrec
    xxx_reduce id d (PINST n as _ fa_is fa_os int cont) =
        // Traverse each child in order.
        //  xxx_map::int->int->content->((anode#(scheme#(anode list))) list);
        letrec
            xxx_map id _ (P_LEAF _)  = []
        /\  xxx_map id d (P_HIER ps) =
                letrec
                    go _ []     = []
                /\  go c (p:ps) =
                        let an = xxx_reduce c d p in
                        let l  = xxx_length an in
                        an : go (c+l) ps
                in
                go id ps
        in
        // Construct an 'adj.node' for this 'PINST'.
        let p = ( ANODE id (find_fingerprint as) []
                , mk_scheme n (int2str id) fa_is fa_os
                , [])
        in
        // Check if we're at the 'bottom'.
        d == 0 => p |
        // Fetch 'adj.node' for 'cont' children (only decrease 'depth' for non-"draw-nodes").
        let d' = str_is_prefix "draw_" n => d-1 | d in
        let ps = xxx_map (id+1) d' cont in
        // Compute adjacencies for 'p' and 'ps'.
        let sc (_,s,_) = s in
        let p'  = itlist (xxx_connect) (map sc ps) p in
        let ps' = map (xxx_connect (sc p)) ps in
        // Finally add new 'ps' as children to new 'p', droppin their 'SCHEME's.
        xxx_merge p' ps'
;

// Interface for 'xxx_reduce', simply calls the reduction with its initial
// values and flattens its result.
//  xxx::PINST->[ANODE]
let xxx pexlif depth = val (p,_,cs) = xxx_reduce 1 depth pexlif in (p:cs);

//==============================================================================
//
// Ullman’s Subgraph Isomorphism Algorithm.
//   G - Graph, or puzzle/haystack.
//   P - Potential subgraphs of G, or piece/needle.
//   M - |V(P)| x |V(G)| matrix that encodes possible subgraph isomorphisms.
//
//==============================================================================

//------------------------------------------------------------------------------
// Creationg of adj. matrix.

// Creates a list of 'max' elements with an 'T' at index 'i' if 'i' is present
// in the list 'xs' and 'F' if not.
//  fill::int->int->(bool list)
let fill max xs =
        letrec
            fill 0 rs = rs
        /\  fill n rs = F : fill (n-1) rs
        in
        letrec
            build n rs []     = fill (max-n) rs
        /\  build n rs (a:as) = build a (T : fill (a-n-1) rs) as
        in
        rev (build 0 [] xs)
;

// Construct an adjacency matrix (shared wires) for a 'PEXLIF'.
//  adjacency_matrix::[ANODE]->(bool mat)
let adjacency_matrix as = as fseq map (fill (length as) # adj_of_anode) as;

//------------------------------------------------------------------------------
// Creationg of iso. match matrix.

// Construct an isomatch matrix (possible matches) from two ...
//  isomatch_matrix::[ANODE]->[ANODE]->(bool mat)
let isomatch_matrix as_g as_p = map (pam as_g # equal on sig_of_anode) as_p;

//------------------------------------------------------------------------------
// Pruning of match matrix.

// Filter every index/pair of indices in a vector/matrix 'xs' using 'p'.
let filter_cols p xs = ixlist (\x. \ix. \ys. p x => ix : ys | ys) xs [];
let filter_rows p xs = ixlist (\x. \ix. \ys. map (pair ix) (filter_cols p x) @ ys) xs [];

// Iterate over every mat. index that is a possible match.
//  forall_ones::(bool mat)->((int#int)->a->a)->a->a
let forall_ones mat f = sitlist f (filter_rows id mat);

// Iterate over every index in a col. that is a possible match.
//  forall_neighbors::int->(bool mat)->(int->a->a)->a->a
let forall_neighbors i mat f = sitlist f (filter_cols id (el i mat));

// Thin the possible set of isomorphisms. The general idea is that, if we have
// M(x,y) then any neighbor v of x in P should have a neighbor u in G s.t.
// M(v,u) holds. Otherwise M(x,y) cannot be a solution.
//
// prune(...)
// do
//   for all (i,j) where M is 1
//     for all neighbors x of vi in P
//       if there is no neighbor y of vj in G s.t. M(x,y)
//         M(i,j) := F
// while M was changed
//
//  prune::(bool mat)->(bool mat)->(bool mat)->(bool mat)
letrec
    prune m g p =
        val m' =
            forall_ones m (\(i,j).
                forall_neighbors i p (\vi. \n.
                    forall_neighbors j g (\vj. const T) F
                        => n | mat_update F (i,j) n
                )
            ) m
        then m != m' => prune m' g p | m'
;

//------------------------------------------------------------------------------
// Main "matching" algo.

// "Dot-product" of two lists of booleans.
//  dot::(bool list)->(bool list)->bool
let dot xs ys = itlist (\z. \b. z OR b) (map2 (\x. \y. x AND y) xs ys) F;

// "Matrix multiplication" of two boolean matrices.
//  mult::(bool mat)->(bool mat)->(bool mat)
let mult m n = val n' = transpose n then map (pam n' # dot) m;

// Mark every el. as 'F', except the 'n'th el. that is marked as 'T'.
//  mark_one::int->(bool list)->(bool list)
let mark_one n xs = modify (const T) n (map (const F) xs);

// Iterate over all unused row-indices.
//  forall_unused::(bool mat)->int->(bool list)
//               ->(int->(bool mat)->((bool mat) list))
//               ->((bool mat) list)
let forall_unused m row used f =
        let unused = filter (NOT # flip el used) (filter_cols id (el row m)) in
        sitlist (\c. \ms. f c m @ ms) unused []
;

// Check that wether 'm' is a valid morphism for puzzle 'g' and piece 'p'.
//  isomorphism::(bool mat)->(bool mat)->(bool mat)->bool
let
    isomorphism mat g p =
        let only_one_solution mat =
            val (rs,cs) = unzip (filter_rows id mat) then
            let unique xs = setify xs == xs in
            unique rs AND unique cs
        in
        only_one_solution mat AND p == mult mat (transpose (mult mat g))
;

// Find ...
//
// recurse(used, row, G, P, M)
//   if row = num_rows(M) + 1
//     if M is an isomorphism
//        output yes and end the algorithm
//     if not
//        output no
//   N = prune(M)
//   for all unused columns c in N[row]
//     N' = set all columns in N[row] to zero but column c
//     used' = mark c as used
//     recurse(used', row+1, G, P, N')
//   output no
//
//  recurse::(bool mat)->(bool mat)->(bool mat)->((bool mat) list)
letrec
    recurse mat g p =
        let solution m = isomorphism m g p => [m] | [] in
        letrec
            go m cs r = r == num_rows mat + 1 => solution m |
                val m' = prune m g p then
                forall_unused m' r cs (\c. \n.
                    let n'  = modify (mark_one c) r n  in
                    let cs' = modify (const T)    c cs in
                    go n' cs' (r+1)
                )
        in
        go mat (replicate (num_columns mat) F) 1
;

//==============================================================================
//
// ...
//
//==============================================================================

// ...
//  recover_schemes::int->pexlif->(attrs->int)->(scheme list)
let
    recover_schemes d f pexlif =
        letrec
            go_pex d (PINST n as l fa_is fa_os int cont) =
                letrec
                        go_cont _ (P_LEAF _)  = []
                    /\  go_cont d (P_HIER ps) = flatmap (go_pex d) ps
                in
                let sc = mk_scheme n (find_signature as) fa_is fa_os in
                let d' = str_is_prefix "draw_" n => d-1 | d in
                d == 0 => [sc] |
                sc : go_cont d' cont
        in
        go_pex d pexlif
;

// ...
//  recover_all::((bool mat) list)->pexlif->pexlif->(attrs->int)->((scheme#scheme) list)
let
    recover_all res g p f =
        let g_sc = recover_schemes 1 f g then
        let p_sc = recover_schemes 1 f p then
        let
	    recover_one mat =
                let pairs_ix = forall_ones mat cons [] then
                map (\(i, j). (el i p_sc, el j g_sc)) pairs_ix
        in 
	map recover_one res
;

//------------------------------------------------------------------------------
// Filter solutions.

// ...
//  filter_all::((scheme#scheme)->bool)->((scheme#scheme) mat)->((scheme#scheme) mat)
letrec
    filter_all p []       = []
/\  filter_all p (sol:ss) =
        let ss' = filter_all p ss in all p sol => sol : ss' | ss'
;

//------------------------------------------------------------------------------
// Printing res.

// Print-function for a single sol. list.
//  print_one::((scheme#scheme) list)->string
let
    print_one match =
       let pr_wires a b = sprintf "%s->%s" (fst a) (fst b) in
       let pr_schemes (SCHEME n1 s1 i1 o1) (SCHEME n2 s2 i2 o2) =
           sprintf "%s(%s) ->\n %s(%s) where\n %s and\n %s" n1 s1 n2 s2
               (list2str T "[" "," "]" (curry pr_wires) (zip i1 i2))
               (list2str T "[" "," "]" (curry pr_wires) (zip o1 o2))
       in
       list2str T "{" "\n," "}" (curry pr_schemes) match
;

// Print all solutions of a given sol. list.
//  print_all::((scheme#scheme) mat)->string
let print_all = list2str T "Solutions:\n" "\n" "\n" print_one;

//------------------------------------------------------------------------------
// ...

// ...
//  solutions::((bool mat) list)->pexlif->pexlif->((scheme#scheme) list)
let solutions res g p = recover_all res g p find_fingerprint;

// ...
//  print_fp::((scheme#scheme) mat)->string
let print_fp ss = print_all ss;

// ...
//  print_sha256::((scheme#scheme) mat)->string
let
    print_sha256 ss =
        let p (s,r) = sig_of_scheme s == sig_of_scheme r in
        print_all (filter_all p ss)
;

//==============================================================================
// Fin.

// all NOT [T,T] = F;
// any NOT [F,T] = T;
// equal T T;
// const T F = T;
// flip const T F = F;
// curry const (T,F) = T;
// uncurry id T F = (T,F);
// first NOT (T,T) = (F,T);
// second NOT (T,T) = (T,F);
// butfirst [F,T] = [T];
// firstn 3 (iterate NOT T) = [T,F,T];
// ixlist (\a.\i.\b.(i>a):b) [2,2,2,2] [] = [F,F,T,T];
// modify NOT 2 [T,T,T] = [T,F,T];
// string_butfirstn "abc" 2 = "c";
// string_butfirst "abc" = "bc";
// string_butlast "abc" = "ab";
// list_update T 2 [F,F,F] = [F,T,F];
// mat_update T (2,2) [[F,F,F],[F,F,F],[F,F,F]] = [[F,F,F],[F,T,F],[F,F,F]];
// unused_rows [[F,T,F,T,F,T,F],[F,F,T,F,T,F,T]] = [F,T,T,T,T,T,T];
// filter_cols id [T,F,T] = [1,3];
// filter_rows id [[T,F],[F,T]] = [(1,1),(2,2)];
// forall_ones [[T,F],[F,T]] (\p. \l. p : l) [] = [(1,1),(2,2)];
// dot [T,F] [F,F] = F;
// mult [[T,T],[F,F]] [[F,F],[T,T]] = [[T,T],[F,F]];
// mark_one 2 [T,T,T] = [F,T,F];
// forall_unused
//     [[T,F,T,F,T,F,T]]
//     1
//     [F,F,F,F,T,T,T]
//     (\c. \m. (print (sprintf "%d " c)) fseq (F,m));

//------------------------------------------------------------------------------
