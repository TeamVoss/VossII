set_font font_large;
load "ste.fl";

TYPE "byte" 8;

// =============================================================
//  Simple example of mixed scalar and symbolic simulation
// =============================================================

// Visualizing is useful, but the main focus is the behavior of the circuit.
// In VossII the main workhorse is a (generalized) symbolic simulator: STE

// Consider the following simple circuit.
let example =
    bit_input	clk.
    bit_input	clear.
    bit_input	up.
    bit_input	down.
    byte_input  a b.
    byte_output sum.
    CELL "draw_hier example" [
	STATE clk sum [
	    clear   --- '0,
	    up	    --- sum '+' a '+' b,
	    down    --- sum '+' a '-' b
	]
];

let p = example 'clk 'clear 'up 'down 'a 'b 'sum;

let vis = STE_debug (pexlif2fsm p);
vis;


// The STE command takes a number of arguments:
//  flags -- provides setting for simulator (more later)
//  ckt	  -- circuit or visualization environment
//  wl    -- weakening list (more later)
//  ant   -- assumptions about signal values as list of 5-tuples
//  cons  -- assertions about signal values as list of 5-tuples
//  trl   -- nodes to be traced.
//
// Special case when using STE as a symbolic simulator:
// flags="-e", wl=cons=trl=[],
// ant= values to drive inputs
//
// A 5-tuple (w,n,v,f,t) shold be read as: 
//  When condition 'w', node 'n' should take value 'v' from 'f' to 't'.
//

// Too cumbersome to write lists of 5-tuples, so a small domain specific
// language has been created.
// For example:

"clk" is_clock 4;

"clear" is 1 in_cycle 0 followed_by
	   1 in_cycle 30 followed_by
	   1 in_cycle 50 otherwise 0 until 100 cycles;

// Together as a larger example:
let N = 100;
let ant = 
    "clk" is_clock N
  and
    "clear" is 1 in_cycle 0 followed_by
	       1 in_cycle 30 followed_by
	       1 in_cycle 50 otherwise 0 until N cycles
  and
    "up" is    1 in_cycle 2 for 10 cycles followed_by
	       0 for 5 cycles followed_by
	       1 for 20 cycles followed_by
	       0 for 10 cycles otherwise 0 until N cycles
  and
    "down" is  1 in_cycle 10 for 10 cycles followed_by
	       0 for 15 cycles followed_by
	       1 for 20 cycles followed_by
	       0 for 10 cycles otherwise 0 until N cycles
  and
    "a[7:0]" is 1 for 10 cycles followed_by
		3 for 2 cycles followed_by
		"c1[7:0]" for 1 cycle followed_by
		"c2[7:0]" for 1 cycle followed_by
		"c3[7:0]" for 1 cycle followed_by
		"c4[7:0]" for 1 cycle otherwise 0 until N cycles
  and
    "b[7:0]" is 0 for 3 cycles followed_by
		1 for 5 cycles followed_by
		7 for 5 cycles followed_by
		3 for 2 cycles followed_by
		"d1[7:0]" for 1 cycle followed_by
		"d2[7:0]" for 1 cycle followed_by
		"d3[7:0]" for 1 cycle followed_by
		"d4[7:0]" for 1 cycle otherwise 0 until N cycles
;

// Now run STE with this antecedent. Note no consequent!
let ste = STE "-e" vis [] ant [] [];
ste;

// Now add inputs and output to Waveforms window to see how the values change.

// Also note that back-annotation of he current values can be done.


// =============================================================
//  Example of simulation of HFL model
// =============================================================

// Simulation of HFL code with state machines.
load "diff_cache/diff_cache.fl";



// =============================================================
// Verification example
// =============================================================

// Load design.
let p = verilog2pexlif "-IM65C02" "M65C02_Core" [
					    "M65C02_Core.v",
					    "M65C02_MPCv4.v",
					    "M65C02_AddrGen.v",
					    "M65C02_ALU.v",
					    "M65C02_BCD.v",
					    "M65C02_BIN.v" ] []
;

// Start the GUI
let vis = STE_debug (pexlif2fsm p);
vis;

// Load ROM.
let ROM_ant file rom MAX_TIME =
    let fp = fopen file "r" then
    letrec rd addr =
	let line = fgets fp then
	line == "" => [] |
	let loc = sprintf "%s[%d][31:0]" rom addr then
	let vs = map (\c.c="1") (butlast (explode line)) in
	(map2 (\n.\v. (T,n,v,0,MAX_TIME)) (md_expand_vector loc) vs):
	(rd (addr+1))
    in
    let lines = rd 0 then
    (fclose fp) fseq
    flat lines
;

let N      = 20;                                    // Simulation length.
let a      = bv_variable "a[7:0]";                  // Accumulator sym. value.
let b      = bv_variable "b[7:0]";                  // Operand sym. value.
let res    = tl (fixed_bv2list 9 T (a + b));	    // Expected result.
                                                    // Expected carry flag.
let carry  = (bv_AND (bv_add (bv_ZX a) (bv_ZX b)) (int2bv 256)) != (int2bv 0);
let zero   = res = (replicate 8 F);                 // Expected zero flag.
let static =
    // Microprogram setup.
    "MC[2:0]"      is "0b100"     in_cycle 0 and  // Microcycle controller.
    "uPL[31:28]"   is "0b0101"    in_cycle 0 and  // Instruction field.
    "i3/dRst"      is "0x0"       in_cycle 0 and  // Delayed reset.
    "i1/PSW[5:0]"  is "0b000100"  in_cycle 1 and  // Program status word.
    "OP1[7:0]"     is "0x0"       in_cycle 0 and  // Operand one.
    "OP2[7:0]"     is "0x0"       in_cycle 0 and  // Operand two.
    // Constant.
    "Clk"  is_clock N          and                  // Clock.
    "Rst"  is "0" for N cycles and                  // Reset.
    "Wait" is "0" for N cycles and                  // Memory Wait.
    "Int"  is "0" for N cycles and                  // Interrupt.
    "xIRQ" is "0" for N cycles and                  // Interrupt Mask.
    // ROM.
    ROM_ant "M65C02/M65C02_uPgm_V3a.coe"    "uP_ROM" N and // Program ROM.
    ROM_ant "M65C02/M65C02_Decoder_ROM.coe" "ID_ROM" N     // Instruction ROM.
;

// Shorthands.
let a_bv = fixed_bv2list 8 T a;
let b_bv = fixed_bv2list 8 T b;

// 0x196 _ADC_imm, opcode 0x69.
let ant =
    "A[7:0]"  is a_bv    in_cycle 1 and
    "BA[8:0]" is "0x196" in_cycle 0 and
    "DI[7:0]" is "0x69"  in_cycle 0 and
    "DI[7:0]" is b_bv    in_cycle 4 and
    static
;

let cons =
    "A[7:0]"     is res     in_cycle 9
;

let ste  = STE "-e" vis [] ant cons [];
ste;

get_ste_result ste "strong";


// What if it fails?
let try_res    = tl (fixed_bv2list 9 T (a - b));
let cons =
    "A[7:0]"     is try_res     in_cycle 9
;

let ste  = STE "-e" vis [] ant cons [];
ste;

let ok = get_ste_result ste "strong";
ok;
forcing ok;

let failure_cond = NOT ok;

enumerate_examples 10 (depends (a_bv, b_bv)) failure_cond;

let sub = full_example F (depends ant) failure_cond;
sub;

let ant' = substitute sub ant;
let cons' = substitute sub cons;

substitute sub a_bv;
substitute sub b_bv;
substitute sub try_res;

STE "-e" vis [] ant' cons' [];


// =============================================================
// What about non-functional (relational) specifications?
// =============================================================

set_font font_large;
cload "ste.fl";

// The basic idea is to add an "observer" circuit.
// Example:

TYPE "word" 32;

let CSA =
    word_input  x y z.
    word_output c s.
    //
    internal m.
    CELL "draw_hier CSA" [
        s <- x '^' y '^' z,
        m <- x '&' y '|' x '&' z '|' y '&' z,
        c <- m '<<' '1
];


letrec CSA_tree =
    word_list_input	inps.
    word_output		C S.
    word_internal	t uC uS lC lS mC mS.
    CELL "draw_hier CSA_tree" (
	let sz = length inps in
	sz = 1 => [
	    S <- (el 1 inps),
	    C <- '0
	] |
	sz = 2 => [
	    S <- (el 1 inps),
	    C <- (el 2 inps)
	] |
	let upper = firstn (sz/2) inps in
	let lower = butfirstn (sz/2) inps in
	[
	    CSA_tree upper uC uS,
	    CSA_tree lower lC lS,
	    CSA uS lC lS mC mS,
	    CSA uC mC mS C S
	]
);

let fast_adder_tree =
    word_list_input	inps.
    word_output		sum.
    word_internal	C S.
    CELL "draw_hier fast_adder_tree" [
	CSA_tree inps C S,
	sum <- C '+' S
];

let p = fast_adder_tree ['i1,'i2,'i3,'i4,'i5,'i6,'i7,'i8] 'sum;

let vis = STE_debug (pexlif2fsm p);
vis;


let CSA_property i1 i2 i3 c s =
    let sum1 = i1 at_cycle 0 '+'
	       i2 at_cycle 0 '+'
	       i3 at_cycle 0
    in
    let sum2 = c at_cycle 0 '+' s at_cycle 0 in
    ASSERT "csa_sum" (sum1 '=' sum2)
;

var_order (interleave (map md_expand_vector ["a[31:0]","b[31:0]","c[31:0]"]));

let verify_CSA model i1 i2 i3 c s =
    let ant =
	i1 is "a[31:0]" in_cycle 0
      and
	i2 is "b[31:0]" in_cycle 0
      and
	i3 is "c[31:0]" in_cycle 0
    in
    let assumes = [] in
    let cons = [] in
    let asserts = [CSA_property i1 i2 i3 c s] in
    val (ckt, assume_ant, assert_cons) = rels2STE model assumes asserts then
    let wl = map (\n.T,n,0,2) (md_expand_vectors [i1,i2,i3]) in
    let final_ant = ant@assume_ant in
    let final_cons = cons@assert_cons in
    // NOTE: We need to strictly weaken the inputs (since the C[0]==0)
    // We also need to limit propagation since the BDDs would blow up otherwise
    let ste = STE "-e -w 1000" ckt wl final_ant final_cons [] in
    let res = get_ste_result ste "strong" then
    res == T => fprintf stdout "Successfully verified\n" |
    // Failed verification
    let failure_cond = NOT res in
    let sub = full_example F (depends final_ant) failure_cond then
    let final_ant' = substitute sub final_ant then
    let final_cons' = substitute sub final_cons then
    let vis = STE_debug ckt in
    (STE "-e -w 1000" vis wl final_ant' final_cons' []) fseq
    fprintf stderr "Failed. Counterexample simulated.\n"
;

verify_CSA p "i1/uC[31:0]" "i1/mC[31:0]" "i1/mS[31:0]" "C[31:0]" "S[31:0]";
verify_CSA p "i1/uS[31:0]" "i1/lC[31:0]" "i1/lS[31:0]"
	      "i1/mC[31:0]" "i1/mS[31:0]";
verify_CSA p "i1/i1/uC[31:0]" "i1/i1/mC[31:0]" "i1/i1/mS[31:0]"
	     "i1/uC[31:0]" "i1/uS[31:0]";
verify_CSA p "i1/i1/uS[31:0]" "i1/i1/lC[31:0]" "i1/i1/lS[31:0]"
	      "i1/i1/mC[31:0]" "i1/i1/mS[31:0]";

verify_CSA p "i1/i2/uC[31:0]" "i1/i2/mC[31:0]" "i1/i2/mS[31:0]"
	     "i1/lC[31:0]" "i1/lS[31:0]";
verify_CSA p "i1/i2/uS[31:0]" "i1/i2/lC[31:0]" "i1/i2/lS[31:0]"
	      "i1/i2/mC[31:0]" "i1/i2/mS[31:0]";



// Example of a failure (wrong signals connected).
verify_CSA p "i1/i2/uS[31:0]" "i1/i2/uC[31:0]" "i1/i2/lS[31:0]"
	      "i1/i2/mC[31:0]" "i1/i2/mS[31:0]";

