
lettype slist = SLIST {leaf::bool} ({bv#bv} opt) ({slist} opt);
let sNIL = SLIST T NONE NONE;
let sCONS e l = SLIST F (SOME e) (SOME l);

let is_sNIL (SLIST type opt_hd opt_tail) = type;
let is_sCONS (SLIST type opt_hd opt_tail) = NOT type;
let destr_sCONS (SLIST type (SOME hd) (SOME tl)) =  hd, tl;


lettype mem = MEM {initial_value::bv} {value_list::slist};
let initMem = MEM '0 sNIL;

lettype canvas = CANVAS {rows::int} {cols::int} {bitmap::mem ref};

let get_rows_and_cols canvas  =
    val (CANVAS rows cols m_r) = canvas then
    rows,cols
;

forward_declare {read :: mem->bv->bv};

let canvas2tcl canvas =
    val (CANVAS rows cols m_r) = canvas then
    let m = deref m_r then
    let mk_row r =
	let mk_col c =
	    let idx = {r::int}*{cols::int}+{c::int} in
	    let v = read m (int2bv idx) then
            v == ('0) => "black" |
            v == ('1) => "white" |
            "pink"
	in
	list2str T "{" " " "}" mk_col (0 upto (cols-1))
    in
    list2str T "{" "\n" "}" mk_row (0 upto (rows-1))
;


// ---- Visualization code ------
let Init_Tcl = tcl_eval [sprintf "source %s/visualize.tcl" DIR];
Init_Tcl;

let DRexamples images =
    let cnt = length images in
    val (rows, cols) = get_rows_and_cols (hd images) in
    let max_per_row = min cnt (max 1 (400/(2*cols+3))) in
    let rows_needed = (cnt+max_per_row-1)/max_per_row in
    Init_Tcl fseq
    let wc = tcl_eval [ sprintf "create_example_canvas %d %d %d %d"
                                rows cols rows_needed max_per_row]
    then
    let fp = mktemp "visualize" then
    letrec draw_ex cs cnt =
        cs = [] => () |
        val (c:cs) = cs then
        (fprintf fp "draw_example %s {} %d " wc cnt) seq
        (fprintf fp "%s" (canvas2tcl c)) fseq
        (fprintf fp "\n\n") fseq
        (draw_ex cs (cnt+1))
    in
    (draw_ex images 0) fseq
    let fname = stream2filename fp then
    (fprintf fp "update\n%s config -scrollregion [%s bbox all]" wc wc) fseq
    (fclose fp) fseq
    (tcl_eval [sprintf "source %s" fname]) fseq
    ()
;


let bv2fixlist size bv =
    let l = bv2list bv in
    let len = length l in
    len >= size => lastn size l |
    (replicate (size-len) (hd l))@l
;

let get_example canvas =
    let ns = depends canvas then
    let l = length ns then
    let i = random 0 (2**l-1) then
    let vs = bv2fixlist l (int2bv i) then
    let sub = zip ns vs then
    val (CANVAS rows cols m_r) = canvas then
    let m = deref m_r in
    let m' = substitute sub m then
    CANVAS rows cols (ref m')
;
non_lazy get_example;

let VIS cnt canvas =
    DRexamples (map (\i. get_example (i seq canvas)) (1 upto cnt))
;



// Actual code
let mk_canvas rows cols =
    CANVAS rows cols (ref (MEM '0 sNIL))
;
non_lazy mk_canvas;

let read mem addr =
    val (MEM init avs) = mem in
    letrec rd l assuming (is_sCONS l) =
	val ((a,v),rem) = destr_sCONS l in
	a = addr => v | rd rem
     /\    rd l = init
    in
    rd avs
;

let write mem addr data =
    val (MEM init avs) = mem in
    (MEM init (sCONS (addr,data) avs))
;

let get_pixel canvas row col =
    val (CANVAS rows cols m_r) = canvas then
    let m = deref m_r then
    let idx = row*(int2bv cols)+col in
    read m idx
;

let set_pixel canvas row col value =
    val (CANVAS rows cols m_r) = canvas then
    let m = deref m_r then
    let idx = row*(int2bv cols)+col in
    let m' = write m idx value then
    (m_r := m')
;


let draw_line (x0,y0) (x1,y1) canvas =
    //
    let dx = abs (x1 - x0) then
    let sx = (x0 < x1) => '1 | '-1 then
    let dy = '-1 * abs(y1 - y0) then
    let sy = (y0 < y1) => '1 | '-1 then
    let err = dx + dy then
    letrec step err x0 y0 =
        (set_pixel canvas x0 y0 '1) fseq
        ((x0 = x1) AND (y0 = y1)) => () |
        (
            let e2 = '2 * err then
            val (err, x0) =
                ( (e2 >= dy) ) => ((err + dy),(x0 + sx) )
                                  | (err,x0)
            in
            val (err, y0) =
                ( (e2 <= dx) ) => ((err + dx),(y0 + sy) )
                                  | (err,y0)
            in
            step err x0 y0
        )
    in
    (step err x0 y0) fseq
    canvas
;


let draw_circle (xc,yc) rad canvas =
    let x = '-1 * rad then
    let y = '0 then
    let err = '2 - '2 * rad then
    letrec step cond r err x y =
        cond == F => () |
        (set_pixel canvas (xc - x) (yc + y) '1) fseq
        (set_pixel canvas (xc - y) (yc - x) '1) fseq
        (set_pixel canvas (xc + x) (yc - y) '1) fseq
        (set_pixel canvas (xc + y) (yc + x) '1) fseq
        let r = err then
        val (y,err) =
            ( cond AND (r <= y) ) => (
                let y = y + '1 then
                let err = err + '2*y + '1 then
                (y,err)
            ) | (y,err)
        then
        val (x,err) =
            ( cond AND ((r > x) OR (err > y)) ) => (
                let x = x + '1 then
                let err = err + '2*x + '1 then
                (x,err)
            ) | (x,err)
        then
        let rcond = x >= '0 then
        (cond AND rcond) => () | (step (cond AND NOT rcond) r err x y)
    in
    (step T rad err x y) fseq
    canvas
;



let C1 = draw_line ('3,'19) ('20,'5) (mk_canvas 32 32);
VIS 5 C1;

let x0 = bv_constrained_variable "x0[5:0]" (\v. '0 < v AND v < '5);
let y0 = bv_constrained_variable "y0[5:0]" (\v. '0 < v AND v < '5);
let x1 = bv_constrained_variable "x1[5:0]" (\v. x0 < v AND v < '31);
let y1 = bv_constrained_variable "y1[5:0]" (\v. y0 < v AND v < '31);

let C2 = draw_line (x0,y0) (x1,y1) (mk_canvas 32 32);
C2;


let rad = bv_constrained_variable "y1[5:0]" (\v. '5 < v AND v < '15);

let C3 = draw_circle (x0,y0) rad (mk_canvas 32 32);
C3;
VIS 16 C3;

